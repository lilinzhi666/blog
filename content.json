{"meta":{"title":"lilinzhi","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-09-01T01:18:59.548Z","updated":"2022-09-01T01:18:59.548Z","comments":true,"path":"About/index.html","permalink":"http://example.com/About/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-01T01:18:59.548Z","updated":"2022-09-01T01:18:59.548Z","comments":true,"path":"Categories/index.html","permalink":"http://example.com/Categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-01T01:18:59.548Z","updated":"2022-09-01T01:18:59.548Z","comments":true,"path":"Archives/index.html","permalink":"http://example.com/Archives/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-01T01:19:55.943Z","updated":"2022-09-01T01:19:55.943Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-20T02:09:34.315Z","updated":"2022-08-20T02:09:34.315Z","comments":true,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":""}],"posts":[{"title":"函数式接口","slug":"函数式接口","date":"2022-10-09T07:00:58.000Z","updated":"2022-10-09T07:04:41.217Z","comments":true,"path":"2022/10/09/函数式接口/","link":"","permalink":"http://example.com/2022/10/09/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"函数式接口 作者：lilinzhi 1.消费型 ​ 消费型Consumer ​ 有参数，没有返回值 2.供应型 ​ 供应型Supplier ​ 没有参数，有返回值 3.功能型 ​ 功能性Function ​ 有参数，也有返回值 4.断言型 ​ 断言型Predicate ​ 有返回值–boolean 事情-判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Random;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import java.util.function.Supplier;/** * @author lilinzhi * @version 1.0 * @description: TODO * @date 2022/10/7 21:52 */public class Test &#123; public static void main(String[] args) &#123; //1.函数式接口 // 消费型Consumer // 有参数，没有返回值 Consumer&lt;String&gt; c1 =System.out::println; c1.accept(&quot;llz&quot;); // 2.供应型Supplier // 没有参数，有返回值 // 要一个0-9之间的随机整数 Supplier&lt;Integer&gt; s1 =()-&gt;&#123;return new Random().nextInt(10);&#125;; Integer integer = s1.get(); System.out.println(integer); //3.功能性Function apply // 有参数，也有返回值 //String------&gt;int Function&lt;String,Integer&gt; f1 =(String s)-&gt;&#123;return Integer.parseInt(s);&#125;; int v2 = f1.apply(&quot;123&quot;); System.out.println(v2); //4.断言型Predicate // 有返回值--boolean 事情-判断 // String---&gt;包含zzt Predicate&lt;String&gt; p1= (String s)-&gt;&#123;return s.contains(&quot;zzt&quot;);&#125;; boolean abczzt = p1.test(&quot;abczzt&quot;); System.out.println(abczzt); &#125;&#125;","categories":[],"tags":[{"name":"函数式接口","slug":"函数式接口","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"}]},{"title":"Stream流使用笔记","slug":"Stream流使用笔记","date":"2022-10-09T06:54:48.000Z","updated":"2022-10-09T07:05:39.499Z","comments":true,"path":"2022/10/09/Stream流使用笔记/","link":"","permalink":"http://example.com/2022/10/09/Stream%E6%B5%81%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Stream流使用笔记 作者：lilinzhi guava适合于构造动态List，虽然只是个语法题，但是易用性确实好很多，可以用一个简单语句代替之前用很多语句才能实现的功能，方便表达出程序员的想法。Guava里的很多方法都非常方便，相信基本都是来自于实践中的痛点，对JDK里的方法是个很好的补充。 12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;31.0.1-jre&lt;/version&gt; &lt;/dependency&gt; listA与listB的差级 listB与listA的差级 listA与listB的交集 listA与listB的并集（不去重） listA与listB的去重并集（不去重） 1234567891011121314151617181920212223242526272829303132333435363738394041import com.google.common.collect.Lists;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;/** * @author lilinzhi * @version 1.0 * @description: TODO * @date 2022/10/9 14:38 */public class test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; listA = Lists.newArrayList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;); ArrayList&lt;String&gt; listB = Lists.newArrayList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;); System.out.println(&quot;listA = &quot; + listA); System.out.println(&quot;listB = &quot; + listB); // listA和listB的差集（listA - listB） List&lt;String&gt; collect = listA.stream().filter(item -&gt; !listB.contains(item)).collect(Collectors.toList()); System.out.println(&quot;listA - listB的差集 = &quot; + collect); // listA和listB的差集（listB - listA） List&lt;String&gt; collect1 = listB.stream().filter(item -&gt; !listA.contains(item)).collect(Collectors.toList()); System.out.println(&quot;listB - listA的差集 = &quot; + collect1); // listA和listB交集 List&lt;String&gt; intersection = listA.stream().filter(listB::contains).collect(Collectors.toList()); System.out.println(&quot;listA和listB交集 = &quot; + intersection); // listA和listB并集（不去重） listA.addAll(listB); System.out.println(&quot;listA和listB并集 = &quot; + listA); // listA和listB并集（去重） List&lt;String&gt; distinctList = listA.stream().distinct().collect(Collectors.toList()); System.out.println(&quot;listA和listB去重并集 = &quot; + distinctList); &#125;&#125;","categories":[],"tags":[{"name":"Stream流使用笔记","slug":"Stream流使用笔记","permalink":"http://example.com/tags/Stream%E6%B5%81%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"}]},{"title":"提高生产力，最全MybatisPlus讲解","slug":"提高生产力，最全MybatisPlus讲解","date":"2022-10-07T05:29:52.000Z","updated":"2022-10-07T05:30:16.019Z","comments":true,"path":"2022/10/07/提高生产力，最全MybatisPlus讲解/","link":"","permalink":"http://example.com/2022/10/07/%E6%8F%90%E9%AB%98%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%8C%E6%9C%80%E5%85%A8MybatisPlus%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"问答专栏标签招聘活动 发现 注册登录 首页专栏小菜良记文章详情 1 提高生产力，最全 MyBatisPlus 讲解！蔡不菜丶发布于 2020-12-06 大家好，我是小菜，一个渴望在互联网行业做到蔡不菜的小菜。可柔可刚，点赞则柔，白嫖则刚！ 死鬼~看完记得给我来个三连哦！ 本文主要介绍 1MybatisPlus的使用 如有需要，可以参考 如有帮助，不忘 点赞 ❥ 微信公众号已开启，小菜良记，没关注的同学们记得关注哦！ 如果你每天还在重复写 CRUD 的 SQL，如果你对这些 SQL 已经不耐烦了，那么你何不花费一些时间来阅读这篇文章，然后对已有的老项目进行改造，必有收获！ 一、MP 是什么MP 全称 Mybatis-Plus ，套用官方的解释便是成为 MyBatis 最好的搭档,简称基友。它是在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1. 三大特性1）润物无声只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。 2）效率至上只需简单配置，即可快速进行单表 CRUD 操作，从而节省大量时间。 3）丰富功能代码生成、物理分页、性能分析等功能一应俱全。 2. 支持数据库 mysql 、mariadb 、oracle 、db2 、h2 、hsql 、sqlite 、postgresql 、sqlserver 、presto 、Gauss 、Firebird Phoenix 、clickhouse 、Sybase ASE 、 OceanBase 、达梦数据库 、虚谷数据库 、人大金仓数据库 、南大通用数据库 3. 框架结构 实话说，以上这些内容只要你打开官网也能看到，那么我们接下来就先来实际操作一番！ 二、MP实战1. 手摸手式项目练习1）数据库及表准备sql 语句： 12345678910111213use test;CREATE TABLE `student` ( `id` int(0) NOT NULL AUTO_INCREMENT, `dept_id` int(0) NULL DEFAULT NULL, `name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `remark` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Dynamic;-- ------------------------------ Records of student-- ----------------------------INSERT INTO `student` VALUES (1, 1, &#x27;小菜&#x27;, &#x27;关注小菜不迷路！&#x27;);INSERT INTO `student` VALUES (2, 2, &#x27;小明&#x27;, &#x27;好好学习，天天向上！&#x27;); 2）pom 依赖12345678910111213141516171819202122232425262728293031323334&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt;&lt;/dependency&gt;&lt;!--MP插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--Mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--JUNIT--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt;&lt;/dependency&gt; 3）配置文件123456spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver 4）实体类1234567891011121314@Data@Builder@TableName(&quot;student&quot;)public class User &#123; @TableId(type = IdType.AUTO) private Integer id; private Integer deptId; private String name; private String remark;&#125; 5）Mapper1public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 6）测试类1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void getAll() &#123; List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125;&#125;/** OUTPUT:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！)User(id=2, deptId=1, name=小明, remark=好好学习，天天向上！)**/ 小菜结： 在以上的结果，我们可以看到已经打印出了数据库中的全部数据（两条）。而并没有看到平时我们需要写的 mapper.xml 文件，只是用到了 usermapper 中的 selectList() 方法，而 UserMapper 继承了 BaseMapper 这个接口，这个接口便是 MybatisPlus 提供给我们的，我们再来看下这个接口给我们提供了哪些方法。 2. CRUD 基操1）insert12345678910@Testpublic void insert() &#123; //这里使用了 lombok 中的建造者模式构建对象 User user = User.builder().deptId(1).name(&quot;小华&quot;).remark(&quot;小华爱学习&quot;).build(); int insertFlag = userMapper.insert(user); log.info(&quot;插入影响行数,&#123;&#125; | 小华的ID: &#123;&#125;&quot;, insertFlag, user.getId());&#125;/** OUTPUT:插入影响行数,1 | 小华的ID: 8**/ 可以看到我们不仅插入了数据，而且还获取到了插入数据的ID，但是值得注意的是这里的 ID 虽然是自增的，但并非是 MP 默认的 ID生成策略，而是我们在实体类中指定的： 在 MP 中支持的主键生成策略有以下几种： 我们既然已经看到了 @TableId 这个注解，那我们再来关注一个常用注解 @TableField 从注解名上我们就可以看出，**@TableId** 是用来标记主键 ID 的，而 @TableField 是用来标记其他字段的。 可以看得出来这个注解中存在的值还是比较多的，下面介绍几个常用的值： value 用于解决字段名不一致问题和驼峰命名，比如实体类中属性名为 remark，但是表中的字段名为 describe ，这个时候就可以使用 @TableField(value=&quot;describe&quot;) 来进行转换。驼峰转换如果在全局中有配置驼峰命名，这个地方可不写。 exist 用于在数据表中不存在的字段，我们可以使用 @TableField(exist = false) 来进行标记 condition 用在预处理 WHERE 实体条件自定义运算规则，比如我配置了 @TableField(condition = SqlCondition.LIKE)，输出 SQL 为：select 表 where name LIKE CONCAT(&#39;%&#39;,值,&#39;%&#39;)，其中 SqlCondition 值如下： update 用在预处理 set 字段自定义注入，比如我配置了 @TableField(update = &quot;%s+1&quot;)，其中 %s 会填充字段，输出 SQL 为：update 表名 set 字段 = 字段+1 where 条件 select 用于是否查询时约束，如果我们有个字段 remark 是 text 类型的，查询的时候不想查询该字段，那么就可以使用 @TableField(select = false) 来约束查询的时候不查询该字段 2）updateMybatisPlus 的更新操作存在两种： 123int updateById(Param(&quot;et&quot;) T entity);int update(@Param(&quot;et&quot;) T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper); 根据 ID 更新12345678@Testpublic void update() &#123; User user = User.builder().id(3).name(&quot;小华&quot;).remark(&quot;小华爱玩游戏&quot;).build(); userMapper.updateById(user);&#125;/** 更新结果:User(id=3, deptId=1, name=小华, remark=小华爱玩游戏)**/ 根据条件更新123456789@Testpublic void update() &#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.eq(&quot;name&quot;,&quot;小华&quot;).set(&quot;remark&quot;,&quot;小华爱下棋&quot;); userMapper.update(null, updateWrapper);&#125;/** 更新结果:User(id=3, deptId=1, name=小华, remark=小华爱下棋)**/ 我们也可以将要更新的条件放进 user 对象 里面： 12345678910@Testpublic void update() &#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.eq(&quot;name&quot;,&quot;小华&quot;); User user = User.builder().remark(&quot;小华爱游泳&quot;).build(); userMapper.update(user, updateWrapper);&#125;/** 更新结果:User(id=3, deptId=1, name=小华, remark=小华爱游泳)**/ 3）delete在 MybatisPlus 中删除的方式相对于更新多，总共有四种： 1234567int deleteById(Serializable id);int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);int delete(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; wrapper);int deleteBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList); 根据 ID 删除1234567@Testpublic void deleteById() &#123; userMapper.deleteById(3);&#125;/** SQL语句：DELETE FROM student WHERE id = 3;**/ 根据 Map 删除12345678910@Testpublic void deleteByMap() &#123; HashMap&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); columnMap.put(&quot;name&quot;,&quot;小华&quot;); columnMap.put(&quot;remark&quot;,&quot;小华爱游泳&quot;); userMapper.deleteByMap(columnMap);&#125;/** SQL语句：DELETE FROM student WHRE name = &#x27;小华&#x27; AND remark = &#x27;小华爱游泳&#x27;;**/ 根据 Wrapper 删除123456789@Testpublic void delete() &#123; UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;(); wrapper.eq(&quot;remark&quot;,&quot;小华爱下棋&quot;); userMapper.delete(wrapper);&#125;/** SQL语句：DELETE FROM student WHRE remark = &#x27;小华爱下棋&#x27;;**/ 根据 Wrapper 删除还有另外一种方式，直接将实体类放入 Wrapper 中包装： 123456789@Testpublic void delete() &#123; User user = User.builder().remark(&quot;小华爱下棋&quot;).build(); UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;&gt;(user); userMapper.delete(wrapper);&#125;/** SQL语句：DELETE FROM student WHRE remark = &#x27;小华爱下棋&#x27;;**/ 根据 ID 批量删除12345678910@Testpublic void deleteBatchIds() &#123; List&lt;Integer&gt; idList = new ArrayList&lt;&gt;(); idList.add(4); idList.add(7); userMapper.deleteBatchIds(idList);&#125;/** SQL语句：DELETE FROM student WHERE id In (4,7)**/ 4）select查询操作在我们开发中是最经常用到的，也是重中之重。MybatisPlus 中支持查询的方法也比较多，如下： 12345678910111213141516171819T selectById(Serializable id);List&lt;T&gt; selectBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList);List&lt;T&gt; selectByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);Integer selectCount(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);List&lt;T&gt; selectList(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);List&lt;Object&gt; selectObjs(@aram(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); 可以看到总共有 10 个方法，我们接下来一个一个测试 查询所有123456789101112@Testpublic void selectList() &#123; List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println);&#125;/** OUTPUT:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！)User(id=2, deptId=1, name=小明, remark=好好学习，天天向上！) SQL语句:SELECT id, dept_id, name, remark FROM student;**/ 查询数量123456789101112@Testpublic void selectCount() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;,&quot;小&quot;); System.out.println(userMapper.selectCount(queryWrapper));&#125;/** OUTPUT:2 SQL语句:SELECT COUNT( 1 ) FROM student WHERE (name LIKE &#x27;%小%&#x27;);**/ 根据 ID 查询1234567891011@Testpublic void selectById() &#123; User user = userMapper.selectById(1); System.out.println(user);&#125;/** OUTPUT:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！) SQL语句:SELECT id, dept_id, name, remark FROM student WHERE ID = 1;**/ 根据 ID 批量查询123456789101112@Testpublic void selectBatchIds() &#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2)); users.forEach(System.out::println);&#125;/** OUTPUT:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！)User(id=2, deptId=1, name=小明, remark=好好学习，天天向上！) SQL语句:SELECT id, dept_id, name, remark FROM student WHERE ID IN (1, 2);**/ 根据条件查询单条12345678910111213@Testpublic void selectOne() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;name&quot;,&quot;小菜&quot;); User user = userMapper.selectOne(queryWrapper); System.out.println(user);&#125;/** OUTPUT:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！) SQL语句: SELECT id, name, dept_id, remark FROM student WHERE (name = &#x27;小菜&#x27;);**/ 根据条件查询多条通过 map 传递参数，不是通过 LIKE 查询，而是通过 &#x3D; 查询 12345678910111213@Testpublic void selectByMap() &#123; HashMap&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); columnMap.put(&quot;name&quot;,&quot;小&quot;); List&lt;User&gt; users = userMapper.selectByMap(columnMap); users.forEach(System.out::println);&#125;/** OUTPUT:null SQL语句:SELECT id, name, dept_id, remark FROM student WHERE name = &#x27;小&#x27;;**/ 如果我们没有新建实体类进行结果封装，我们还可以用 Map 来接收结果集： 1234567891011121314@Testpublic void selectMaps() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;,&quot;小&quot;); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125;/** OUTPUT:&#123;name=小菜, remark=关注小菜不迷路！, id=1, dept_id=1&#125;&#123;name=小明, remark=好好学习，天天向上！, id=2, dept_id=1&#125; SQL语句：SELECT id, name, dept_id, remark FROM student WHERE (name LIKE &#x27;%小%&#x27;);**/ 也可以用 Object 对象来接收结果集： 12345678910111213@Testpublic void selectObjs() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;, &quot;小&quot;); List&lt;Object&gt; objects = userMapper.selectObjs(queryWrapper);&#125;/** OUTPUT:&#123;name=小菜, remark=关注小菜不迷路！, id=1, dept_id=1&#125;&#123;name=小明, remark=好好学习，天天向上！, id=2, dept_id=1&#125; SQL语句：SELECT id, name, dept_id, remark FROM student WHERE (name LIKE &#x27;%小%&#x27;);**/ 分页查询12345678910111213141516171819202122232425@Testpublic void selectPage() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;, &quot;小&quot;); Page&lt;User&gt; page = new Page&lt;&gt;(1, 1); IPage&lt;User&gt; userIPage = userMapper.selectPage(page, queryWrapper); System.out.println(&quot;数据总数:&quot; + userIPage.getTotal()); System.out.println(&quot;总页数:&quot; + userIPage.getPages()); System.out.println(&quot;当前页:&quot; + userIPage.getCurrent()); System.out.println(&quot;页大小:&quot; + userIPage.getSize()); userIPage.getRecords().forEach(System.out::println);&#125;/** OUTPUT:数据总数:2总页数:2当前页:1页大小:1User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！) SQL语句： SELECT id, name, dept_id, remark FROM student WHERE (name LIKE &#x27;%小%&#x27;) LIMIT 0,1;**/ 3. 条件构造器 在 CRUD 的基本操作中，我们想要通过条件查询都是通过 Wrapper 类进行封装的，上面只是简单的用到 eq 和 like 操作。事实上这个类十分强大，我们在下面会详细进行介绍。 1）allEq全部 eq 或个别 isNull 1234567allEq(Map&lt;R, V&gt; params)allEq(Map&lt;R, V&gt; params, boolean null2IsNull)allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull) allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull)allEq(boolean condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull) 参数说明： param： key 为数据库字段名，value 为字段值 nullsIsNull：为 true 则在 map 的 value 为 null 时调用 isNull 方法，为 false 是则忽略 value 为 null 时不调用 isNull 方法 filter： 过滤函数，判断是否允许字段传入比对条件中 使用示例： allEq(Map&lt;R, V&gt; params) 123456789101112131415161718@Testpublic void testAllEq() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;,&quot;小菜&quot;); params.put(&quot;dept_id&quot;,1); params.put(&quot;remark&quot;,null); queryWrapper.allEq(params); //会调用 isNull 方法 userMapper.selectList(queryWrapper);&#125;/** 结果:｛｝ SQL语句: SELECT id,name,dept_id,remark FROM student WHERE (name = &#x27;小菜&#x27; AND dept_id = 1 AND remark IS NULL); **/ allEq(Map&lt;R, V&gt; params, boolean null2IsNull) 123456789101112131415161718@Testpublic void testAllEq() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;,&quot;小菜&quot;); params.put(&quot;dept_id&quot;,1); params.put(&quot;remark&quot;,null); queryWrapper.allEq(params, false); //不会调用 isNull 方法 userMapper.selectList(queryWrapper);&#125;/** 结果:User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！) SQL语句: SELECT id,name,dept_id,remark FROM student WHERE (name = &#x27;小菜&#x27; AND dept_id = 1); **/ allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull) 123456789101112131415161718@Testpublic void testAllEq() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;,&quot;小菜&quot;); params.put(&quot;dept_id&quot;,1); params.put(&quot;remark&quot;,null); queryWrapper.allEq(false,params,false); //不会带入条件进行查询 userMapper.selectList(queryWrapper);&#125;/** 结果:&#123;name=小菜, remark=关注小菜不迷路！, id=1, dept_id=1&#125;&#123;name=小明, remark=好好学习，天天向上！, id=2, dept_id=1&#125; SQL语句: SELECT id,name,dept_id,remark FROM student; **/ allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params) 12345678910111213141516171819@Testpublic void testAllEq() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;name&quot;, &quot;小菜&quot;); params.put(&quot;dept_id&quot;, 1); params.put(&quot;remark&quot;, null); //只有 key 中含有 “m” 才会用作条件判断 queryWrapper.allEq((k, v) -&gt; (k.contains(&quot;m&quot;)), params); userMapper.selectList(queryWrapper);&#125;/** 结果:0 SQL语句: SELECT id,name,dept_id,remark FROM student WHERE (name = &#x27;小菜&#x27; AND remark IS NULL); **/ 2）比较操作 eq： 相当于 = ne： 相当于 != gt： 相当于 &gt; ge： 相当于&gt;= lt： 相当于 &lt; le： 相当于&lt;= between： 相当于between ... and ... notBetween： 相当于not between ... and ... in： 相当于in(.., .., ..) notIn： 相当于not in(.., .., ..) 3）模糊查询 like： like(&quot;name&quot;,&quot;小菜&quot;) --&gt; name like &quot;%小菜%&quot; notLike： notLike(&quot;name&quot;,&quot;小菜&quot;) --&gt; name not like &quot;%小菜%&quot; likeLeft： like(&quot;name&quot;,&quot;小菜&quot;) --&gt; name like &quot;%小菜&quot; likeRight： like(&quot;name&quot;,&quot;小菜&quot;) --&gt; name like &quot;小菜%&quot; 4）排序 orderBy： 12 orderBy(boolean condition, boolean isAsc, R... columns)orderBy(true, true, &quot;id&quot;, &quot;name&quot;) --&gt; order by id ASC, name ASC orderByAsc： 1`orderByAsc(&quot;id&quot;,&quot;name&quot;) --&gt; order by id ASC, name ASC` orderByDesc： 1orderByDesc(&quot;id&quot;,&quot;name) --&gt; order by id Desc, name Desc` 5）逻辑查询 or： 拼接：主动调用 or 表示紧接着下一个方法不是用 and 连接!(不调用 or 则默认为使用 and 连接)， eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;) 嵌套：or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;)) and： 嵌套：and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;)) 6）select在MP查询中，默认查询所有的字段，如果有需要也可以通过select方法进行指定字段，如select(&quot;id&quot;, &quot;name&quot;) 4. 配置讲解1）基本配置 configLocation 用于指明 MyBatis 配置文件的位置，如果我们有 MyBatis 的配置文件，需将配置文件的路径配置到 configLocation 中 SpringBoot： 1mybatis-plus.config-location = classpath:mybatis-config.xml SpringMvc： 1234&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean mapperLocations 用于指明 Mapper 所对应的 XML 的文件位置，我们在 通用 CRUD 中用到的 Mapper 是直接继承 MP 提供的 BaseMapper ，我们也可以自定义方法，然后在 XML 文件中自定义 SQL，而这时我们需要告诉 Mapper 所对应 XML 文件的位置 SpringBoot： 1mybatis-plus.mapper-locations = classpath*:mybatis/*.xml SpringMVC： 1234&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mybatis/*.xml&quot;/&gt;&lt;/bean&gt; typeAliasesPackage 用于 MyBatis 别名包扫描路径，通过该属性可以给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名 SpringBoot： 1mybatis-plus.type-aliases-package = cbuc.life.bean SpringMVC： 12345&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;&lt;property name=&quot;typeAliasesPackage&quot;value=&quot;com.baomidou.mybatisplus.samples.quickstart.entity&quot;/&gt;&lt;/bean&gt; 2）进阶配置 mapUnderScoreToCamelCase 是否开启自动驼峰命名规则映射，这个配置的默认值是 true，但是这个属性在 MyBatis 中的默认值是 false，所以在我们平时的开发中都会将这个配置开启。 #关闭自动驼峰映射，该参数不能和mybatis-plus.config-location同时存在 mybatis-plus.configuration.map-underscore-to-camel-case &#x3D; false cacheEnabled 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存，默认为 true。 1mybatis-plus.configuration.cache-enabled = false 3）DB 策略配置 idType 全局默认主键类型，设置后，即可省略实体对象中的@TableId(type = IdType.AUTO)配置。该配置的默认值为 ID_WORKER SpringBoot： 1mybatis-plus.global-config.db-config.id-type = auto SpringMVC： 12345678910111213&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;globalConfig&quot;&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot;&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig&quot;&gt; &lt;property name=&quot;idType&quot; value=&quot;AUTO&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; tablePrefix 表名前缀，全局配置后可省略@TableName()配置。该配置的默认值为 null SpringBoot： 1mybatis-plus.global-config.db-config.table-prefix = yq_ SpringMVC： 1234567891011121314&lt;bean id=&quot;sqlSessionFactory&quot;class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;globalConfig&quot;&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot;&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig&quot;&gt; &lt;property name=&quot;idType&quot; value=&quot;AUTO&quot;/&gt; &lt;property name=&quot;tablePrefix&quot; value=&quot;yq_&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 5. 其他扩展1）自动填充有时候我们在插入或更新数据的时候，希望有些字段可以自动填充。比如我们平时数据表里面会有个 插入时间 或者 更新时间 这种字段，我们会默认以当前时间填充，在 MP 中我们也可以进行配置。 首先我们需要借助 @TableField(fill = FieldFill.INSERT) 这个注解，在插入时进行填充。 12@TableField(fill = FieldFill.INSERT)private String remark; 其中自动填充的模式如下： 123456789101112131415161718public enum FieldFill &#123; /** * 默认不处理 */ DEFAULT, /** * 插入时填充字段 */ INSERT, /** * 更新时填充字段 */ UPDATE, /** * 插入和更新时填充字段 */ INSERT_UPDATE&#125; 然后我们再编写自定义的填充处理模式： 123456789101112131415@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; Object remark = getFieldValByName(&quot;remark&quot;, metaObject); if (null == remark) &#123; setFieldValByName(&quot;remark&quot;, &quot;好好学习&quot;, metaObject); &#125; &#125; @Override public void updateFill(MetaObject metaObject) &#123; //自定义更新时填充 &#125;&#125; 测试： 12345678910@Testpublic void testObjectHandler() &#123; User user = User.builder().deptId(1).name(&quot;小明&quot;).build(); userMapper.insert(user);&#125;/** SQL语句：INSERT INTO student ( name, dept_id, remark )VALUES ( &#x27;小明&#x27;, 1, &#x27;好好学习&#x27; );**/ 可以看到插入时，已经自动将我们填充的字段合并进去。 2）逻辑删除在开发中，很多时候我们删除数据并不需要真正意义上的物理删除，而是使用逻辑删除，这样子查询的时候需要状态条件，确保被标记的数据不被查询到。 MP 当然也支持这样的功能。 我们需要先为 student 表添加一个字段 status 来声明数据是否被删除，0 表示被删除，1表示未删除，然后也需要在实体类上增加这个属性： 12@TableLogicprivate Integer status; 在 application.yaml 中配置： 12345mybatis-plus: global-config: db-config: logic-delete-value: 0 logic-not-delete-value: 1 测试： 123456789@Testpublic void testLogicDelete() &#123; userMapper.deleteById(1);&#125;/** SQL语句：UPDATE student SET status=0WHERE id=1 AND status=1;**/ 可以看出这段 SQL 并没有真正删除，而是进行了逻辑删除，只是更新了删除标识 3）通用枚举如果有性别之类的字段，我们通常会用 0 和 1 来表示，但是查出来我们得进行值转换，这个时候我们就可以使用枚举来解决这个问题： 首先为 student 表添加一个 sex 字段来表示性别，0 表示女性，1 表示男性，然后定义一个枚举类： 123456789101112131415161718192021222324public enum SexEnum implements IEnum&lt;Integer&gt; &#123; MAN(1, &quot;男&quot;), WOMEN(0, &quot;女&quot;); private int code; private String value; SexEnum(int code, String value) &#123; this.code = code; this.value = value; &#125; @Override public Integer getValue() &#123; return this.code; &#125; //注意要重写此方法，不然会将值转换成 ‘MAN’，而不是 ‘男’ @Override public String toString() &#123; return this.value; &#125;&#125; 然后在实体类中添加对应属性： 1private SexEnum sex; 在 application.yaml 中配置： 12mybatis-plus: type-enums-package: cbuc.life.enums 测试： 123456789101112131415@Testpublic void selectOne() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;name&quot;, &quot;小菜&quot;); User user = userMapper.selectOne(queryWrapper); System.out.println(user);&#125;/** 输出结果：User(id=1, deptId=1, name=小菜, remark=关注小菜不迷路！, status=1, sex=男) SQL语句： SELECT id,sex,name,dept_id,remark,status FROM student WHERE status=1 AND (name = &#x27;小菜&#x27;);**/","categories":[],"tags":[{"name":"提高生产力，最全 MyBatisPlus 讲解！","slug":"提高生产力，最全-MyBatisPlus-讲解！","permalink":"http://example.com/tags/%E6%8F%90%E9%AB%98%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%8C%E6%9C%80%E5%85%A8-MyBatisPlus-%E8%AE%B2%E8%A7%A3%EF%BC%81/"}]},{"title":"sql加强2","slug":"sql加强2","date":"2022-10-07T05:10:35.000Z","updated":"2022-10-07T05:11:19.963Z","comments":true,"path":"2022/10/07/sql加强2/","link":"","permalink":"http://example.com/2022/10/07/sql%E5%8A%A0%E5%BC%BA2/","excerpt":"","text":"SQL强化SQL执行顺序1234567891011121314151617181920212223242526--举例：select a.sex, b.city, count(1) as cnt, sum(salary) as sum1from table1 ajoin table2 b on a.id=b.idwhere a.name=b.namegroup by a.sex,b.cityhaving cnt&gt;=2order by a.sex,b.citylimit 10--或者是select distinct a.sex, b.city, a.agefrom table1 ajoin table2 b on a.id=b.idwhere a.name=b.nameorder by a.sex,b.citylimit 10 上面的SQL语句的执行顺序是: from (去加载table1 和 table2这2个表 ) -&gt; join -&gt; on -&gt; where -&gt; group by-&gt;select 后面的聚合函数count,sum -&gt; having -&gt; distinct -&gt; order by -&gt; limit 123456789101112131415161718192021222324252627--on 和where的先后顺序讨论--下面用left join 各得到结果，结果不一样。--下面可知，先执行on，再执行whereselect * from table1 aleft join table2 b on a.id=b.idwhere a.name=b.name;--下面的条数可能会比上面多。select * from table1 aleft join table2 b on a.id=b.idand a.name=b.name;--下面用inner join 各得到结果，结果是一样的select * from table1 ajoin table2 b on a.id=b.idwhere a.name=b.name;select * from table1 ajoin table2 b on a.id=b.idand a.name=b.name; hivesql与sparkSQL的区别： 子查询hive必须起别名，SparkSQL可以不用起别名 group by xx，yy，hive不用能用别名，spark可以用别名 hive不支持临时视图和缓存表，SparkSQL都支持 &#96;&#96;&#96;sql–用SparkSQL的临时视图 use interview_db; create or replace temporary view t_view1 as select *, if(month&#x3D;1,amount,0) as a1, if(month&#x3D;2,amount,0) as a2, if(month&#x3D;3,amount,0) as a3, if(month&#x3D;4,amount,0) as a4 from table2;1 1 1 select year,sum(a1) as m1,sum(a2) as m2,sum(a3) as m3,sum(a4) as m4from t_view1group by year; 1 &#96;&#96;&#96;sql 1 –使用SparkSQL的缓存表cache table cached1 asselect *,if(month&#x3D;1,amount,0) as a1,if(month&#x3D;2,amount,0) as a2,if(month&#x3D;3,amount,0) as a3,if(month&#x3D;4,amount,0) as a4from table2; select * from cached1;select year,sum(a1) as m1,sum(a2) as m2,sum(a3) as m3,sum(a4) as m4from cached1group by year; 123456789* 爆炸函数，hive不支持explode与普通字段联合使用，需要用侧视图分开，SparkSQL支持联合使用 * ```sql sql use interview_db; select qq,game1 from tableB lateral view explode(split(game,&#x27;_&#x27;)) view1 as game1 ; --spark还支持这样，但是hive不支持： select qq,explode(split(game,&#x27;_&#x27;)) game1 from tableB ; 1 1 12345* sparkSQL支持300多种函数，hiveSQL支持200多种函数。sparkSQL函数比hiveSQL要多。 * 比如SparkSQL有sequence函数，hive就没有 1 hive10题 先配置环境 在pycharm或datagrip或idea中配置hive数据源。也可以配置一个sparkSQL数据源，来加快速度。 如果配置hive数据源： 需要提前启动hdfs和yarn，hive的metastore，hive的hiveserver2 &#96;&#96;&#96;shell#启动hdfs和yarnstart-all.sh hive的metastorenohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service metastore 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-metastore.log &amp; #hive的hiveserver2#hiveserver2开启后，等过2分钟后才能生效。nohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service hiveserver2 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-hiveserver2.log &amp; 1234567891011121314 ![1659774353515](E:\\自研项目\\sql资料\\4\\images\\1659774353515.png)* 如果遇到下面的问题* ![1659749246129](E:\\自研项目\\sql资料\\4\\images\\1659749246129.png)* 解决办法 * ``` hive/conf/hive-env.sh中加入 export HADOOP_CLIENT_OPTS=&quot; -Xmx512m&quot; export HADOOP_HEAPSIZE=1024 改完重启hiveserver2 如果配置SparkSQL数据源 需要提前启动hdfs，hive的metastore，Spark的Thriftserver服务。 &#96;&#96;&#96;shell#启动hdfs和yarnstart-all.sh hive的metastorenohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service metastore 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-metastore.log &amp; #Spark的Thriftserver服务&#x2F;export&#x2F;server&#x2F;spark&#x2F;sbin&#x2F;start-thriftserver.sh –hiveconf hive.server2.thrift.port&#x3D;10001 –hiveconf hive.server2.thrift.bind.host&#x3D;node1 –master local[*] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449 * 下面是spark3集成hive3需要的jar包，如果是spark2集成hive2，则jar包不一样。![1659774447157](E:\\自研项目\\sql资料\\4\\images\\1659774447157.png) * ![1659774468920](E:\\自研项目\\sql资料\\4\\images\\1659774468920.png)```sqlshow databases ;create database if not exists test_sql;use test_sql;-- 一些语句会走 MapReduce，所以慢。 可以开启本地化执行的优化。set hive.exec.mode.local.auto=true;-- (默认为false)--第1题：访问量统计CREATE TABLE test_sql.test1 ( userId string, visitDate string, visitCount INT ) ROW format delimited FIELDS TERMINATED BY &quot;\\t&quot;;INSERT overwrite TABLE test_sql.test1VALUES ( &#x27;u01&#x27;, &#x27;2017/1/21&#x27;, 5 ), ( &#x27;u02&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u03&#x27;, &#x27;2017/1/22&#x27;, 8 ), ( &#x27;u04&#x27;, &#x27;2017/1/20&#x27;, 3 ), ( &#x27;u01&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u01&#x27;, &#x27;2017/2/21&#x27;, 8 ), ( &#x27;u02&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u01&#x27;, &#x27;2017/2/22&#x27;, 4 );select *, sum(sum1) over(partition by userid order by month1 /*rows between unbounded preceding and current row*/ ) as `累积` from(select userid, date_format(replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;yyyy-MM&#x27;) as month1, sum(visitcount) sum1from test_sql.test1group by userid, date_format(replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;yyyy-MM&#x27;)) as t;-- 第2题：电商场景TopK统计CREATE TABLE test_sql.test2 ( user_id string, shop string ) ROW format delimited FIELDS TERMINATED BY &#x27;\\t&#x27;;INSERT INTO TABLE test_sql.test2 VALUES( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u3&#x27;, &#x27;c&#x27; ),( &#x27;u4&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;c&#x27; ),( &#x27;u5&#x27;, &#x27;b&#x27; ),( &#x27;u4&#x27;, &#x27;b&#x27; ),( &#x27;u6&#x27;, &#x27;c&#x27; ),( &#x27;u2&#x27;, &#x27;c&#x27; ),( &#x27;u1&#x27;, &#x27;b&#x27; ),( &#x27;u2&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;a&#x27; ),( &#x27;u3&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; );--（1）每个店铺的UV（访客数）-- UV和PV-- PV是访问当前网站所有的次数-- UV是访问当前网站的客户数(需要去重)--(2)每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数select shop, count(distinct user_id) as uvfrom test_sql.test2 group by shop ;--上面的拆解来看，等价于--distinct后可以接多个字段，表示联合去重select shop, count(user_id) as uvfrom(select distinct shop, user_idfrom test_sql.test2 ) as tgroup by shop ;--也等价于select shop, count(user_id) as uvfrom(select shop, user_idfrom test_sql.test2 group by shop, user_id) as tgroup by shop ;select * from(select *, row_number() over (partition by shop order by cnt desc) as rnfrom(select shop,user_id,count(1) as cnt from test_sql.test2 group by shop,user_id ) as t) t2where t2.rn&lt;=3;-- 第3题：订单量统计CREATE TABLE test_sql.test3 ( dt string, order_id string, user_id string, amount DECIMAL ( 10, 2 ) )ROW format delimited FIELDS TERMINATED BY &#x27;\\t&#x27;;INSERT overwrite TABLE test_sql.test3 VALUES (&#x27;2017-01-01&#x27;,&#x27;10029028&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-01-01&#x27;,&#x27;10029029&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-01-01&#x27;,&#x27;100290288&#x27;,&#x27;1000003252&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;10029088&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;100290281&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;100290282&#x27;,&#x27;1000003253&#x27;,33.57), (&#x27;2017-11-02&#x27;,&#x27;10290282&#x27;,&#x27;100003253&#x27;,234), (&#x27;2018-11-02&#x27;,&#x27;10290284&#x27;,&#x27;100003243&#x27;,234);-- (1)给出 2017年每个月的订单数、用户数、总成交金额。-- (2)给出2017年11月的新客数(指在11月才有第一笔订单)select date_format(dt,&#x27;yyyy-MM&#x27;) as month1, count(distinct order_id) as cnt1, count(distinct user_id) as cnt2, sum(amount) as amt from test_sql.test3 where year(dt)=2017group by date_format(dt,&#x27;yyyy-MM&#x27;);select count(user_id) cnt from(select user_id, min(date_format(dt,&#x27;yyyy-MM&#x27;)) min_monthfrom test3 group by user_id) as t where min_month=&#x27;2017-11&#x27;;--统计每个月的新客户数select min_month, count(user_id) cntfrom (select user_id, min(date_format(dt, &#x27;yyyy-MM&#x27;)) min_month from test3 group by user_id) as tgroup by min_month;-- 第4题：大数据排序统计CREATE TABLE test_sql.test4user (user_id string,name string,age int);CREATE TABLE test_sql.test4log (user_id string,url string);INSERT INTO TABLE test_sql.test4user VALUES(&#x27;001&#x27;,&#x27;u1&#x27;,10),(&#x27;002&#x27;,&#x27;u2&#x27;,15),(&#x27;003&#x27;,&#x27;u3&#x27;,15),(&#x27;004&#x27;,&#x27;u4&#x27;,20),(&#x27;005&#x27;,&#x27;u5&#x27;,25),(&#x27;006&#x27;,&#x27;u6&#x27;,35),(&#x27;007&#x27;,&#x27;u7&#x27;,40),(&#x27;008&#x27;,&#x27;u8&#x27;,45),(&#x27;009&#x27;,&#x27;u9&#x27;,50),(&#x27;0010&#x27;,&#x27;u10&#x27;,65);INSERT INTO TABLE test_sql.test4log VALUES(&#x27;001&#x27;,&#x27;url1&#x27;),(&#x27;002&#x27;,&#x27;url1&#x27;),(&#x27;003&#x27;,&#x27;url2&#x27;),(&#x27;004&#x27;,&#x27;url3&#x27;),(&#x27;005&#x27;,&#x27;url3&#x27;),(&#x27;006&#x27;,&#x27;url1&#x27;),(&#x27;007&#x27;,&#x27;url5&#x27;),(&#x27;008&#x27;,&#x27;url7&#x27;),(&#x27;009&#x27;,&#x27;url5&#x27;),(&#x27;0010&#x27;,&#x27;url1&#x27;);select * from test_sql.test4user ;select * from test_sql.test4log ;--有一个5000万的用户文件(user_id，name，age)，-- 一个2亿记录的用户看电影的记录文件(user_id，url)，根据年龄段观看电影的次数进行排序？--取整函数有 round，floor，ceilselect *, round(x,0) as r,--四舍五入 floor(x) as f,--向下取整 ceil(x) as c--向上取整 from(select 15/10 as x union allselect 18/10 as x union allselect 24/10 as x union allselect 27/10 as x ) as t;select type, sum(cnt) as sum1from(select *, concat(floor(age/10)*10,&#x27;-&#x27;,floor(age/10)*10+10) as typefrom test_sql.test4user as a-- join前最好提前减小数据量join (select user_id,count(url) as cnt from test_sql.test4log group by user_id) as bon a.user_id=b.user_id) as tgroup by typeorder by sum(cnt) desc;-- 第5题：活跃用户统计CREATE TABLE test5(dt string,user_id string,age int)ROW format delimited fields terminated BY &#x27;,&#x27;;INSERT overwrite TABLE test_sql.test5 VALUES (&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-11&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-11&#x27;,&#x27;test_3&#x27;,39),(&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-11&#x27;,&#x27;test_3&#x27;,39),(&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-12&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-13&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-15&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-16&#x27;,&#x27;test_2&#x27;,19);select * from test_sql.test5 order by dt,user_id;--有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）-- type 总数 平均年龄-- &#x27;所有用户&#x27; 3 27-- &#x27;活跃用户&#x27; 1 19with t1 as (select distinct dt, user_id,age from test_sql.test5), t2 as (select *,row_number() over (partition by user_id order by dt) as rn from t1 ), t3 as (select *,date_sub(dt,rn) as dt2 from t2), t4 as (select dt2,user_id,age,count(1) cnt from t3 group by dt2,user_id,age), t5 as (select * from t4 where cnt&gt;=2), t6 as (select distinct user_id,age from t5)select &#x27;所有用户&#x27; as type, count(user_id) cnt,avg(age) as avg_agefrom (select distinct user_id,age from test_sql.test5) t union allselect &#x27;活跃用户&#x27; as type, count(user_id) cnt,avg(age) as avg_age from t6;-- 用思路2来分析连续2天登录with t1 as (select distinct dt, user_id from test_sql.test5), t2 as (select *, date_add(dt,1) as dt2, lead(dt,1)over(partition by user_id order by dt) as dt3 from t1)select count(distinct user_id) from t2 where dt2=dt3;-- 第6题：电商购买金额统计实战CREATE TABLE test_sql.test6 ( userid string, money decimal(10,2), paymenttime string, orderid string);INSERT INTO TABLE test_sql.test6 VALUES(&#x27;001&#x27;,100,&#x27;2017-10-01&#x27;,&#x27;123&#x27;),(&#x27;001&#x27;,200,&#x27;2017-10-02&#x27;,&#x27;124&#x27;),(&#x27;002&#x27;,500,&#x27;2017-10-01&#x27;,&#x27;125&#x27;),(&#x27;001&#x27;,100,&#x27;2017-11-01&#x27;,&#x27;126&#x27;);select * from test_sql.test6 order by userid,paymenttime;--请用sql写出所有用户中在今年10月份第一次购买商品的金额，select userid,paymenttime,moneyfrom(select *, row_number() over (partition by userid order by paymenttime) as rn from test_sql.test6 where date_format(paymenttime,&#x27;yyyy-MM&#x27;)=&#x27;2017-10&#x27; ) as twhere t.rn=1;-- 第7题：教育领域SQL实战CREATE TABLE test_sql.book(book_id string, `SORT` string, book_name string, writer string, OUTPUT string, price decimal(10,2));INSERT INTO TABLE test_sql.book VALUES(&#x27;001&#x27;,&#x27;TP391&#x27;,&#x27;信息处理&#x27;,&#x27;author1&#x27;,&#x27;机械工业出版社&#x27;,&#x27;20&#x27;),(&#x27;002&#x27;,&#x27;TP392&#x27;,&#x27;数据库&#x27;,&#x27;author12&#x27;,&#x27;科学出版社&#x27;,&#x27;15&#x27;),(&#x27;003&#x27;,&#x27;TP393&#x27;,&#x27;计算机网络&#x27;,&#x27;author3&#x27;,&#x27;机械工业出版社&#x27;,&#x27;29&#x27;),(&#x27;004&#x27;,&#x27;TP399&#x27;,&#x27;微机原理&#x27;,&#x27;author4&#x27;,&#x27;科学出版社&#x27;,&#x27;39&#x27;),(&#x27;005&#x27;,&#x27;C931&#x27;,&#x27;管理信息系统&#x27;,&#x27;author5&#x27;,&#x27;机械工业出版社&#x27;,&#x27;40&#x27;),(&#x27;006&#x27;,&#x27;C932&#x27;,&#x27;运筹学&#x27;,&#x27;author6&#x27;,&#x27;科学出版社&#x27;,&#x27;55&#x27;);CREATE TABLE test_sql.reader (reader_id string, company string, name string, sex string, grade string, addr string);INSERT INTO TABLE test_sql.reader VALUES(&#x27;0001&#x27;,&#x27;阿里巴巴&#x27;,&#x27;jack&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr1&#x27;),(&#x27;0002&#x27;,&#x27;百度&#x27;,&#x27;robin&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr2&#x27;),(&#x27;0003&#x27;,&#x27;腾讯&#x27;,&#x27;tony&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr3&#x27;),(&#x27;0004&#x27;,&#x27;京东&#x27;,&#x27;jasper&#x27;,&#x27;男&#x27;,&#x27;cfo&#x27;,&#x27;addr4&#x27;),(&#x27;0005&#x27;,&#x27;网易&#x27;,&#x27;zhangsan&#x27;,&#x27;女&#x27;,&#x27;ceo&#x27;,&#x27;addr5&#x27;),(&#x27;0006&#x27;,&#x27;搜狐&#x27;,&#x27;lisi&#x27;,&#x27;女&#x27;,&#x27;ceo&#x27;,&#x27;addr6&#x27;);CREATE TABLE test_sql.borrow_log(reader_id string, book_id string, borrow_date string);INSERT INTO TABLE test_sql.borrow_log VALUES (&#x27;0001&#x27;,&#x27;002&#x27;,&#x27;2019-10-14&#x27;),(&#x27;0002&#x27;,&#x27;001&#x27;,&#x27;2019-10-13&#x27;),(&#x27;0003&#x27;,&#x27;005&#x27;,&#x27;2019-09-14&#x27;),(&#x27;0004&#x27;,&#x27;006&#x27;,&#x27;2019-08-15&#x27;),(&#x27;0005&#x27;,&#x27;003&#x27;,&#x27;2019-10-10&#x27;),(&#x27;0006&#x27;,&#x27;004&#x27;,&#x27;2019-17-13&#x27;);select * from test_sql.book;select * from test_sql.reader;select * from test_sql.borrow_log;--（8）考虑到数据安全的需要，需定时将“借阅记录”中数据进行备份，请使用一条SQL语句，-- 在备份用户bak下创建与“借阅记录”表结构完全一致的数据表BORROW_LOG_BAK.-- 井且将“借阅记录”中现有数据全部复制到BORROW_L0G_ BAK中。create table test_sql.BORROW_LOG_BAK as select * from test_sql.borrow_log;select * from test_sql.BORROW_LOG_BAK;--（9）现在需要将原Oracle数据库中数据迁移至Hive仓库，-- 请写出“图书”在Hive中的建表语句（Hive实现，提示：列分隔符|；-- 数据表数据需要外部导入：分区分别以month＿part、day＿part 命名）CREATE TABLE test_sql.book2( book_id string, `SORT` string, book_name string, writer string, OUTPUT string, price decimal(10, 2))partitioned by (month_part string,day_part string ) row format delimited fields terminated by &#x27;|&#x27;;--（10）Hive中有表A，现在需要将表A的月分区 201505 中 -- user＿id为20000的user＿dinner字段更新为bonc8920，其他用户user＿dinner字段数据不变，-- 请列出更新的方法步骤。（Hive实现，提示：Hive中无update语法，请通过其他办法进行数据更新）--A-- user_id user_dinner part-- 20000 aaaaa 201505-- 30000 bbbbb 201505create table A (user_id int,user_dinner string) partitioned by (part string);insert overwrite table A partition (part = &#x27;201505&#x27;)values (20000, &#x27;aaaaa&#x27;), (30000, &#x27;bbbbb&#x27;), (40000, &#x27;ccccc&#x27;);select * from A;--update A set user_dinner=&#x27;bonc8920&#x27; where user_id=20000;insert overwrite table A partition (part = &#x27;201505&#x27;)select user_id, &#x27;bonc8920&#x27; as user_dinner from A where user_id=20000 and part = &#x27;201505&#x27; union allselect user_id, user_dinner from A where user_id!=20000 and part = &#x27;201505&#x27; ;-- 第8题：服务日志SQL统计CREATE TABLE test_sql.test8(`date` string, interface string, ip string);INSERT INTO TABLE test_sql.test8 VALUES(&#x27;2016-11-09 11:22:05&#x27;,&#x27;/api/user/login&#x27;,&#x27;110.23.5.23&#x27;),(&#x27;2016-11-09 11:23:10&#x27;,&#x27;/api/user/detail&#x27;,&#x27;57.3.2.16&#x27;),(&#x27;2016-11-09 23:59:40&#x27;,&#x27;/api/user/login&#x27;,&#x27;200.6.5.166&#x27;),(&#x27;2016-11-09 11:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;136.79.47.70&#x27;),(&#x27;2016-11-09 11:15:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;94.144.143.141&#x27;),(&#x27;2016-11-09 11:16:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;197.161.8.206&#x27;),(&#x27;2016-11-09 12:14:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;240.227.107.145&#x27;),(&#x27;2016-11-09 13:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;79.130.122.205&#x27;),(&#x27;2016-11-09 14:14:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;65.228.251.189&#x27;),(&#x27;2016-11-09 14:15:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;245.23.122.44&#x27;),(&#x27;2016-11-09 14:17:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;22.74.142.137&#x27;),(&#x27;2016-11-09 14:19:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;54.93.212.87&#x27;),(&#x27;2016-11-09 14:20:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;218.15.167.248&#x27;),(&#x27;2016-11-09 14:24:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;20.117.19.75&#x27;),(&#x27;2016-11-09 15:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;183.162.66.97&#x27;),(&#x27;2016-11-09 16:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;108.181.245.147&#x27;),(&#x27;2016-11-09 14:17:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;22.74.142.137&#x27;),(&#x27;2016-11-09 14:19:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;22.74.142.137&#x27;);select * from test_sql.test8;--求11月9号下午14点（14-15点），访问/api/user/login接口的top10的ip地址select ip, count(1) cntfrom test_sql.test8where date_format(`date`, &#x27;yyyy-MM-dd HH&#x27;) = &#x27;2016-11-09 14&#x27; and interface = &#x27;/api/user/login&#x27;group by iporder by cnt desclimit 10;-- 第9题：充值日志SQL实战CREATE TABLE test_sql.test9( dist_id string COMMENT &#x27;区组id&#x27;, account string COMMENT &#x27;账号&#x27;, `money` decimal(10,2) COMMENT &#x27;充值金额&#x27;, create_time string COMMENT &#x27;订单时间&#x27;);INSERT INTO TABLE test_sql.test9 VALUES (&#x27;1&#x27;,&#x27;11&#x27;,100006,&#x27;2019-01-02 13:00:01&#x27;), (&#x27;1&#x27;,&#x27;22&#x27;,110000,&#x27;2019-01-02 13:00:02&#x27;), (&#x27;1&#x27;,&#x27;33&#x27;,102000,&#x27;2019-01-02 13:00:03&#x27;), (&#x27;1&#x27;,&#x27;44&#x27;,100300,&#x27;2019-01-02 13:00:04&#x27;), (&#x27;1&#x27;,&#x27;55&#x27;,100040,&#x27;2019-01-02 13:00:05&#x27;), (&#x27;1&#x27;,&#x27;66&#x27;,100005,&#x27;2019-01-02 13:00:06&#x27;), (&#x27;1&#x27;,&#x27;77&#x27;,180000,&#x27;2019-01-03 13:00:07&#x27;), (&#x27;1&#x27;,&#x27;88&#x27;,106000,&#x27;2019-01-02 13:00:08&#x27;), (&#x27;1&#x27;,&#x27;99&#x27;,100400,&#x27;2019-01-02 13:00:09&#x27;), (&#x27;1&#x27;,&#x27;12&#x27;,100030,&#x27;2019-01-02 13:00:10&#x27;), (&#x27;1&#x27;,&#x27;13&#x27;,100003,&#x27;2019-01-02 13:00:20&#x27;), (&#x27;1&#x27;,&#x27;14&#x27;,100020,&#x27;2019-01-02 13:00:30&#x27;), (&#x27;1&#x27;,&#x27;15&#x27;,100500,&#x27;2019-01-02 13:00:40&#x27;), (&#x27;1&#x27;,&#x27;16&#x27;,106000,&#x27;2019-01-02 13:00:50&#x27;), (&#x27;1&#x27;,&#x27;17&#x27;,100800,&#x27;2019-01-02 13:00:59&#x27;), (&#x27;2&#x27;,&#x27;18&#x27;,100800,&#x27;2019-01-02 13:00:11&#x27;), (&#x27;2&#x27;,&#x27;19&#x27;,100030,&#x27;2019-01-02 13:00:12&#x27;), (&#x27;2&#x27;,&#x27;10&#x27;,100000,&#x27;2019-01-02 13:00:13&#x27;), (&#x27;2&#x27;,&#x27;45&#x27;,100010,&#x27;2019-01-02 13:00:14&#x27;), (&#x27;2&#x27;,&#x27;78&#x27;,100070,&#x27;2019-01-02 13:00:15&#x27;);select * from test_sql.test9 order by dist_id , money desc;--请写出SQL语句，查询充值日志表2019年01月02号每个区组下充值额最大的账号，要求结果：--区组id，账号，金额，充值时间select * from(select *, row_number() over (partition by dist_id order by money desc) rnfrom test_sql.test9 where to_date(create_time)=&#x27;2019-01-02&#x27;) twhere t.rn=1;-- 第10题：电商分组TopK实战CREATE TABLE test_sql.test10( `dist_id` string COMMENT &#x27;区组id&#x27;, `account` string COMMENT &#x27;账号&#x27;, `gold` int COMMENT &#x27;金币&#x27;);INSERT INTO TABLE test_sql.test10 VALUES (&#x27;1&#x27;,&#x27;77&#x27;,18), (&#x27;1&#x27;,&#x27;88&#x27;,106), (&#x27;1&#x27;,&#x27;99&#x27;,10), (&#x27;1&#x27;,&#x27;12&#x27;,13), (&#x27;1&#x27;,&#x27;13&#x27;,14), (&#x27;1&#x27;,&#x27;14&#x27;,25), (&#x27;1&#x27;,&#x27;15&#x27;,36), (&#x27;1&#x27;,&#x27;16&#x27;,12), (&#x27;1&#x27;,&#x27;17&#x27;,158), (&#x27;2&#x27;,&#x27;18&#x27;,12), (&#x27;2&#x27;,&#x27;19&#x27;,44), (&#x27;2&#x27;,&#x27;10&#x27;,66), (&#x27;2&#x27;,&#x27;45&#x27;,80), (&#x27;2&#x27;,&#x27;78&#x27;,98);select * from test_sql.test10;select * from(select *, row_number() over (partition by dist_id order by gold desc) rnfrom test_sql.test10 ) twhere t.rn&lt;=10; 行转列(转置) 行转列的常规做法是，group by+sum(if())【或count(if())】 华泰证券1已知 year month amount 1991 1 1.1 1991 2 1.2 1991 3 1.3 1991 4 1.4 1992 1 2.1 1992 2 2.2 1992 3 2.3 1992 4 2.4 查成这样一个结果 year m1 m2 m3 m4 1991 1.1 1.2 1.3 1.4 1992 2.1 2.2 2.3 2.4 解答 &#96;&#96;&#96;sqluse test_sql;set hive.exec.mode.local.auto&#x3D;true;create table table2(year int,month int ,amount double) ; insert overwrite table table2 values (1991,1,1.1), (1991,2,1.2), (1991,3,1.3), (1991,4,1.4), (1992,1,2.1), (1992,2,2.2), (1992,3,2.3), (1992,4,2.4);select * from table2; –行转列–常规做法是，group by+sum(if())–原始写法select year, sum(a) as m1, sum(b) as m2, sum(c) as m3, sum(d) as m4from(select *, if(month&#x3D;1,amount,0) a, if(month&#x3D;2,amount,0) b, if(month&#x3D;3,amount,0) c, if(month&#x3D;4,amount,0) d from table2) tgroup by t.year;–简化写法select year, sum(if(month&#x3D;1,amount,0)) m1, sum(if(month&#x3D;2,amount,0)) m2, sum(if(month&#x3D;3,amount,0)) m3, sum(if(month&#x3D;4,amount,0)) m4from table2group by year; 1234567891011121314151617181920212223242526272829303132333435363738394041424344### 华泰证券2* 查询课程编号“2”的成绩比课程编号“1”低的所有同学的学号、姓名。* 【这是行转列的衍生题】* ```sql create table student(sid int, sname string, gender string, class_id int); insert overwrite table student values (1, &#x27;张三&#x27;, &#x27;女&#x27;, 1), (2, &#x27;李四&#x27;, &#x27;女&#x27;, 1), (3, &#x27;王五&#x27;, &#x27;男&#x27;, 2); select * from student; create table course (cid int, cname string, teacher_id int); insert overwrite table course values (1, &#x27;生物&#x27;, 1), (2, &#x27;体育&#x27;, 1), (3, &#x27;物理&#x27;, 2); select * from course; create table score (sid int, student_id int, course_id int, number int); insert overwrite table score values (1, 1, 1, 58), (4, 1, 2, 50), (2, 1, 2, 68), (3, 2, 2, 89); select * from score; with t1 as( select student_id, sum(if(course_id=2,number,0)) as pe, --体育 sum(if(course_id=1,number,0)) as bio --生物 from score group by student_id having pe&lt;bio) select sid, sname from t1 join student on t1.student_id = sid ; 腾讯游戏表table如下： DDate shengfu 2015-05-09 胜 2015-05-09 胜 2015-05-09 负 2015-05-09 负 2015-05-10 胜 2015-05-10 负 2015-05-10 负 如果要生成下列结果, 该如何写sql语句? DDate 胜 负 2015-05-09 2 2 2015-05-10 1 2 123456789101112131415--建表create table table1(DDate string, shengfu string) ;insert overwrite table table1 values (&#x27;2015-05-09&#x27;, &quot;胜&quot;), (&#x27;2015-05-09&#x27;, &quot;胜&quot;), (&#x27;2015-05-09&#x27;, &quot;负&quot;), (&#x27;2015-05-09&#x27;, &quot;负&quot;), (&#x27;2015-05-10&#x27;, &quot;胜&quot;), (&#x27;2015-05-10&#x27;, &quot;负&quot;), (&#x27;2015-05-10&#x27;, &quot;负&quot;);select DDate, SUM(case when shengfu = &#x27;胜&#x27; then 1 else 0 end) `胜`, SUM(case when shengfu = &#x27;负&#x27; then 1 else 0 end) `负`from table1group by DDate; 腾讯QQ假设tableA如表5, tableB如表6, 表5 qq号（字段名：qq） 游戏（字段名：game） 10000 a 10000 b 10000 c 20000 c 20000 d 表6 qq号（字段名：qq） 游戏（字段名：game） 10000 a_b_c 20000 c_d 请写出以下sql逻辑： a, 将tableA输出为tableB的格式； 【行转列】 b, 将tableB输出为tableA的格式; 【列转行】 1234567891011121314151617181920212223create table tableA(qq string, game string) insert overwrite table tableA values (10000, &#x27;a&#x27;), (10000, &#x27;b&#x27;), (10000, &#x27;c&#x27;), (20000, &#x27;c&#x27;), (20000, &#x27;d&#x27;);create table tableB(qq string, game string) ;insert overwrite table tableB values (10000, &#x27;a_b_c&#x27;),(20000, &#x27;c_d&#x27;); --将tableA输出为tableB的格式； select qq, concat_ws(&#x27;_&#x27;, collect_list(game)) gamefrom tableAgroup by qq; --将tableB输出为tableA的格式; select qq, tmp.gamefrom tableB lateral view explode(split(game, &#x27;_&#x27;)) tmp as game; 连续N天登陆 思路分析过程 &#96;&#96;&#96;sql–核心代码-&gt;distinct-&gt; row_number-&gt; date_sub(dt,rn) as dt2-&gt; group by dt2,name-&gt; having count(1)&gt;&#x3D;N天-&gt; distinct name-&gt; count(name) 123456789101112131415 * 思路2* ![1659759179547](E:\\自研项目\\sql资料\\4\\images\\1659759179547.png)* ```sql --核心代码 -&gt;distinct -&gt;date_add(dt,N-1) as date2 -&gt;lead(dt,N-1) over(partition by userid order by dt) as date3 -&gt;where date2=date3 -&gt;distinct OPPO3、以下为用户登陆游戏的日期，用一条sQL语句查询出连续三天登录的人员姓名 name date 张三 2021-01-01 张三 2021-01-02 张三 2021-01-03 张三 2021-01-02 李四 2021-01-01 李四 2021-01-02 王五 2021-01-03 王五 2021-01-02 王五 2021-01-02 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647create table game(name string, `date` string);insert overwrite table game values(&#x27;张三&#x27;,&#x27;2021-01-01&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-02&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-03&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-02&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-07&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-08&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-09&#x27;),(&#x27;李四&#x27;,&#x27;2021-01-01&#x27;),(&#x27;李四&#x27;,&#x27;2021-01-02&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-03&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-02&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-02&#x27;);with t1 as ( select distinct name,date from game), t2 as ( select *, row_number() over (partition by name order by date) rn from t1), t3 as ( select *,date_sub(date,rn) date2 from t2 ) select distinct name from t3 group by name,date2 having count(1)&gt;=3; --方案二select * from game;with t1 as ( select distinct name,`date` from game), t2 as ( select *, date_add(`date`,3-1) as date2, lead(`date`,3-1) over(partition by name order by `date`) as date3 from t1 )select distinct name from t2 where date2=date3;--方案二的写法2with t1 as ( select distinct name,`date` from game), t2 as ( select *, lead(`date`,3-1) over(partition by name order by `date`) as date3 from t1 )select distinct name from t2 where datediff(date3,`date`)=2 ; 脉脉用户每日登陆脉脉会访问app不同的模块，现有两个表 表1记录了每日脉脉活跃用户的uid和不同模块的活跃时长 表2记录了脉脉所有注册用户的一些属性 表1：maimai.dau d uid module active_duration 列说明 2020-01-01 1 jobs 324 d：活跃的日期uid：用户的唯一编码module：用户活跃模块actre.duration：该模块下对应的活跃时长（单位：s） 2020-01-01 2 feeds 445 2020-01-01 3 im 345 2020-01-02 2 network 765 2020-01-02 3 jobs 342 … … … … 在过去一个月内,曾连续两天活跃的用户 123456789101112131415161718192021222324252627282930-- 建表-- 表1 dau 记录了每日脉脉活跃用户的uid和不同模块的活跃时长create table dau(d string, uid int, module string, active_duration int);insert overwrite table dauvalues (&#x27;2020-01-01&#x27;, 1, &#x27;jobs&#x27;, 324), (&#x27;2020-01-01&#x27;, 2, &#x27;feeds&#x27;, 445), (&#x27;2020-01-01&#x27;, 3, &#x27;im&#x27;, 345), (&#x27;2020-01-02&#x27;, 2, &#x27;network&#x27;, 765), (&#x27;2020-01-02&#x27;, 3, &#x27;jobs&#x27;, 342);select *from dau;with t1 as ( select DISTINCT d, uid from dau), t2 as ( select *, date_sub(d, (row_number() over (partition by uid order by d))) dis from t1 where d &lt;= `current_date`() and d &gt;= date_sub((`current_date`()), 30)),t3 as ( select uid, min(d) `开始日期`, max(d) `结束日期`, count(1) `连续登入天数` from t2 group by uid,dis having count(*) &gt;= 2 )select DISTINCT uid from t3 ; 广州银行有一张表C_T（列举了部分数据）表示持卡人消费记录，表结构如下： CARD NER VARCHAR2 卡号， C_MONTH NUMBER 消费月份， C_DATE DATE 消费日期， C_TYPEVAR CHAR2 消费类型 C_ATM NUMBER 消费金额 每个月每张卡连续消费的最大天数（如卡在当月只有一次消费则为1）。 连续消费天数：指一楼时间内连续每天都有消费，同一天有多笔消费算一天消费，不能跨月份统计。 123456789101112131415161718192021222324252627create table c_t( card_nbr string, c_month string, c_date string, c_type string, c_atm decimal);insert overwrite table c_t values (1,&#x27;2022-01&#x27;,&#x27;2022-01-01&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-01&#x27;,&#x27;2022-01-02&#x27;,&#x27;网购&#x27;,200), (1,&#x27;2022-01&#x27;,&#x27;2022-01-03&#x27;,&#x27;网购&#x27;,300), (1,&#x27;2022-01&#x27;,&#x27;2022-01-15&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-01&#x27;,&#x27;2022-01-16&#x27;,&#x27;网购&#x27;,200), (2,&#x27;2022-01&#x27;,&#x27;2022-01-06&#x27;,&#x27;网购&#x27;,500), (2,&#x27;2022-01&#x27;,&#x27;2022-01-07&#x27;,&#x27;网购&#x27;,800), (1,&#x27;2022-02&#x27;,&#x27;2022-02-01&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-02&#x27;,&#x27;2022-02-02&#x27;,&#x27;网购&#x27;,200), (1,&#x27;2022-02&#x27;,&#x27;2022-02-03&#x27;,&#x27;网购&#x27;,300), (2,&#x27;2022-02&#x27;,&#x27;2022-02-06&#x27;,&#x27;网购&#x27;,500), (2,&#x27;2022-02&#x27;,&#x27;2022-02-07&#x27;,&#x27;网购&#x27;,800);with t1 as (select distinct card_nbr,c_month,c_date from c_t), t2 as (select *,row_number() over (partition by card_nbr,c_month order by c_date) rn from t1 ), t3 as (select *,date_sub(c_date,rn) dt2 from t2 ), t4 as (select dt2,card_nbr,c_month,count(1) as cnt from t3 group by dt2,card_nbr,c_month), t5 as ( select *,row_number() over (partition by card_nbr,c_month order by cnt desc) as rn from t4)select card_nbr,c_month,cnt from t5 where rn=1 N日留存率 核心代码 -&gt; where 日期 in (首日,1天后,7天后) -&gt; group by 用户 -&gt;count(if(日期=首日,1,null)) as cnt count(if(日期=1天后,1,null)) as cnt2 count(if(日期=7天后,1,null)) as cnt8 -&gt;having cnt&gt;0 -&gt;count(user_id) as 首日总数 count(if(cnt2&gt;0,1,null)) as 次日留存数 count(if(cnt8&gt;0,1,null)) as 7日留存数 -&gt;次日留存数/首日总数 as 次日留存率 7日留存数/首日总数 as 7日留存率 1234567891011121314* 先按用户分组，得到每个用户的各相关日期的登录情况。 * ```sql select cuid, count(if(event_day=&#x27;2020-04-01&#x27;,1,null)) as cnt, count(if(event_day=&#x27;2020-04-02&#x27;,1,null)) as cnt2, count(if(event_day=&#x27;2020-04-08&#x27;,1,null)) as cnt8 from tb_cuid_1d --提前过滤数据 where event_day in (&#x27;2020-04-01&#x27;,&#x27;2020-04-02&#x27;,&#x27;2020-04-08&#x27;) group by cuid -- 2020-04-01必须登录，剔除掉2020-04-01没登录的 having cnt&gt;0 效果如下 &lt;div align=&quot;left&quot;&gt;&lt;img src=&quot;images/1659841600894.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/div&gt; 再对上面的用户汇总 &#96;&#96;&#96;sqlselect count(cnt) as uv, count(if(cnt2!&#x3D;0,1,null)) as uv2, count(if(cnt8!&#x3D;0,1,null)) as uv81234567891011121314 * &lt;div align=&quot;left&quot;&gt;&lt;img src=&quot;images/1659841614840.png&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/div&gt;* 最后再用 【后续日期的留存数】除以【首日总数】，就是【留存率】* 方案二 ```sql select count(a.cuid) uv, count(b.cuid) uv2, count(c.cuid) uv7 from (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;首日&#x27;) as a left join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;次日&#x27;) as b on a.cuid=b.cuid left join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;7日后&#x27;) as c on a.cuid=c.cuid; 腾讯视频号游戏直播表：tableA ds(日期) device user_id is_active 2020-03-01 ios 0001 0 2020–0301 ios 0002 1 2020-03-01 android 0003 1 2020-03-02 ios 0001 0 2020-03-02 ios 0002 0 2020-03-02 android 0003 1 20200301的ios设备用户活跃的次日留存率是多少？ 123456789101112131415161718192021222324252627282930313233343536373839404142use test_sql;set hive.exec.mode.local.auto=true;--腾讯视频号游戏直播drop table if exists tableA;create table tableA(ds string comment &#x27;(日期)&#x27; ,device string,user_id string,is_active int) ;insert overwrite table tableA values(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0001&#x27;,0),(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0002&#x27;,1),(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0004&#x27;,1),(&#x27;2020-03-01&#x27;,&#x27;android&#x27;,&#x27;0003&#x27;,1),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0001&#x27;,0),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0002&#x27;,0),(&#x27;2020-03-02&#x27;,&#x27;android&#x27;,&#x27;0003&#x27;,1),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0005&#x27;,1) ,(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0004&#x27;,1) ;--方案1，过程见下面的顺序编号with t1 as ( select user_id, --3-一个用户如果在&#x27;2020-03-01&#x27;活跃，则cnt1&gt;0 count(if(ds = &#x27;2020-03-01&#x27;, 1, null)) cnt1, --4-一个用户如果在&#x27;2020-03-02&#x27;活跃，则cnt2&gt;0 count(if(ds = &#x27;2020-03-02&#x27;, 1, null)) cnt2 from tableA --1-预先全局过滤 where device = &#x27;ios&#x27; and is_active = 1 and ds in (&#x27;2020-03-01&#x27;, &#x27;2020-03-02&#x27;) --2-按用户分组 group by user_id --6-只筛选&#x27;2020-03-01&#x27;活跃的用户，他在&#x27;2020-03-02&#x27;是否活跃，看cnt2=0则不活跃，&gt;0则活跃 having cnt1 &gt; 0)select count(cnt1) sum1,--&#x27;2020-03-01&#x27;的活跃数 count(if(cnt2 &gt; 0, user_id, null)) sum2,----并且在次日依然活跃的用户数 count(if(cnt2 &gt; 0, user_id, null)) / count(cnt1) rate--次日留存率from t1; 百度有两张表 1234567891011121314151617181920212223create table if not exists tb_cuid_1d( cuid string comment &#x27;用户的唯一标识&#x27;, os string comment &#x27;平台&#x27;, soft_version string comment &#x27;版本&#x27;, event_day string comment &#x27;日期&#x27;, timestamp int comment &#x27;用户访问时间戳&#x27;, duration decimal comment &#x27;用户访问时长&#x27;, ext array&lt;string&gt; comment &#x27;扩展字段&#x27;);insert overwrite table tb_cuid_1d values (1,&#x27;android&#x27;,1,&#x27;2020-04-01&#x27;,1234567,100,`array`(&#x27;&#x27;)), (1,&#x27;android&#x27;,1,&#x27;2020-04-02&#x27;,1234567,100,`array`(&#x27;&#x27;)), (1,&#x27;android&#x27;,1,&#x27;2020-04-08&#x27;,1234567,100,`array`(&#x27;&#x27;)), (2,&#x27;android&#x27;,1,&#x27;2020-04-01&#x27;,1234567,100,`array`(&#x27;&#x27;)), (3,&#x27;android&#x27;,1,&#x27;2020-04-02&#x27;,1234567,100,`array`(&#x27;&#x27;)); create table if not exists tb_account_1d( cuid string comment &#x27;用户的唯一标识&#x27;, uid string comment &#x27;登入用户账号名&#x27;, event_day string comment &#x27;日期&#x27;); 写出用户表 tb_cuid_1d的 20200401 的次日、次7日留存的具体HQL ： 一条sql统计出以下指标 （4.1号uv，4.1号在4.2号的留存uv，4.1号在4.8号的留存uv）; 12345678910111213141516171819202122232425262728--一个理解简单，但是性能不快的做法select count(a.cuid) uv, count(b.cuid) uv2, count(c.cuid) uv7from (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-01&#x27;) as aleft join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-02&#x27;) as b on a.cuid=b.cuidleft join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-08&#x27;) as c on a.cuid=c.cuid;--另一个理解稍微复杂，但是性能快的做法with t1 as ( select cuid, count(if(event_day=&#x27;2020-04-01&#x27;,1,null)) as cnt1, count(if(event_day=&#x27;2020-04-02&#x27;,1,null)) as cnt2, count(if(event_day=&#x27;2020-04-08&#x27;,1,null)) as cnt8 from tb_cuid_1d where event_day in (&#x27;2020-04-01&#x27;,&#x27;2020-04-02&#x27;,&#x27;2020-04-08&#x27;) group by cuid having cnt1 &gt;0), t2 as (select count(cuid) as uv1, count(if(cnt2 &gt; 0, 1, null)) as uv2, count(if(cnt8 &gt; 0, 1, null)) as uv7 from t1 )select *, uv2 / uv1 as `次日留存率`, uv7 / uv1 as `7日留存率`from t2 分组内top前几 需求常见词： 【每组xxx内按yyy排序的前n个zzz】 【每组xxx内按yyy排序的第1个zzz】 【每组xxx内按yyy排序的最后1个zzz】 特点是yyy和zzz是不同的字段。 比如：班内按性别分组，组内按身高排序，的前3个学生姓名 公式：row_number() over(partition by 组名 order by yyy) as rn，再筛选rn&lt;&#x3D;N名 跨越物流员工表结构 员工表数据 题目描述 求出每个部门工资最高的前三名员工，并计算这些员工的工资占所属部门总工资的百分比。 结果 12345678910111213141516171819202122232425262728293031323334create table emp(empno string ,ename string,hiredate string,sal int ,deptno string);insert overwrite table emp values(&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;1981-2-22&#x27;, 1250, 30),(&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;1981-4-2&#x27;, 2975, 20),(&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;1987-7-13&#x27;, 1100, 20),(&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;1980-12-17&#x27;, 800, 20),(&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;1982-1-23&#x27;, 1300, 10),(&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;1981-9-8&#x27;, 1500, 30),(&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;1981-6-9&#x27;, 2450, 10),(&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;1981-11-17&#x27;, 5000, 10),(&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;1981-12-3&#x27;, 3000, 20),(&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;1981-2-20&#x27;, 1600, 30),(&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;1981-9-28&#x27;, 1250, 30),(&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;1981-12-3&#x27;, 950, 30),(&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;1987-7-13&#x27;, 3000, 20),(&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;1981-5-1&#x27;, 2850, 30);select * from emp;--求出每个部门工资最高的前三名员工，并计算这些员工的工资占所属部门总工资的百分比。select a.empno, a.sal, a.deptno, a.rn, a.sum_sal, round(a.sal/a.sum_sal,2) as ratefrom(select *,--每个部门工资排名 row_number() over (partition by deptno order by sal desc) as rn, --每个部门的总工资 sum(sal) over(partition by deptno ) as sum_sal from emp) awhere rn&lt;=3; 小米电商订单表，torder. 字段，user_id, order_id, ctime(10位时间戳)，city id，sale_num，sku_id(商品) 问题：20201201至今每日订单量top10的城市及其订单量(订单量对order id去重)(在线写) 123456789101112131415create table t_order (user_id string, order_id string, ctime string, city_id string, sale_num int , sku_id string) ;with t1 as (select to_date(ctime) cdate, city_id, count(distinct order_id) cnt from t_order where to_date(ctime) &gt;= &#x27;2020-12-01&#x27; and to_date(ctime) &lt;= `current_date`() group by to_date(ctime), city_id), t2 as (select *, row_number() over (partition by cdate order by cnt desc) rn from t1)select cdate, city_id, cntfrom t2where rn &lt;= 10; 窗口函数 窗口函数的最大特点是有over()关键字 聚合类的窗口函数 sum() over() count&#x2F;avg&#x2F;max&#x2F;min 排序类的窗口函数 row_number，rank，dense_rank 偏移类的，跨行的 lag &#x2F; lead first_value&#x2F;last_value ntile 交通银行Emp表的表数据如下： NAME MONTH AMT 张三 01 100 李四 02 120 王五 03 150 赵六 04 500 张三 05 400 李四 06 350 王五 07 180 赵六 08 400 问题：请写出可以得到以下的结果SQL NAME 总金额 排名 占比 赵六 900 1 40.91% 张三 500 2 22.73% 李四 470 3 21.36% 王五 330 4 15.00% 1234567891011121314151617181920212223create table emp(name string , month string, amt int);insert overwrite table emp values (&#x27;张三&#x27;, &#x27;01&#x27;, 100), (&#x27;李四&#x27;, &#x27;02&#x27;, 120), (&#x27;王五&#x27;, &#x27;03&#x27;, 150), (&#x27;赵六&#x27;, &#x27;04&#x27;, 500), (&#x27;张三&#x27;, &#x27;05&#x27;, 400), (&#x27;李四&#x27;, &#x27;06&#x27;, 350), (&#x27;王五&#x27;, &#x27;07&#x27;, 180), (&#x27;赵六&#x27;, &#x27;08&#x27;, 400);--rank 1224--dense_rank 1223with t1 as (select name, sum(amt) as sum_amt from emp group by name), t2 as ( select name, sum_amt, row_number() over (order by sum_amt desc) rn, sum_amt/sum(sum_amt) over () as rate from t1 )select name, sum_amt, rn, concat(round(rate*100,2),&#x27;%&#x27;) rate from t2 跨越物流题目描述 在第一题员工表的基础上，统计每年入职总数以及截至本年累计入职总人数。 截至本年累计入职总人数&#x3D;本年总入职人数 + 本年之前所有年的总入职人数之和 结果 1234567select *, sum(cnt) over (order by year1) cnt2from(select year(hiredate) as year1, count(1) as cntfrom empgroup by year(hiredate)) a; 带条件的聚合统计 一般的做法是group by xx,yy 再多次的sum(if(……)) 好处是避免多次加载表，一次性得到多个指标，可以只加载一次表就得到多个指标。 腾讯数据提取用户行为表：t_user_video_action_d分区：ds（格式 yyyyMMdd） 主键：user_id、video_id 含义：一个 user 对一个视频的所有行为聚合，每天增量字段： 字段名 字段含义 类型 user_id 用户 id string video_id 视频 id string expose_cnt 曝光次数 int like_cnt 点赞次数 int 视频表：t_video_d 分区：ds（格式 yyyyMMdd）主键：video_id 含义：当天全量视频数据字段： 字段名 字段含义 类型 枚举 video_id 视频 id string video_type 视频类型 string 娱乐、新闻、搞笑 video_user_id 视频创建者 user_id string video_create_time 视频创建时间 bigint ​ 作者表：t_video_user_d 分区：ds（格式 yyyyMMdd）主键：video_user_id 含义：当天全量视频创建者数据 字段名 字段含义 类型 枚举 video_user_id 视频创建者 user_id string video_user_name 名称 string video_user_type 视频创建者类型 string 娱乐、新闻、搞笑 需求方需要视频号搞笑类型视频的曝光点赞时长等数据，请提供一张 ads 表。搞笑类型视频定义：视频类型为搞笑或者视频创建者类型为搞笑 需要产出字段：视频 id，视频创建者 user_id，视频创建者名称、当天曝光次数、当天点赞次数、近 30 天曝光次数、近 30 天点赞次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 create table if not exists t_user_video_action_d( user_id string comment &quot;用户id&quot;, video_id string comment &quot;视频id&quot;, expose_cnt int comment &quot;曝光次数&quot;, like_cnt int comment &quot;点赞次数&quot;) partitioned by (ds string);drop table t_video_d;create table if not exists t_video_d( video_id string comment &#x27;视频id&#x27;, video_type string comment &#x27;视频类型&#x27;, video_user_id string comment &#x27;视频创建者user_id&#x27;, video_create_time bigint comment &#x27;视频创建时间&#x27;) partitioned by (ds string);create table if not exists t_video_user_d( video_user_id string comment &#x27;视频创建者user_id&#x27;, video_user_name string comment &#x27;名称&#x27;, video_user_type string comment &#x27;视频创建者类型&#x27;) partitioned by (ds string);--假设当天是2022-07-31select t1.*, t2.video_user_id, t2.video_user_namefrom (select video_id, sum(case when ds = &#x27;2022-07-30&#x27; then expose_cnt else 0 end),--当天曝光次数、 sum(case when ds = &#x27;2022-07-30&#x27; then like_cnt else 0 end),-- 当天点赞次数、 sum(expose_cnt) as sum_expose,-- 近 30 天曝光次数、 sum(like_cnt)-- 近 30 天点赞次数 from t_user_video_action_d where ds between &#x27;2022-07-01&#x27; and &#x27;2022-07-30&#x27; group by video_id) as t1join (select d.video_id, d.video_user_id, u.video_user_name from t_video_d d join t_video_user_d u on d.video_user_id = u.video_user_id where (d.video_type like &#x27;%搞笑%&#x27; or u.video_user_type like &#x27;%搞笑%&#x27;) and d.ds = &#x27;2022-07-30&#x27; and u.ds = &#x27;2022-07-30&#x27;) as t2 on t1.video_id = t2.video_id 小米电商要求：编写SQL能运行，数据正确且符合规范，如遇到自定义函数或不记得的函数可以用XX代替 1.已知有如下两个表表sale：字段如下 123456789Create table sale_order( Order_id bigint comment &#x27;订单ID&#x27;, User_id bigint comment &#x27;用户ID&#x27;, Order_status int, Create_time string, Last_update_time string, Product_id bigint, Product_num bigint ); 用户注册表： 123456Create table user_info( user_id bigint comment&#x27;用户ID，唯一主键&#x27;, sex string. age int); 问题：用一条SQL生成完整的用户画像表，包含如下字段： user_id, sex, age, d7order_num, d14_order_num，后面两个字段分别为近7天订单数量，近14天订单数量。 12345678910111213141516171819202122232425create table sale_order( order_id bigint comment &#x27;订单ID&#x27;, user_id bigint comment &#x27;用户ID&#x27;, order_status int , create_time string, last_update_time string, product_id bigint, product_num bigint);create table user_info( user_id bigint comment &#x27;用户ID,唯一主键&#x27;, sex string, age int);select u.user_id, s.d7order_num, s.d14order_numfrom user_info uleft join (select user_id, count(if(create_time &gt;= &#x27;7天前&#x27; and create_time &lt;= &#x27;今天&#x27;, order_id,null)) as d7order_num, count(if(create_time &gt;= &#x27;14天前&#x27; and create_time &lt;= &#x27;今天&#x27;, order_id,null)) as d14order_num from sale_order where create_time &gt;= &#x27;14天前&#x27; group by user_id) s on u.user_id = s.user_id; join系列【区分 inner &#x2F;left &#x2F; right &#x2F; full &#x2F; left semi &#x2F; left anti join 的特点】 有以下银行信息表 12345678910111213141516171819202122232425use interview_db;set hive.exec.mode.local.auto=true;drop table if exists all_users;create table all_users( id int comment &#x27;用户id&#x27;, name string comment &#x27;用户姓名&#x27;, sex string comment &#x27;性别&#x27;, age int comment &#x27;年龄&#x27;) comment &#x27;银行用户信息表&#x27;;insert overwrite table all_users values(1,&#x27;张三&#x27;,&#x27;男&#x27;,20),(2,&#x27;李四&#x27;,&#x27;男&#x27;,29),(3,&#x27;王五&#x27;,&#x27;男&#x27;,21),(4,&#x27;赵六&#x27;,&#x27;女&#x27;,28),(5,&#x27;田七&#x27;,&#x27;女&#x27;,22);drop table if exists black_list;create table black_list( user_id int comment &#x27;用户编号&#x27;, type string comment &#x27;风控类型&#x27;)comment &#x27;银行黑名单信息表&#x27;;insert overwrite table black_list values(1,&#x27;诈骗&#x27;),(2,&#x27;逾期&#x27;),(3,&#x27;套现&#x27;); left join使用left join对所有用户，如果也在黑名单中，则标记为YES，否则标记为NO。 id name sex age flag 1 张三 男 20 YES 2 李四 男 29 YES 3 王五 男 21 YES 4 赵六 女 28 NO 5 田七 女 22 NO 12345select a.*, if(b.user_id is not null, &#x27;YES&#x27;, &#x27;NO&#x27;) flagfrom all_users aleft join black_list bon a.id = b.user_id; right join对上面的问题，使用right join再做一次。 id name sex age flag 1 张三 男 20 YES 2 李四 男 29 YES 3 王五 男 21 YES 4 赵六 女 28 NO 5 田七 女 22 NO 12345select b.*, if(a.user_id is not null, &#x27;YES&#x27;, &#x27;NO&#x27;) flagfrom black_list aright join all_users bon a.user_id = b.id; left semi join使用left semi join对所有用户，如果也在黑名单中，则挑选出来。 id name sex age 1 张三 男 20 2 李四 男 29 3 王五 男 21 1234select a.*from all_users aleft semi join black_list bon a.id = b.user_id; left anti join使用left anti join对所有用户，如果不在黑名单中，则挑选出来。 id name sex age 4 赵六 女 28 5 田七 女 22 1234select a.*from all_users aleft anti join black_list bon a.id = b.user_id; full join1234567891011121314151617181920--用户的存款金额。drop table if exists deposit;create table deposit ( user_id int comment &#x27;用户id&#x27;, amount int comment &#x27;存款金额&#x27;)comment &#x27;用户最新银行存款信息表&#x27;;insert overwrite table deposit values(1,2000),(2,2900),(3,2100);--用户的负债金额。drop table if exists debt;create table debt ( user_id int comment &#x27;用户id&#x27;, amount int comment &#x27;负债金额&#x27;)comment &#x27;用户最新银行负债信息表&#x27;;insert overwrite table debt values(3,3400),(4,2800),(5,2200); 使用full join，展示用户的存款金额和负债金额。 user_id deposit_amount debt_amount 1 2000 0 2 2900 0 3 2100 3400 4 0 2800 5 0 2200 123456select coalesce(a.user_id, b.user_id) as user_id, coalesce(a.amount, 0) as deposit_amount, coalesce(b.amount, 0) as debt_amountfrom deposit afull join debt bon a.user_id = b.user_id; 字节跳动【考察full join】 1、某个游戏中的元宝分为，付费元宝和免费元宝。玩家购买商城道具时候，可以使用付费元宝也可以使用免费元宝。请使用HIve SQL语句计算出2021-01-01至2021-01-07期间各个角色当日消耗元宝的付费免费比例（付费免费比 &#x3D; 付费元宝消耗量 &#x2F; 免费元宝消耗量）。 现有表结构如下： desc dm_paid_buy; #dm_paid_buy 角色使用付费元宝购买商城道具时候记录一条 time bigint #购买的时间戳 server_id string #服务器ID role_id int #角色ID cost int #购买对应道具消耗的付费元宝数量 item_id int #购买对应道具的id amount int #购买对应道具的数量 p_date string #登录日期,yyyy-MM-dd desc dm_free_buy; #dm_free_buy 角色使用免费元宝购买商城道具时候记录一条 time bigint #购买的时间戳 server_id string #服务器ID role_id int #角色ID cost int #购买对应道具消耗的免费元宝数量 item_id int #购买对应道具的id amount int #购买对应道具的数量 p_date string #登录日期,yyyy-MM-dd 示例： 结果输出 p_date server_id role_id 付费免费比 2021-01-01 123 10098 0 2021-01-01 120 10098 0.4 2021-01-02 123 10098 0.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657use interview_db;set hive.exec.mode.local.auto=true;create table if not exists dm_paid_buy( `time` bigint comment &#x27;#购买的时间戳&#x27;, server_id string comment &#x27;#服务器ID&#x27;, role_id int comment &#x27;#角色ID&#x27;, cost int comment &#x27;#购买对应道具消耗的付费元宝数量&#x27;, item_id int comment &#x27;#购买对应道具的id&#x27;, amount int comment &#x27;#购买对应道具的数量&#x27;, p_date string comment &#x27;#登录日期, yyyy-MM-dd&#x27;) comment &#x27;角色使用付费元宝购买商城道具时候记录一条&#x27;;insert overwrite table dm_paid_buy values(1234567,120,10098,2,3,4,&#x27;2021-01-01&#x27;),(1234567,120,10098,4,3,5,&#x27;2021-01-01&#x27;),(1234567,123,10098,3,3,2,&#x27;2021-01-02&#x27;),(1234567,123,10098,2,3,2,&#x27;2021-01-02&#x27;);-- 查看表结构desc dm_paid_buy;create table if not exists dm_free_buy( `time` bigint comment &#x27;#购买的时间戳&#x27;, server_id string comment &#x27;#服务器ID&#x27;, role_id int comment &#x27;#角色ID&#x27;, cost int comment &#x27;#购买对应道具消耗的免费元宝数量&#x27;, item_id int comment &#x27;#购买对应道具的id&#x27;, amount int comment &#x27;#购买对应道具的数量&#x27;, p_date string comment &#x27;#登录日期, yyyy-MM-dd&#x27;) comment &#x27;角色使用免费元宝购买商城道具时候记录一条&#x27;;insert overwrite table dm_free_buy values(1234567,123,10098,8,3,4,&#x27;2021-01-01&#x27;),(1234567,123,10098,5,3,5,&#x27;2021-01-01&#x27;),(1234567,120,10098,6,3,4,&#x27;2021-01-01&#x27;),(1234567,120,10098,9,3,5,&#x27;2021-01-01&#x27;),(1234567,123,10098,18,3,2,&#x27;2021-01-02&#x27;),(1234567,123,10098,7,3,2,&#x27;2021-01-02&#x27;);select coalesce(a.p_date, b.p_date) p_date, coalesce(a.server_id, b.server_id) server_id, coalesce(a.role_id, b.role_id) role_id, round(nvl(a.cost, 0) / b.cost, 3) as ratefrom (select p_date, server_id, role_id, sum(cost) cost from dm_paid_buy where p_date &gt;= &#x27;2021-01-01&#x27; and p_date &lt;= &#x27;2021-01-07&#x27; group by p_date, server_id, role_id) afull join (select p_date, server_id, role_id, sum(cost) cost from dm_free_buy where p_date &gt;= &#x27;2021-01-01&#x27; and p_date &lt;= &#x27;2021-01-07&#x27; group by p_date, server_id, role_id) b on a.p_date=b.p_date and a.server_id=b.server_id and a.role_id=b.role_id; join优化交通银行数据模型如下： 表T1的数据结构： 字段英文名 字段中文名 类型 主键标志 注释 Rec_no 记录号 CHAR(3) Y Ci_no 客户号 CHAR(6) N Cust_Type 客户类型 CHAR(2) N Cre_dt 开户日期 Date N Cus_sts 客户状态 Char(1) N Y-正常 N-无效 表T1的数据 Rec_no ci_no cust_type cre_dt cus_sts 123 111111 01 2010-11-15 Y 234 222222 02 2011-09-01 Y 345 333333 02 2012-01-09 Y 456 444444 01 2012-09-08 Y 表T2的数据结构： 字段英文名 字段中文名 类型 主键标志 注释 Ci_no 客户号 CHAR(6) Y AC_no 客户账号 CHAR(9) Y Bal 账号余额 DECIMAL(15，2) N 表T2的数据： Ci_no char(6) Ac_no char(9) Bal decimal(15,2) 222222 123456888 1000.28 222222 123456999 886 333333 123454321 5000 请编写sql统计在9月份开户且账户余额不为0的有效客户数。（8分） 1234567891011121314151617181920212223242526272829303132333435363738394041create table T1( rec_no int, ci_no int, cust_type string, cre_dt string, cus_sts string);insert overwrite table T1 values(123,111111,&#x27;01&#x27;,&#x27;2010-11-15&#x27;,&#x27;Y&#x27;),(234,222222,&#x27;02&#x27;,&#x27;2011-09-01&#x27;,&#x27;N&#x27;),(345,333333,&#x27;02&#x27;,&#x27;2012-01-09&#x27;,&#x27;Y&#x27;),(456,444444,&#x27;01&#x27;,&#x27;2012-09-08&#x27;,&#x27;Y&#x27;);select * from T1; create table T2( ci_no int, ac_no string, bal decimal(7,2));insert overwrite table T2 values(222222,&#x27;123456789&#x27;,1000.28),(333333,&#x27;123454321&#x27;,5000.00);select * from T2;-- 传统的写法。select count(distinct t1.ci_no) as cntfrom t1join t2 on t1.ci_no=t2.ci_nowhere month(t1.cre_dt)=9and t1.cus_sts=&#x27;Y&#x27;and bal&gt;0;-- 方案2select count(t1.ci_no) as cntfrom (select * from t1 where month(cre_dt)=9 and cus_sts=&#x27;Y&#x27;) t1join (select ci_no from t2 group by ci_no having sum(bal)&gt;0) t2on t1.ci_no=t2.ci_no;","categories":[],"tags":[{"name":"SQL强化2","slug":"SQL强化2","permalink":"http://example.com/tags/SQL%E5%BC%BA%E5%8C%962/"}]},{"title":"sql加强1","slug":"sql加强1","date":"2022-10-07T05:10:29.000Z","updated":"2022-10-07T05:11:05.400Z","comments":true,"path":"2022/10/07/sql加强1/","link":"","permalink":"http://example.com/2022/10/07/sql%E5%8A%A0%E5%BC%BA1/","excerpt":"","text":"SQL强化SQL执行顺序1234567891011121314151617181920212223242526--举例：select a.sex, b.city, count(1) as cnt, sum(salary) as sum1from table1 ajoin table2 b on a.id=b.idwhere a.name=b.namegroup by a.sex,b.cityhaving cnt&gt;=2order by a.sex,b.citylimit 10--或者是select distinct a.sex, b.city, a.agefrom table1 ajoin table2 b on a.id=b.idwhere a.name=b.nameorder by a.sex,b.citylimit 10 上面的SQL语句的执行顺序是: from (去加载table1 和 table2这2个表 ) -&gt; join -&gt; on -&gt; where -&gt; group by-&gt;select 后面的聚合函数count,sum -&gt; having -&gt; distinct -&gt; order by -&gt; limit 123456789101112131415161718192021222324252627--on 和where的先后顺序讨论--下面用left join 各得到结果，结果不一样。--下面可知，先执行on，再执行whereselect * from table1 aleft join table2 b on a.id=b.idwhere a.name=b.name;--下面的条数可能会比上面多。select * from table1 aleft join table2 b on a.id=b.idand a.name=b.name;--下面用inner join 各得到结果，结果是一样的select * from table1 ajoin table2 b on a.id=b.idwhere a.name=b.name;select * from table1 ajoin table2 b on a.id=b.idand a.name=b.name; hivesql与sparkSQL的区别： 子查询hive必须起别名，SparkSQL可以不用起别名 group by xx，yy，hive不用能用别名，spark可以用别名 hive不支持临时视图和缓存表，SparkSQL都支持 &#96;&#96;&#96;sql–用SparkSQL的临时视图use interview_db;create or replace temporary view t_view1 asselect *,if(month&#x3D;1,amount,0) as a1,if(month&#x3D;2,amount,0) as a2,if(month&#x3D;3,amount,0) as a3,if(month&#x3D;4,amount,0) as a4from table2;1 1 select year, sum(a1) as m1, sum(a2) as m2, sum(a3) as m3, sum(a4) as m4from t_view1group by year; –使用SparkSQL的缓存表cache table cached1 asselect *, if(month&#x3D;1,amount,0) as a1, if(month&#x3D;2,amount,0) as a2, if(month&#x3D;3,amount,0) as a3, if(month&#x3D;4,amount,0) as a4from table2; select * from cached1;select year, sum(a1) as m1, sum(a2) as m2, sum(a3) as m3, sum(a4) as m4from cached1group by year; 12345678910* 爆炸函数，hive不支持explode与普通字段联合使用，需要用侧视图分开，SparkSQL支持联合使用 * ```sql use interview_db; select qq,game1 from tableB lateral view explode(split(game,&#x27;_&#x27;)) view1 as game1 ; --spark还支持这样，但是hive不支持： select qq,explode(split(game,&#x27;_&#x27;)) game1 from tableB ; 123* sparkSQL支持300多种函数，hiveSQL支持200多种函数。sparkSQL函数比hiveSQL要多。 * 比如SparkSQL有sequence函数，hive就没有 先配置环境 在pycharm或datagrip或idea中配置hive数据源。也可以配置一个sparkSQL数据源，来加快速度。 如果配置hive数据源： 需要提前启动hdfs和yarn，hive的metastore，hive的hiveserver2 &#96;&#96;&#96;shell#启动hdfs和yarnstart-all.sh hive的metastorenohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service metastore 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-metastore.log &amp; #hive的hiveserver2#hiveserver2开启后，等过2分钟后才能生效。nohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service hiveserver2 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-hiveserver2.log &amp; 1234567891011121314 ![1659774353515](E:\\自研项目\\sql资料\\3\\images\\1659774353515.png)* 如果遇到下面的问题* ![1659749246129](E:\\自研项目\\sql资料\\3\\images\\1659749246129.png)* 解决办法 * ``` hive/conf/hive-env.sh中加入 export HADOOP_CLIENT_OPTS=&quot; -Xmx512m&quot; export HADOOP_HEAPSIZE=1024 改完重启hiveserver2 如果配置SparkSQL数据源 需要提前启动hdfs，hive的metastore，Spark的Thriftserver服务。 &#96;&#96;&#96;shell#启动hdfs和yarnstart-all.sh hive的metastorenohup &#x2F;export&#x2F;server&#x2F;hive&#x2F;bin&#x2F;hive –service metastore 2&gt;&amp;1 &gt; &#x2F;tmp&#x2F;hive-metastore.log &amp; #Spark的Thriftserver服务&#x2F;export&#x2F;server&#x2F;spark&#x2F;sbin&#x2F;start-thriftserver.sh –hiveconf hive.server2.thrift.port&#x3D;10001 –hiveconf hive.server2.thrift.bind.host&#x3D;node1 –master local[*] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449 * 下面是spark3集成hive3需要的jar包，如果是spark2集成hive2，则jar包不一样。![1659774447157](E:\\自研项目\\sql资料\\3\\images\\1659774447157.png) * ![1659774468920](E:\\自研项目\\sql资料\\3\\images\\1659774468920.png)```sqlshow databases ;create database if not exists test_sql;use test_sql;-- 一些语句会走 MapReduce，所以慢。 可以开启本地化执行的优化。set hive.exec.mode.local.auto=true;-- (默认为false)--第1题：访问量统计CREATE TABLE test_sql.test1 ( userId string, visitDate string, visitCount INT ) ROW format delimited FIELDS TERMINATED BY &quot;\\t&quot;;INSERT overwrite TABLE test_sql.test1VALUES ( &#x27;u01&#x27;, &#x27;2017/1/21&#x27;, 5 ), ( &#x27;u02&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u03&#x27;, &#x27;2017/1/22&#x27;, 8 ), ( &#x27;u04&#x27;, &#x27;2017/1/20&#x27;, 3 ), ( &#x27;u01&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u01&#x27;, &#x27;2017/2/21&#x27;, 8 ), ( &#x27;u02&#x27;, &#x27;2017/1/23&#x27;, 6 ), ( &#x27;u01&#x27;, &#x27;2017/2/22&#x27;, 4 );select *, sum(sum1) over(partition by userid order by month1 /*rows between unbounded preceding and current row*/ ) as `累积` from(select userid, date_format(replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;yyyy-MM&#x27;) as month1, sum(visitcount) sum1from test_sql.test1group by userid, date_format(replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;yyyy-MM&#x27;)) as t;-- 第2题：电商场景TopK统计CREATE TABLE test_sql.test2 ( user_id string, shop string ) ROW format delimited FIELDS TERMINATED BY &#x27;\\t&#x27;;INSERT INTO TABLE test_sql.test2 VALUES( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u3&#x27;, &#x27;c&#x27; ),( &#x27;u4&#x27;, &#x27;b&#x27; ),( &#x27;u1&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;c&#x27; ),( &#x27;u5&#x27;, &#x27;b&#x27; ),( &#x27;u4&#x27;, &#x27;b&#x27; ),( &#x27;u6&#x27;, &#x27;c&#x27; ),( &#x27;u2&#x27;, &#x27;c&#x27; ),( &#x27;u1&#x27;, &#x27;b&#x27; ),( &#x27;u2&#x27;, &#x27;a&#x27; ),( &#x27;u2&#x27;, &#x27;a&#x27; ),( &#x27;u3&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; ),( &#x27;u5&#x27;, &#x27;a&#x27; );--（1）每个店铺的UV（访客数）-- UV和PV-- PV是访问当前网站所有的次数-- UV是访问当前网站的客户数(需要去重)--(2)每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数select shop, count(distinct user_id) as uvfrom test_sql.test2 group by shop ;--上面的拆解来看，等价于--distinct后可以接多个字段，表示联合去重select shop, count(user_id) as uvfrom(select distinct shop, user_idfrom test_sql.test2 ) as tgroup by shop ;--也等价于select shop, count(user_id) as uvfrom(select shop, user_idfrom test_sql.test2 group by shop, user_id) as tgroup by shop ;select * from(select *, row_number() over (partition by shop order by cnt desc) as rnfrom(select shop,user_id,count(1) as cnt from test_sql.test2 group by shop,user_id ) as t) t2where t2.rn&lt;=3;-- 第3题：订单量统计CREATE TABLE test_sql.test3 ( dt string, order_id string, user_id string, amount DECIMAL ( 10, 2 ) )ROW format delimited FIELDS TERMINATED BY &#x27;\\t&#x27;;INSERT overwrite TABLE test_sql.test3 VALUES (&#x27;2017-01-01&#x27;,&#x27;10029028&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-01-01&#x27;,&#x27;10029029&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-01-01&#x27;,&#x27;100290288&#x27;,&#x27;1000003252&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;10029088&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;100290281&#x27;,&#x27;1000003251&#x27;,33.57), (&#x27;2017-02-02&#x27;,&#x27;100290282&#x27;,&#x27;1000003253&#x27;,33.57), (&#x27;2017-11-02&#x27;,&#x27;10290282&#x27;,&#x27;100003253&#x27;,234), (&#x27;2018-11-02&#x27;,&#x27;10290284&#x27;,&#x27;100003243&#x27;,234);-- (1)给出 2017年每个月的订单数、用户数、总成交金额。-- (2)给出2017年11月的新客数(指在11月才有第一笔订单)select date_format(dt,&#x27;yyyy-MM&#x27;) as month1, count(distinct order_id) as cnt1, count(distinct user_id) as cnt2, sum(amount) as amt from test_sql.test3 where year(dt)=2017group by date_format(dt,&#x27;yyyy-MM&#x27;);select count(user_id) cnt from(select user_id, min(date_format(dt,&#x27;yyyy-MM&#x27;)) min_monthfrom test3 group by user_id) as t where min_month=&#x27;2017-11&#x27;;--统计每个月的新客户数select min_month, count(user_id) cntfrom (select user_id, min(date_format(dt, &#x27;yyyy-MM&#x27;)) min_month from test3 group by user_id) as tgroup by min_month;-- 第4题：大数据排序统计CREATE TABLE test_sql.test4user (user_id string,name string,age int);CREATE TABLE test_sql.test4log (user_id string,url string);INSERT INTO TABLE test_sql.test4user VALUES(&#x27;001&#x27;,&#x27;u1&#x27;,10),(&#x27;002&#x27;,&#x27;u2&#x27;,15),(&#x27;003&#x27;,&#x27;u3&#x27;,15),(&#x27;004&#x27;,&#x27;u4&#x27;,20),(&#x27;005&#x27;,&#x27;u5&#x27;,25),(&#x27;006&#x27;,&#x27;u6&#x27;,35),(&#x27;007&#x27;,&#x27;u7&#x27;,40),(&#x27;008&#x27;,&#x27;u8&#x27;,45),(&#x27;009&#x27;,&#x27;u9&#x27;,50),(&#x27;0010&#x27;,&#x27;u10&#x27;,65);INSERT INTO TABLE test_sql.test4log VALUES(&#x27;001&#x27;,&#x27;url1&#x27;),(&#x27;002&#x27;,&#x27;url1&#x27;),(&#x27;003&#x27;,&#x27;url2&#x27;),(&#x27;004&#x27;,&#x27;url3&#x27;),(&#x27;005&#x27;,&#x27;url3&#x27;),(&#x27;006&#x27;,&#x27;url1&#x27;),(&#x27;007&#x27;,&#x27;url5&#x27;),(&#x27;008&#x27;,&#x27;url7&#x27;),(&#x27;009&#x27;,&#x27;url5&#x27;),(&#x27;0010&#x27;,&#x27;url1&#x27;);select * from test_sql.test4user ;select * from test_sql.test4log ;--有一个5000万的用户文件(user_id，name，age)，-- 一个2亿记录的用户看电影的记录文件(user_id，url)，根据年龄段观看电影的次数进行排序？--取整函数有 round，floor，ceilselect *, round(x,0) as r,--四舍五入 floor(x) as f,--向下取整 ceil(x) as c--向上取整 from(select 15/10 as x union allselect 18/10 as x union allselect 24/10 as x union allselect 27/10 as x ) as t;select type, sum(cnt) as sum1from(select *, concat(floor(age/10)*10,&#x27;-&#x27;,floor(age/10)*10+10) as typefrom test_sql.test4user as a-- join前最好提前减小数据量join (select user_id,count(url) as cnt from test_sql.test4log group by user_id) as bon a.user_id=b.user_id) as tgroup by typeorder by sum(cnt) desc;-- 第5题：活跃用户统计CREATE TABLE test5(dt string,user_id string,age int)ROW format delimited fields terminated BY &#x27;,&#x27;;INSERT overwrite TABLE test_sql.test5 VALUES (&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-11&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-11&#x27;,&#x27;test_3&#x27;,39),(&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-11&#x27;,&#x27;test_3&#x27;,39),(&#x27;2019-02-11&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-12&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-13&#x27;,&#x27;test_1&#x27;,23),(&#x27;2019-02-15&#x27;,&#x27;test_2&#x27;,19),(&#x27;2019-02-16&#x27;,&#x27;test_2&#x27;,19);select * from test_sql.test5 order by dt,user_id;--有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）-- type 总数 平均年龄-- &#x27;所有用户&#x27; 3 27-- &#x27;活跃用户&#x27; 1 19with t1 as (select distinct dt, user_id,age from test_sql.test5), t2 as (select *,row_number() over (partition by user_id order by dt) as rn from t1 ), t3 as (select *,date_sub(dt,rn) as dt2 from t2), t4 as (select dt2,user_id,age,count(1) cnt from t3 group by dt2,user_id,age), t5 as (select * from t4 where cnt&gt;=2), t6 as (select distinct user_id,age from t5)select &#x27;所有用户&#x27; as type, count(user_id) cnt,avg(age) as avg_agefrom (select distinct user_id,age from test_sql.test5) t union allselect &#x27;活跃用户&#x27; as type, count(user_id) cnt,avg(age) as avg_age from t6;-- 用思路2来分析连续2天登录with t1 as (select distinct dt, user_id from test_sql.test5), t2 as (select *, date_add(dt,1) as dt2, lead(dt,1)over(partition by user_id order by dt) as dt3 from t1)select count(distinct user_id) from t2 where dt2=dt3;-- 第6题：电商购买金额统计实战CREATE TABLE test_sql.test6 ( userid string, money decimal(10,2), paymenttime string, orderid string);INSERT INTO TABLE test_sql.test6 VALUES(&#x27;001&#x27;,100,&#x27;2017-10-01&#x27;,&#x27;123&#x27;),(&#x27;001&#x27;,200,&#x27;2017-10-02&#x27;,&#x27;124&#x27;),(&#x27;002&#x27;,500,&#x27;2017-10-01&#x27;,&#x27;125&#x27;),(&#x27;001&#x27;,100,&#x27;2017-11-01&#x27;,&#x27;126&#x27;);select * from test_sql.test6 order by userid,paymenttime;--请用sql写出所有用户中在今年10月份第一次购买商品的金额，select userid,paymenttime,moneyfrom(select *, row_number() over (partition by userid order by paymenttime) as rn from test_sql.test6 where date_format(paymenttime,&#x27;yyyy-MM&#x27;)=&#x27;2017-10&#x27; ) as twhere t.rn=1;-- 第7题：教育领域SQL实战CREATE TABLE test_sql.book(book_id string, `SORT` string, book_name string, writer string, OUTPUT string, price decimal(10,2));INSERT INTO TABLE test_sql.book VALUES(&#x27;001&#x27;,&#x27;TP391&#x27;,&#x27;信息处理&#x27;,&#x27;author1&#x27;,&#x27;机械工业出版社&#x27;,&#x27;20&#x27;),(&#x27;002&#x27;,&#x27;TP392&#x27;,&#x27;数据库&#x27;,&#x27;author12&#x27;,&#x27;科学出版社&#x27;,&#x27;15&#x27;),(&#x27;003&#x27;,&#x27;TP393&#x27;,&#x27;计算机网络&#x27;,&#x27;author3&#x27;,&#x27;机械工业出版社&#x27;,&#x27;29&#x27;),(&#x27;004&#x27;,&#x27;TP399&#x27;,&#x27;微机原理&#x27;,&#x27;author4&#x27;,&#x27;科学出版社&#x27;,&#x27;39&#x27;),(&#x27;005&#x27;,&#x27;C931&#x27;,&#x27;管理信息系统&#x27;,&#x27;author5&#x27;,&#x27;机械工业出版社&#x27;,&#x27;40&#x27;),(&#x27;006&#x27;,&#x27;C932&#x27;,&#x27;运筹学&#x27;,&#x27;author6&#x27;,&#x27;科学出版社&#x27;,&#x27;55&#x27;);CREATE TABLE test_sql.reader (reader_id string, company string, name string, sex string, grade string, addr string);INSERT INTO TABLE test_sql.reader VALUES(&#x27;0001&#x27;,&#x27;阿里巴巴&#x27;,&#x27;jack&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr1&#x27;),(&#x27;0002&#x27;,&#x27;百度&#x27;,&#x27;robin&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr2&#x27;),(&#x27;0003&#x27;,&#x27;腾讯&#x27;,&#x27;tony&#x27;,&#x27;男&#x27;,&#x27;vp&#x27;,&#x27;addr3&#x27;),(&#x27;0004&#x27;,&#x27;京东&#x27;,&#x27;jasper&#x27;,&#x27;男&#x27;,&#x27;cfo&#x27;,&#x27;addr4&#x27;),(&#x27;0005&#x27;,&#x27;网易&#x27;,&#x27;zhangsan&#x27;,&#x27;女&#x27;,&#x27;ceo&#x27;,&#x27;addr5&#x27;),(&#x27;0006&#x27;,&#x27;搜狐&#x27;,&#x27;lisi&#x27;,&#x27;女&#x27;,&#x27;ceo&#x27;,&#x27;addr6&#x27;);CREATE TABLE test_sql.borrow_log(reader_id string, book_id string, borrow_date string);INSERT INTO TABLE test_sql.borrow_log VALUES (&#x27;0001&#x27;,&#x27;002&#x27;,&#x27;2019-10-14&#x27;),(&#x27;0002&#x27;,&#x27;001&#x27;,&#x27;2019-10-13&#x27;),(&#x27;0003&#x27;,&#x27;005&#x27;,&#x27;2019-09-14&#x27;),(&#x27;0004&#x27;,&#x27;006&#x27;,&#x27;2019-08-15&#x27;),(&#x27;0005&#x27;,&#x27;003&#x27;,&#x27;2019-10-10&#x27;),(&#x27;0006&#x27;,&#x27;004&#x27;,&#x27;2019-17-13&#x27;);select * from test_sql.book;select * from test_sql.reader;select * from test_sql.borrow_log;--（8）考虑到数据安全的需要，需定时将“借阅记录”中数据进行备份，请使用一条SQL语句，-- 在备份用户bak下创建与“借阅记录”表结构完全一致的数据表BORROW_LOG_BAK.-- 井且将“借阅记录”中现有数据全部复制到BORROW_L0G_ BAK中。create table test_sql.BORROW_LOG_BAK as select * from test_sql.borrow_log;select * from test_sql.BORROW_LOG_BAK;--（9）现在需要将原Oracle数据库中数据迁移至Hive仓库，-- 请写出“图书”在Hive中的建表语句（Hive实现，提示：列分隔符|；-- 数据表数据需要外部导入：分区分别以month＿part、day＿part 命名）CREATE TABLE test_sql.book2( book_id string, `SORT` string, book_name string, writer string, OUTPUT string, price decimal(10, 2))partitioned by (month_part string,day_part string ) row format delimited fields terminated by &#x27;|&#x27;;--（10）Hive中有表A，现在需要将表A的月分区 201505 中 -- user＿id为20000的user＿dinner字段更新为bonc8920，其他用户user＿dinner字段数据不变，-- 请列出更新的方法步骤。（Hive实现，提示：Hive中无update语法，请通过其他办法进行数据更新）--A-- user_id user_dinner part-- 20000 aaaaa 201505-- 30000 bbbbb 201505create table A (user_id int,user_dinner string) partitioned by (part string);insert overwrite table A partition (part = &#x27;201505&#x27;)values (20000, &#x27;aaaaa&#x27;), (30000, &#x27;bbbbb&#x27;), (40000, &#x27;ccccc&#x27;);select * from A;--update A set user_dinner=&#x27;bonc8920&#x27; where user_id=20000;insert overwrite table A partition (part = &#x27;201505&#x27;)select user_id, &#x27;bonc8920&#x27; as user_dinner from A where user_id=20000 and part = &#x27;201505&#x27; union allselect user_id, user_dinner from A where user_id!=20000 and part = &#x27;201505&#x27; ;-- 第8题：服务日志SQL统计CREATE TABLE test_sql.test8(`date` string, interface string, ip string);INSERT INTO TABLE test_sql.test8 VALUES(&#x27;2016-11-09 11:22:05&#x27;,&#x27;/api/user/login&#x27;,&#x27;110.23.5.23&#x27;),(&#x27;2016-11-09 11:23:10&#x27;,&#x27;/api/user/detail&#x27;,&#x27;57.3.2.16&#x27;),(&#x27;2016-11-09 23:59:40&#x27;,&#x27;/api/user/login&#x27;,&#x27;200.6.5.166&#x27;),(&#x27;2016-11-09 11:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;136.79.47.70&#x27;),(&#x27;2016-11-09 11:15:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;94.144.143.141&#x27;),(&#x27;2016-11-09 11:16:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;197.161.8.206&#x27;),(&#x27;2016-11-09 12:14:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;240.227.107.145&#x27;),(&#x27;2016-11-09 13:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;79.130.122.205&#x27;),(&#x27;2016-11-09 14:14:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;65.228.251.189&#x27;),(&#x27;2016-11-09 14:15:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;245.23.122.44&#x27;),(&#x27;2016-11-09 14:17:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;22.74.142.137&#x27;),(&#x27;2016-11-09 14:19:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;54.93.212.87&#x27;),(&#x27;2016-11-09 14:20:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;218.15.167.248&#x27;),(&#x27;2016-11-09 14:24:23&#x27;,&#x27;/api/user/detail&#x27;,&#x27;20.117.19.75&#x27;),(&#x27;2016-11-09 15:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;183.162.66.97&#x27;),(&#x27;2016-11-09 16:14:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;108.181.245.147&#x27;),(&#x27;2016-11-09 14:17:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;22.74.142.137&#x27;),(&#x27;2016-11-09 14:19:23&#x27;,&#x27;/api/user/login&#x27;,&#x27;22.74.142.137&#x27;);select * from test_sql.test8;--求11月9号下午14点（14-15点），访问/api/user/login接口的top10的ip地址select ip, count(1) cntfrom test_sql.test8where date_format(`date`, &#x27;yyyy-MM-dd HH&#x27;) = &#x27;2016-11-09 14&#x27; and interface = &#x27;/api/user/login&#x27;group by iporder by cnt desclimit 10;-- 第9题：充值日志SQL实战CREATE TABLE test_sql.test9( dist_id string COMMENT &#x27;区组id&#x27;, account string COMMENT &#x27;账号&#x27;, `money` decimal(10,2) COMMENT &#x27;充值金额&#x27;, create_time string COMMENT &#x27;订单时间&#x27;);INSERT INTO TABLE test_sql.test9 VALUES (&#x27;1&#x27;,&#x27;11&#x27;,100006,&#x27;2019-01-02 13:00:01&#x27;), (&#x27;1&#x27;,&#x27;22&#x27;,110000,&#x27;2019-01-02 13:00:02&#x27;), (&#x27;1&#x27;,&#x27;33&#x27;,102000,&#x27;2019-01-02 13:00:03&#x27;), (&#x27;1&#x27;,&#x27;44&#x27;,100300,&#x27;2019-01-02 13:00:04&#x27;), (&#x27;1&#x27;,&#x27;55&#x27;,100040,&#x27;2019-01-02 13:00:05&#x27;), (&#x27;1&#x27;,&#x27;66&#x27;,100005,&#x27;2019-01-02 13:00:06&#x27;), (&#x27;1&#x27;,&#x27;77&#x27;,180000,&#x27;2019-01-03 13:00:07&#x27;), (&#x27;1&#x27;,&#x27;88&#x27;,106000,&#x27;2019-01-02 13:00:08&#x27;), (&#x27;1&#x27;,&#x27;99&#x27;,100400,&#x27;2019-01-02 13:00:09&#x27;), (&#x27;1&#x27;,&#x27;12&#x27;,100030,&#x27;2019-01-02 13:00:10&#x27;), (&#x27;1&#x27;,&#x27;13&#x27;,100003,&#x27;2019-01-02 13:00:20&#x27;), (&#x27;1&#x27;,&#x27;14&#x27;,100020,&#x27;2019-01-02 13:00:30&#x27;), (&#x27;1&#x27;,&#x27;15&#x27;,100500,&#x27;2019-01-02 13:00:40&#x27;), (&#x27;1&#x27;,&#x27;16&#x27;,106000,&#x27;2019-01-02 13:00:50&#x27;), (&#x27;1&#x27;,&#x27;17&#x27;,100800,&#x27;2019-01-02 13:00:59&#x27;), (&#x27;2&#x27;,&#x27;18&#x27;,100800,&#x27;2019-01-02 13:00:11&#x27;), (&#x27;2&#x27;,&#x27;19&#x27;,100030,&#x27;2019-01-02 13:00:12&#x27;), (&#x27;2&#x27;,&#x27;10&#x27;,100000,&#x27;2019-01-02 13:00:13&#x27;), (&#x27;2&#x27;,&#x27;45&#x27;,100010,&#x27;2019-01-02 13:00:14&#x27;), (&#x27;2&#x27;,&#x27;78&#x27;,100070,&#x27;2019-01-02 13:00:15&#x27;);select * from test_sql.test9 order by dist_id , money desc;--请写出SQL语句，查询充值日志表2019年01月02号每个区组下充值额最大的账号，要求结果：--区组id，账号，金额，充值时间select * from(select *, row_number() over (partition by dist_id order by money desc) rnfrom test_sql.test9 where to_date(create_time)=&#x27;2019-01-02&#x27;) twhere t.rn=1;-- 第10题：电商分组TopK实战CREATE TABLE test_sql.test10( `dist_id` string COMMENT &#x27;区组id&#x27;, `account` string COMMENT &#x27;账号&#x27;, `gold` int COMMENT &#x27;金币&#x27;);INSERT INTO TABLE test_sql.test10 VALUES (&#x27;1&#x27;,&#x27;77&#x27;,18), (&#x27;1&#x27;,&#x27;88&#x27;,106), (&#x27;1&#x27;,&#x27;99&#x27;,10), (&#x27;1&#x27;,&#x27;12&#x27;,13), (&#x27;1&#x27;,&#x27;13&#x27;,14), (&#x27;1&#x27;,&#x27;14&#x27;,25), (&#x27;1&#x27;,&#x27;15&#x27;,36), (&#x27;1&#x27;,&#x27;16&#x27;,12), (&#x27;1&#x27;,&#x27;17&#x27;,158), (&#x27;2&#x27;,&#x27;18&#x27;,12), (&#x27;2&#x27;,&#x27;19&#x27;,44), (&#x27;2&#x27;,&#x27;10&#x27;,66), (&#x27;2&#x27;,&#x27;45&#x27;,80), (&#x27;2&#x27;,&#x27;78&#x27;,98);select * from test_sql.test10;select * from(select *, row_number() over (partition by dist_id order by gold desc) rnfrom test_sql.test10 ) twhere t.rn&lt;=10; 行转列(转置) 行转列的常规做法是，group by+sum(if())【或count(if())】 华泰证券1已知 year month amount 1991 1 1.1 1991 2 1.2 1991 3 1.3 1991 4 1.4 1992 1 2.1 1992 2 2.2 1992 3 2.3 1992 4 2.4 查成这样一个结果 year m1 m2 m3 m4 1991 1.1 1.2 1.3 1.4 1992 2.1 2.2 2.3 2.4 解答 &#96;&#96;&#96;sqluse test_sql;set hive.exec.mode.local.auto&#x3D;true;create table table2(year int,month int ,amount double) ; insert overwrite table table2 values (1991,1,1.1), (1991,2,1.2), (1991,3,1.3), (1991,4,1.4), (1992,1,2.1), (1992,2,2.2), (1992,3,2.3), (1992,4,2.4);select * from table2; –行转列–常规做法是，group by+sum(if())–SQLserver中有pivot专门用来行转列–原始写法select year, sum(a) as m1, sum(b) as m2, sum(c) as m3, sum(d) as m4from(select *, if(month&#x3D;1,amount,0) a, if(month&#x3D;2,amount,0) b, if(month&#x3D;3,amount,0) c, if(month&#x3D;4,amount,0) d from table2) tgroup by t.year;–简化写法select year, sum(if(month&#x3D;1,amount,0)) m1, sum(if(month&#x3D;2,amount,0)) m2, sum(if(month&#x3D;3,amount,0)) m3, sum(if(month&#x3D;4,amount,0)) m4from table2group by year; 1234567891011121314151617181920212223242526272829303132333435363738394041424344### 华泰证券2* 查询课程编号“2”的成绩比课程编号“1”低的所有同学的学号、姓名。* 【这是行转列的衍生题】* ```sql create table student(sid int, sname string, gender string, class_id int); insert overwrite table student values (1, &#x27;张三&#x27;, &#x27;女&#x27;, 1), (2, &#x27;李四&#x27;, &#x27;女&#x27;, 1), (3, &#x27;王五&#x27;, &#x27;男&#x27;, 2); select * from student; create table course (cid int, cname string, teacher_id int); insert overwrite table course values (1, &#x27;生物&#x27;, 1), (2, &#x27;体育&#x27;, 1), (3, &#x27;物理&#x27;, 2); select * from course; create table score (sid int, student_id int, course_id int, number int); insert overwrite table score values (1, 1, 1, 58), (4, 1, 2, 50), (2, 1, 2, 68), (3, 2, 2, 89); select * from score; with t1 as( select student_id, sum(if(course_id=2,number,0)) as pe, --体育 sum(if(course_id=1,number,0)) as bio --生物 from score group by student_id having pe&lt;bio) select sid, sname from t1 join student on t1.student_id = sid ; 腾讯游戏表table如下： DDate shengfu 2015-05-09 胜 2015-05-09 胜 2015-05-09 负 2015-05-09 负 2015-05-10 胜 2015-05-10 负 2015-05-10 负 如果要生成下列结果, 该如何写sql语句? DDate 胜 负 2015-05-09 2 2 2015-05-10 1 2 123456789101112131415--建表create table table1(DDate string, shengfu string) ;insert overwrite table table1 values (&#x27;2015-05-09&#x27;, &quot;胜&quot;), (&#x27;2015-05-09&#x27;, &quot;胜&quot;), (&#x27;2015-05-09&#x27;, &quot;负&quot;), (&#x27;2015-05-09&#x27;, &quot;负&quot;), (&#x27;2015-05-10&#x27;, &quot;胜&quot;), (&#x27;2015-05-10&#x27;, &quot;负&quot;), (&#x27;2015-05-10&#x27;, &quot;负&quot;);select DDate, SUM(case when shengfu = &#x27;胜&#x27; then 1 else 0 end) `胜`, SUM(case when shengfu = &#x27;负&#x27; then 1 else 0 end) `负`from table1group by DDate; 腾讯QQ假设tableA如表5, tableB如表6, 表5 qq号（字段名：qq） 游戏（字段名：game） 10000 a 10000 b 10000 c 20000 c 20000 d 表6 qq号（字段名：qq） 游戏（字段名：game） 10000 a_b_c 20000 c_d 请写出以下sql逻辑： a, 将tableA输出为tableB的格式； 【行转列】 b, 将tableB输出为tableA的格式; 【列转行】 1234567891011121314151617181920212223create table tableA(qq string, game string) insert overwrite table tableA values (10000, &#x27;a&#x27;), (10000, &#x27;b&#x27;), (10000, &#x27;c&#x27;), (20000, &#x27;c&#x27;), (20000, &#x27;d&#x27;);create table tableB(qq string, game string) ;insert overwrite table tableB values (10000, &#x27;a_b_c&#x27;),(20000, &#x27;c_d&#x27;); --将tableA输出为tableB的格式； select qq, concat_ws(&#x27;_&#x27;, collect_list(game)) gamefrom tableAgroup by qq; --将tableB输出为tableA的格式; select qq, tmp.gamefrom tableB lateral view explode(split(game, &#x27;_&#x27;)) tmp as game; 连续N天登陆 思路分析过程 &#96;&#96;&#96;sql–核心代码-&gt;distinct-&gt; row_number-&gt; date_sub(dt,rn) as dt2-&gt; group by dt2,name-&gt; where count(1)&gt;&#x3D;N天-&gt; distinct name-&gt; count(name) 123456789101112131415 * 思路2* ![1659759179547](E:\\自研项目\\sql资料\\3\\images\\1659759179547.png)* ```sql --核心代码 -&gt;distinct -&gt;date_add(dt,N-1) as date2 -&gt;lead(dt,N-1) over(partition by userid order by dt) as date3 -&gt;where date2=date3 -&gt;distinct OPPO3、以下为用户登陆游戏的日期，用一条sQL语句查询出连续三天登录的人员姓名 name date 张三 2021-01-01 张三 2021-01-02 张三 2021-01-03 张三 2021-01-02 李四 2021-01-01 李四 2021-01-02 王五 2021-01-03 王五 2021-01-02 王五 2021-01-02 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647create table game(name string, `date` string);insert overwrite table game values(&#x27;张三&#x27;,&#x27;2021-01-01&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-02&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-03&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-02&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-07&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-08&#x27;),(&#x27;张三&#x27;,&#x27;2021-01-09&#x27;),(&#x27;李四&#x27;,&#x27;2021-01-01&#x27;),(&#x27;李四&#x27;,&#x27;2021-01-02&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-03&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-02&#x27;),(&#x27;王五&#x27;,&#x27;2021-01-02&#x27;);with t1 as ( select distinct name,date from game), t2 as ( select *, row_number() over (partition by name order by date) rn from t1), t3 as ( select *,date_sub(date,rn) date2 from t2 ) select distinct name from t3 group by name,date2 having count(1)&gt;=3; --方案二select * from game;with t1 as ( select distinct name,`date` from game), t2 as ( select *, date_add(`date`,3-1) as date2, lead(`date`,3-1) over(partition by name order by `date`) as date3 from t1 )select distinct name from t2 where date2=date3;--方案二的写法2with t1 as ( select distinct name,`date` from game), t2 as ( select *, lead(`date`,3-1) over(partition by name order by `date`) as date3 from t1 )select distinct name from t2 where datediff(date3,`date`)=2 ; 脉脉用户每日登陆脉脉会访问app不同的模块，现有两个表 表1记录了每日脉脉活跃用户的uid和不同模块的活跃时长 表2记录了脉脉所有注册用户的一些属性 表1：maimai.dau d uid module active_duration 列说明 2020-01-01 1 jobs 324 d：活跃的日期uid：用户的唯一编码module：用户活跃模块actre.duration：该模块下对应的活跃时长（单位：s） 2020-01-01 2 feeds 445 2020-01-01 3 im 345 2020-01-02 2 network 765 2020-01-02 3 jobs 342 … … … … 在过去一个月内,曾连续两天活跃的用户 123456789101112131415161718192021222324252627282930-- 建表-- 表1 dau 记录了每日脉脉活跃用户的uid和不同模块的活跃时长create table dau(d string, uid int, module string, active_duration int);insert overwrite table dauvalues (&#x27;2020-01-01&#x27;, 1, &#x27;jobs&#x27;, 324), (&#x27;2020-01-01&#x27;, 2, &#x27;feeds&#x27;, 445), (&#x27;2020-01-01&#x27;, 3, &#x27;im&#x27;, 345), (&#x27;2020-01-02&#x27;, 2, &#x27;network&#x27;, 765), (&#x27;2020-01-02&#x27;, 3, &#x27;jobs&#x27;, 342);select *from dau;with t1 as ( select DISTINCT d, uid from dau), t2 as ( select *, date_sub(d, (row_number() over (partition by uid order by d))) dis from t1 where d &lt;= `current_date`() and d &gt;= date_sub((`current_date`()), 30)),t3 as ( select uid, min(d) `开始日期`, max(d) `结束日期`, count(1) `连续登入天数` from t2 group by uid,dis having count(*) &gt;= 2 )select DISTINCT uid from t3 ; 广州银行有一张表C_T（列举了部分数据）表示持卡人消费记录，表结构如下： CARD NER VARCHAR2 卡号， C_MONTH NUMBER 消费月份， C_DATE DATE 消费日期， C_TYPEVAR CHAR2 消费类型 C_ATM NUMBER 消费金额 每个月每张卡连续消费的最大天数（如卡在当月只有一次消费则为1）。 连续消费天数：指一楼时间内连续每天都有消费，同一天有多笔消费算一天消费，不能跨月份统计。 123456789101112131415161718192021222324252627create table c_t( card_nbr string, c_month string, c_date string, c_type string, c_atm decimal);insert overwrite table c_t values (1,&#x27;2022-01&#x27;,&#x27;2022-01-01&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-01&#x27;,&#x27;2022-01-02&#x27;,&#x27;网购&#x27;,200), (1,&#x27;2022-01&#x27;,&#x27;2022-01-03&#x27;,&#x27;网购&#x27;,300), (1,&#x27;2022-01&#x27;,&#x27;2022-01-15&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-01&#x27;,&#x27;2022-01-16&#x27;,&#x27;网购&#x27;,200), (2,&#x27;2022-01&#x27;,&#x27;2022-01-06&#x27;,&#x27;网购&#x27;,500), (2,&#x27;2022-01&#x27;,&#x27;2022-01-07&#x27;,&#x27;网购&#x27;,800), (1,&#x27;2022-02&#x27;,&#x27;2022-02-01&#x27;,&#x27;网购&#x27;,100), (1,&#x27;2022-02&#x27;,&#x27;2022-02-02&#x27;,&#x27;网购&#x27;,200), (1,&#x27;2022-02&#x27;,&#x27;2022-02-03&#x27;,&#x27;网购&#x27;,300), (2,&#x27;2022-02&#x27;,&#x27;2022-02-06&#x27;,&#x27;网购&#x27;,500), (2,&#x27;2022-02&#x27;,&#x27;2022-02-07&#x27;,&#x27;网购&#x27;,800);with t1 as (select distinct card_nbr,c_month,c_date from c_t), t2 as (select *,row_number() over (partition by card_nbr,c_month order by c_date) rn from t1 ), t3 as (select *,date_sub(c_date,rn) dt2 from t2 ), t4 as (select dt2,card_nbr,c_month,count(1) as cnt from t3 group by dt2,card_nbr,c_month), t5 as ( select *,row_number() over (partition by card_nbr,c_month order by cnt desc) as rn from t4)select card_nbr,c_month,cnt from t5 where rn=1 N日留存率 核心代码 -&gt; where 日期 in (首日,1天后,7天后) -&gt; group by 用户 -&gt;count(if(日期=首日,1,null)) as cnt count(if(日期=1天后,1,null)) as cnt2 count(if(日期=7天后,1,null)) as cnt8 -&gt;having cnt&gt;0 -&gt;count(user_id) as 首日总数 count(if(cnt2&gt;0,1,null)) as 次日留存数 count(if(cnt8&gt;0,1,null)) as 7日留存数 -&gt;次日留存数/首日总数 as 次日留存率 7日留存数/首日总数 as 7日留存率 1234567891011121314* 先按用户分组，得到每个用户的各相关日期的登录情况。 * ```sql select cuid, count(if(event_day=&#x27;2020-04-01&#x27;,1,null)) as cnt, count(if(event_day=&#x27;2020-04-02&#x27;,1,null)) as cnt2, count(if(event_day=&#x27;2020-04-08&#x27;,1,null)) as cnt8 from tb_cuid_1d --提前过滤数据 where event_day in (&#x27;2020-04-01&#x27;,&#x27;2020-04-02&#x27;,&#x27;2020-04-08&#x27;) group by cuid -- 2020-04-01必须登录，剔除掉2020-04-01没登录的 having cnt&gt;0 效果如下 &lt;div align=&quot;left&quot;&gt;&lt;img src=&quot;images/1659841600894.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/div&gt; 再对上面的用户汇总 &#96;&#96;&#96;sqlselect count(cnt) as uv, count(if(cnt2!&#x3D;0,1,null)) as uv2, count(if(cnt8!&#x3D;0,1,null)) as uv81234567891011121314 * &lt;div align=&quot;left&quot;&gt;&lt;img src=&quot;images/1659841614840.png&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/div&gt;* 最后再用 【后续日期的留存数】除以【首日总数】，就是【留存率】* 方案二，性能慢，但是步骤比较简单 ```sql select count(a.cuid) uv, count(b.cuid) uv2, count(c.cuid) uv7 from (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;首日&#x27;) as a left join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;次日&#x27;) as b on a.cuid=b.cuid left join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;7日后&#x27;) as c on a.cuid=c.cuid; 腾讯视频号游戏直播表：tableA ds(日期) device user_id is_active 2020-03-01 ios 0001 0 2020-03-01 ios 0002 1 2020-03-01 android 0003 1 2020-03-02 ios 0001 0 2020-03-02 ios 0002 0 2020-03-02 android 0003 1 20200301的ios设备用户活跃的次日留存率是多少？ 1234567891011121314151617181920212223242526272829303132333435363738394041use test_sql;set hive.exec.mode.local.auto=true;--腾讯视频号游戏直播drop table if exists tableA;create table tableA(ds string comment &#x27;(日期)&#x27; ,device string,user_id string,is_active int) ;insert overwrite table tableA values(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0001&#x27;,0),(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0002&#x27;,1),(&#x27;2020-03-01&#x27;,&#x27;ios&#x27;,&#x27;0004&#x27;,1),(&#x27;2020-03-01&#x27;,&#x27;android&#x27;,&#x27;0003&#x27;,1),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0001&#x27;,0),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0002&#x27;,0),(&#x27;2020-03-02&#x27;,&#x27;android&#x27;,&#x27;0003&#x27;,1),(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0005&#x27;,1) ,(&#x27;2020-03-02&#x27;,&#x27;ios&#x27;,&#x27;0004&#x27;,1) ;--方案1，过程见下面的顺序编号with t1 as ( select user_id, --3-一个用户如果在&#x27;2020-03-01&#x27;活跃，则cnt1&gt;0 count(if(ds = &#x27;2020-03-01&#x27;, 1, null)) cnt1, --4-一个用户如果在&#x27;2020-03-02&#x27;活跃，则cnt2&gt;0 count(if(ds = &#x27;2020-03-02&#x27; and is_active = 1, 1, null)) cnt2 from tableA --1-预先全局过滤 where device = &#x27;ios&#x27; and ( (ds=&#x27;2020-03-01&#x27; and is_active = 1) or ds=&#x27;2020-03-02&#x27;) --2-按用户分组 group by user_id --6-只筛选&#x27;2020-03-01&#x27;活跃的用户，他在&#x27;2020-03-02&#x27;是否活跃，看cnt2=0则不活跃，&gt;0则活跃 having cnt1 &gt; 0)select count(cnt1) sum1,--&#x27;2020-03-01&#x27;的活跃数 count(if(cnt2 &gt; 0, user_id, null)) sum2,----并且在次日依然活跃的用户数 count(if(cnt2 &gt; 0, user_id, null)) / count(cnt1) rate--次日留存率from t1; 百度有1张表 123456789101112131415161718create table if not exists tb_cuid_1d( cuid string comment &#x27;用户的唯一标识&#x27;, os string comment &#x27;平台&#x27;, soft_version string comment &#x27;版本&#x27;, event_day string comment &#x27;日期&#x27;, visit_time int comment &#x27;用户访问时间戳&#x27;, duration decimal comment &#x27;用户访问时长&#x27;, ext array&lt;string&gt; comment &#x27;扩展字段&#x27;);insert overwrite table tb_cuid_1d values (1,&#x27;android&#x27;,1,&#x27;2020-04-01&#x27;,1234567,100,`array`(&#x27;&#x27;)), (1,&#x27;android&#x27;,1,&#x27;2020-04-02&#x27;,1234567,100,`array`(&#x27;&#x27;)), (1,&#x27;android&#x27;,1,&#x27;2020-04-08&#x27;,1234567,100,`array`(&#x27;&#x27;)), (2,&#x27;android&#x27;,1,&#x27;2020-04-01&#x27;,1234567,100,`array`(&#x27;&#x27;)), (3,&#x27;android&#x27;,1,&#x27;2020-04-02&#x27;,1234567,100,`array`(&#x27;&#x27;)); 写出用户表 tb_cuid_1d的 20200401 的次日、次7日留存的具体HQL ： 一条sql统计出以下指标 （4.1号uv，4.1号在4.2号的留存uv，4.1号在4.8号的留存uv）; 12345678910111213141516171819202122232425262728--一个理解简单，但是性能不快的做法select count(a.cuid) uv, count(b.cuid) uv2, count(c.cuid) uv7from (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-01&#x27;) as aleft join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-02&#x27;) as b on a.cuid=b.cuidleft join (select distinct event_day, cuid from tb_cuid_1d where event_day=&#x27;2020-04-08&#x27;) as c on a.cuid=c.cuid;--另一个理解稍微复杂，但是性能快的做法with t1 as ( select cuid, count(if(event_day=&#x27;2020-04-01&#x27;,1,null)) as cnt1, count(if(event_day=&#x27;2020-04-02&#x27;,1,null)) as cnt2, count(if(event_day=&#x27;2020-04-08&#x27;,1,null)) as cnt8 from tb_cuid_1d where event_day in (&#x27;2020-04-01&#x27;,&#x27;2020-04-02&#x27;,&#x27;2020-04-08&#x27;) group by cuid having cnt1 &gt;0), t2 as (select count(cuid) as uv1, count(if(cnt2 &gt; 0, 1, null)) as uv2, count(if(cnt8 &gt; 0, 1, null)) as uv7 from t1 )select *, uv2 / uv1 as `次日留存率`, uv7 / uv1 as `7日留存率`from t2 窗口函数 窗口函数最重要的特点是有over关键字，代表定义窗口 函数名(字段名) over(partition by xxx,yyy order by zzz) 常见的窗口函数也就只有3大类 第一大类、聚合类的窗口函数【也就只有5个】 sum() over() count&#x2F;avg&#x2F;max&#x2F;min 第二大类、排序类的窗口函数【也就只有3个】 row_number，rank，dense_rank 第三大类、偏移类的，跨行的【也就只有2个】 lag &#x2F; lead 其他用的极少【仅了解】 first_value、last_value、ntile 所以企业中用的最多的也就是sum，count，row_number 交通银行Emp表的表数据如下： NAME MONTH AMT 张三 01 100 李四 02 120 王五 03 150 赵六 04 500 张三 05 400 李四 06 350 王五 07 180 赵六 08 400 问题：请写出可以得到以下的结果SQL NAME 总金额 排名 占比 赵六 900 1 40.91% 张三 500 2 22.73% 李四 470 3 21.36% 王五 330 4 15.00% 1234567891011121314151617181920212223create table emp(name string , month string, amt int);insert overwrite table emp values (&#x27;张三&#x27;, &#x27;01&#x27;, 100), (&#x27;李四&#x27;, &#x27;02&#x27;, 120), (&#x27;王五&#x27;, &#x27;03&#x27;, 150), (&#x27;赵六&#x27;, &#x27;04&#x27;, 500), (&#x27;张三&#x27;, &#x27;05&#x27;, 400), (&#x27;李四&#x27;, &#x27;06&#x27;, 350), (&#x27;王五&#x27;, &#x27;07&#x27;, 180), (&#x27;赵六&#x27;, &#x27;08&#x27;, 400);--rank 1224--dense_rank 1223with t1 as (select name, sum(amt) as sum_amt from emp group by name), t2 as ( select name, sum_amt, row_number() over (order by sum_amt desc) rn, sum_amt/sum(sum_amt) over () as rate from t1 )select name, sum_amt, rn, concat(round(rate*100,2),&#x27;%&#x27;) rate from t2 跨越物流题目描述 在员工表的基础上，统计每年入职总数以及截至本年累计入职总人数。 截至本年累计入职总人数&#x3D;本年总入职人数 + 本年之前所有年的总入职人数之和 结果 1234567891011121314151617181920212223create table emp(empno string ,ename string,hiredate string,sal int ,deptno string);insert overwrite table emp values(&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;1981-2-22&#x27;, 1250, 30),(&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;1981-4-2&#x27;, 2975, 20),(&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;1987-7-13&#x27;, 1100, 20),(&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;1980-12-17&#x27;, 800, 20),(&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;1982-1-23&#x27;, 1300, 10),(&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;1981-9-8&#x27;, 1500, 30),(&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;1981-6-9&#x27;, 2450, 10),(&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;1981-11-17&#x27;, 5000, 10),(&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;1981-12-3&#x27;, 3000, 20),(&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;1981-2-20&#x27;, 1600, 30),(&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;1981-9-28&#x27;, 1250, 30),(&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;1981-12-3&#x27;, 950, 30),(&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;1987-7-13&#x27;, 3000, 20),(&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;1981-5-1&#x27;, 2850, 30);select *, sum(cnt) over (order by year1) cnt2from(select year(hiredate) as year1, count(1) as cntfrom empgroup by year(hiredate)) a; 广州银行假设有商品表goods，数据如下 Goods_type goods_name price goods_flag 手机 华为mate 2999 手机 苹果phoneX 7999 手机 荣耀V10 2399 水果 车厘子 79 水果 葡萄 18 水果 苹果 12 电脑 金士顿16G 499 根据商品大类Goods_type对商品金额price从小到大排序，前30%为低挡，30%~85%为中档，高于85%为高档，打上标签。 1234567891011121314151617181920212223242526drop table if exists goods;create table goods(goods_type string,goods_name string ,price int);insert overwrite table goodsvalues (&#x27;手机&#x27;, &#x27;华为保时捷折叠手机&#x27;, 12000), (&#x27;手机&#x27;, &#x27;苹果phoneX&#x27;, 7999), (&#x27;手机&#x27;, &#x27;华为mate&#x27;, 2999), (&#x27;手机&#x27;, &#x27;荣耀V10&#x27;, 2399), (&#x27;水果&#x27;, &#x27;榴莲&#x27;, 60), (&#x27;水果&#x27;, &#x27;车厘子&#x27;, 40), (&#x27;水果&#x27;, &#x27;葡萄&#x27;, 18), (&#x27;水果&#x27;, &#x27;苹果&#x27;, 12), (&#x27;电脑&#x27;, &#x27;金士顿16G&#x27;, 499);select *, rn / cnt as rate, case when rn / cnt &lt; 0.3 then &#x27;低挡&#x27; when rn / cnt &gt;= 0.3 and rn / cnt &lt; 0.85 then &#x27;中挡&#x27; when rn / cnt &gt;= 0.85 then &#x27;高挡&#x27; end flagfrom ( select *, row_number() over (partition by goods_type order by price) rn, count(1) over (partition by goods_type) cnt from goods ) t1; 分组内top前几 需求常见词： 【每组xxx内按yyy排序的前n个zzz】 【每组xxx内按yyy排序的第1个zzz】 【每组xxx内按yyy排序的最后1个zzz】 特点是yyy和zzz是不同的字段。 比如：班内按性别xxx分组，组内按身高yyy排序，每个性别组的前3个学生姓名zzz 公式： 123456select * from (select zzz, row_number() over(partition by 组名xxx order by yyy) as rnfrom table) as twhere rn&lt;=N名 跨越物流员工表结构 员工表数据 题目描述 求出每个部门工资最高的前三名员工，并计算这些员工的工资占所属部门总工资的百分比。 结果 12345678910111213141516171819202122232425262728293031323334create table emp(empno string ,ename string,hiredate string,sal int ,deptno string);insert overwrite table emp values(&#x27;7521&#x27;, &#x27;WARD&#x27;, &#x27;1981-2-22&#x27;, 1250, 30),(&#x27;7566&#x27;, &#x27;JONES&#x27;, &#x27;1981-4-2&#x27;, 2975, 20),(&#x27;7876&#x27;, &#x27;ADAMS&#x27;, &#x27;1987-7-13&#x27;, 1100, 20),(&#x27;7369&#x27;, &#x27;SMITH&#x27;, &#x27;1980-12-17&#x27;, 800, 20),(&#x27;7934&#x27;, &#x27;MILLER&#x27;, &#x27;1982-1-23&#x27;, 1300, 10),(&#x27;7844&#x27;, &#x27;TURNER&#x27;, &#x27;1981-9-8&#x27;, 1500, 30),(&#x27;7782&#x27;, &#x27;CLARK&#x27;, &#x27;1981-6-9&#x27;, 2450, 10),(&#x27;7839&#x27;, &#x27;KING&#x27;, &#x27;1981-11-17&#x27;, 5000, 10),(&#x27;7902&#x27;, &#x27;FORD&#x27;, &#x27;1981-12-3&#x27;, 3000, 20),(&#x27;7499&#x27;, &#x27;ALLEN&#x27;, &#x27;1981-2-20&#x27;, 1600, 30),(&#x27;7654&#x27;, &#x27;MARTIN&#x27;, &#x27;1981-9-28&#x27;, 1250, 30),(&#x27;7900&#x27;, &#x27;JAMES&#x27;, &#x27;1981-12-3&#x27;, 950, 30),(&#x27;7788&#x27;, &#x27;SCOTT&#x27;, &#x27;1987-7-13&#x27;, 3000, 20),(&#x27;7698&#x27;, &#x27;BLAKE&#x27;, &#x27;1981-5-1&#x27;, 2850, 30);select * from emp;--求出每个部门工资最高的前三名员工，并计算这些员工的工资占所属部门总工资的百分比。select a.empno, a.sal, a.deptno, a.rn, a.sum_sal, round(a.sal/a.sum_sal,2) as ratefrom(select *,--每个部门工资排名 row_number() over (partition by deptno order by sal desc) as rn, --每个部门的总工资 sum(sal) over(partition by deptno ) as sum_sal from emp) awhere rn&lt;=3; 小米电商订单表，torder. 字段，user_id, order_id, c_date，city_id，sale_num，sku_id (商品) 问题：20201201至今每日订单量top3的城市及其订单量(订单量对order_id去重)(在线写) 1234567891011121314151617181920212223242526272829303132333435363738394041drop table if exists t_order;create table t_order (user_id string, order_id string, c_date string, city_id string, sale_num int , sku_id string) ;insert overwrite table t_order values(&#x27;zs&#x27;,&#x27;001&#x27;,&#x27;2020-12-01&#x27;,&#x27;杭州&#x27;,2,&#x27;鞋子&#x27;),(&#x27;ls&#x27;,&#x27;002&#x27;,&#x27;2020-12-01&#x27;,&#x27;杭州&#x27;,1,&#x27;衣服&#x27;),(&#x27;ww&#x27;,&#x27;003&#x27;,&#x27;2020-12-01&#x27;,&#x27;杭州&#x27;,1,&#x27;小米12&#x27;),(&#x27;zl&#x27;,&#x27;004&#x27;,&#x27;2020-12-01&#x27;,&#x27;杭州&#x27;,1,&#x27;小米11&#x27;),(&#x27;zs&#x27;,&#x27;005&#x27;,&#x27;2020-12-01&#x27;,&#x27;上海&#x27;,2,&#x27;鞋子&#x27;),(&#x27;zs&#x27;,&#x27;005&#x27;,&#x27;2020-12-01&#x27;,&#x27;上海&#x27;,2,&#x27;裤子&#x27;),(&#x27;ls&#x27;,&#x27;006&#x27;,&#x27;2020-12-01&#x27;,&#x27;上海&#x27;,1,&#x27;衣服&#x27;),(&#x27;ww&#x27;,&#x27;007&#x27;,&#x27;2020-12-01&#x27;,&#x27;上海&#x27;,1,&#x27;小米12&#x27;),(&#x27;zs&#x27;,&#x27;008&#x27;,&#x27;2020-12-01&#x27;,&#x27;武汉&#x27;,2,&#x27;鞋子&#x27;),(&#x27;ls&#x27;,&#x27;009&#x27;,&#x27;2020-12-01&#x27;,&#x27;武汉&#x27;,1,&#x27;衣服&#x27;),(&#x27;zs&#x27;,&#x27;010&#x27;,&#x27;2020-12-01&#x27;,&#x27;长沙&#x27;,2,&#x27;鞋子&#x27;),(&#x27;zs&#x27;,&#x27;011&#x27;,&#x27;2020-12-02&#x27;,&#x27;上海&#x27;,2,&#x27;鞋子&#x27;),(&#x27;ls&#x27;,&#x27;012&#x27;,&#x27;2020-12-02&#x27;,&#x27;上海&#x27;,1,&#x27;衣服&#x27;),(&#x27;ww&#x27;,&#x27;013&#x27;,&#x27;2020-12-02&#x27;,&#x27;上海&#x27;,1,&#x27;小米12&#x27;),(&#x27;zl&#x27;,&#x27;014&#x27;,&#x27;2020-12-02&#x27;,&#x27;上海&#x27;,1,&#x27;小米11&#x27;),(&#x27;zs&#x27;,&#x27;015&#x27;,&#x27;2020-12-02&#x27;,&#x27;广州&#x27;,2,&#x27;鞋子&#x27;),(&#x27;ls&#x27;,&#x27;016&#x27;,&#x27;2020-12-02&#x27;,&#x27;广州&#x27;,1,&#x27;衣服&#x27;),(&#x27;ww&#x27;,&#x27;017&#x27;,&#x27;2020-12-02&#x27;,&#x27;广州&#x27;,1,&#x27;小米12&#x27;),(&#x27;zs&#x27;,&#x27;018&#x27;,&#x27;2020-12-02&#x27;,&#x27;武汉&#x27;,2,&#x27;鞋子&#x27;),(&#x27;ls&#x27;,&#x27;019&#x27;,&#x27;2020-12-02&#x27;,&#x27;武汉&#x27;,1,&#x27;衣服&#x27;);select *from t_order;with t1 as (select c_date, city_id, count(distinct order_id) cnt from t_order where c_date &gt;= &#x27;2020-12-01&#x27; and c_date &lt;= `current_date`() group by c_date, city_id), t2 as (select *, row_number() over (partition by c_date order by cnt desc) rn from t1)select c_date, city_id, cnt,rnfrom t2where rn &lt;= 3; 带条件的聚合统计 一般的做法是group by xx,yy 再多次的sum(if(……)) 好处是避免多次加载表，可以只加载一次表就得到多个指标。 每个客户的移动数、固话数和宽带数 腾讯数据提取用户行为表：t_user_video_action_d分区：ds（格式 yyyyMMdd） 主键：user_id、video_id 含义：一个 user 对一个视频的所有行为聚合，每天增量字段： 字段名 字段含义 类型 user_id 用户 id string video_id 视频 id string expose_cnt 曝光次数 int like_cnt 点赞次数 int 视频表：t_video_d 分区：ds（格式 yyyyMMdd）主键：video_id 含义：当天全量视频数据字段： 字段名 字段含义 类型 枚举 video_id 视频 id string video_type 视频类型 string 娱乐、新闻、搞笑 video_user_id 视频创建者 user_id string video_create_time 视频创建时间 bigint ​ 作者表：t_video_user_d 分区：ds（格式 yyyyMMdd）主键：video_user_id 含义：当天全量视频创建者数据 字段名 字段含义 类型 枚举 video_user_id 视频创建者 user_id string video_user_name 名称 string video_user_type 视频创建者类型 string 娱乐、新闻、搞笑 需求方需要视频号搞笑类型视频的曝光点赞时长等数据，请提供一张 ads 表。搞笑类型视频定义：视频类型为搞笑或者视频创建者类型为搞笑 需要产出字段：视频 id，视频创建者 user_id，视频创建者名称、当天曝光次数、当天点赞次数、近 30 天曝光次数、近 30 天点赞次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445 create table if not exists t_user_video_action_d( user_id string comment &quot;用户id&quot;, video_id string comment &quot;视频id&quot;, expose_cnt int comment &quot;曝光次数&quot;, like_cnt int comment &quot;点赞次数&quot;) partitioned by (ds string);drop table t_video_d;create table if not exists t_video_d( video_id string comment &#x27;视频id&#x27;, video_type string comment &#x27;视频类型&#x27;, video_user_id string comment &#x27;视频创建者user_id&#x27;, video_create_time bigint comment &#x27;视频创建时间&#x27;) partitioned by (ds string);create table if not exists t_video_user_d( video_user_id string comment &#x27;视频创建者user_id&#x27;, video_user_name string comment &#x27;名称&#x27;, video_user_type string comment &#x27;视频创建者类型&#x27;) partitioned by (ds string);--假设当天是2022-07-31select t1.*, t2.video_user_id, t2.video_user_namefrom (select video_id, sum(case when ds = &#x27;2022-07-30&#x27; then expose_cnt else 0 end),--当天曝光次数、 sum(case when ds = &#x27;2022-07-30&#x27; then like_cnt else 0 end),-- 当天点赞次数、 sum(expose_cnt) as sum_expose,-- 近 30 天曝光次数、 sum(like_cnt)-- 近 30 天点赞次数 from t_user_video_action_d where ds between &#x27;2022-07-01&#x27; and &#x27;2022-07-30&#x27; group by video_id) as t1join (select d.video_id, d.video_user_id, u.video_user_name from t_video_d d join t_video_user_d u on d.video_user_id = u.video_user_id where (d.video_type like &#x27;%搞笑%&#x27; or u.video_user_type like &#x27;%搞笑%&#x27;) and d.ds = &#x27;2022-07-30&#x27; and u.ds = &#x27;2022-07-30&#x27;) as t2 on t1.video_id = t2.video_id 小米电商要求：编写SQL能运行，数据正确且符合规范，如遇到自定义函数或不记得的函数可以用XX代替 1.已知有如下两个表表sale：字段如下 123456789Create table sale_order( Order_id bigint comment &#x27;订单ID&#x27;, User_id bigint comment &#x27;用户ID&#x27;, Order_status int, Create_time string, Last_update_time string, Product_id bigint, Product_num bigint ); 用户注册表： 123456Create table user_info( user_id bigint comment&#x27;用户ID，唯一主键&#x27;, sex string. age int); 问题：用一条SQL生成完整的用户画像表，包含如下字段： user_id, sex, age, d7order_num, d14_order_num，后面两个字段分别为近7天订单数量，近14天订单数量。 12345678910111213141516171819202122232425create table sale_order( order_id bigint comment &#x27;订单ID&#x27;, user_id bigint comment &#x27;用户ID&#x27;, order_status int , create_time string, last_update_time string, product_id bigint, product_num bigint);create table user_info( user_id bigint comment &#x27;用户ID,唯一主键&#x27;, sex string, age int);select u.user_id, s.d7order_num, s.d14order_numfrom user_info uleft join (select user_id, count(if(create_time &gt;= &#x27;7天前&#x27; and create_time &lt;= &#x27;今天&#x27;, order_id,null)) as d7order_num, count(if(create_time &gt;= &#x27;14天前&#x27; and create_time &lt;= &#x27;今天&#x27;, order_id,null)) as d14order_num from sale_order where create_time &gt;= &#x27;14天前&#x27; group by user_id) s on u.user_id = s.user_id; 先group by再join字节跳动 各个角色当日消耗元宝的付费免费比例 vivo 用full join计算对局数，订单数 侧视图爆炸类vivo 爆炸函数计算常驻人数top10的城市，男女分布情况","categories":[],"tags":[{"name":"SQL强化1","slug":"SQL强化1","permalink":"http://example.com/tags/SQL%E5%BC%BA%E5%8C%961/"}]},{"title":"Docker部署Springboot项目","slug":"Docker部署Springboot项目","date":"2022-10-07T04:56:24.000Z","updated":"2022-10-07T04:57:17.938Z","comments":true,"path":"2022/10/07/Docker部署Springboot项目/","link":"","permalink":"http://example.com/2022/10/07/Docker%E9%83%A8%E7%BD%B2Springboot%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"就几条命令，一键学会Docker部署SpringBoot项目 MarkerHub 2020年04月27日 23:50 · 阅读 3772 关注 我们的开源博客项目eblog已经更新完毕了。今天，我们使用docker的安装方式，来安装一下我们的项目，实验环境是centos 7系统上，本实验适用部署大部分Springboot项目。 eblog项目地址： github.com&#x2F;MarkerHub&#x2F;e… 安装docker123456789101112131415161718192021#安装yum install docker#检验安装是否成功[root@localhost opt]# docker --versionDocker version 1.13.1, build 7f2769b/1.13.1#启动systemctl start docker#换镜像源sudo vim /etc/docker/daemon.json内容如下：&#123; &quot;registry-mirrors&quot;: [&quot;https://m9r2r2uj.mirror.aliyuncs.com&quot;]&#125;保存退出，重启docker#重启systemctl restart docker复制代码 安装redis首先上dockerHub搜索redis，点击进入详情页之后，拉到下面就可以看到how to use，如果需要选择特定的版本，有Supported tags给我们选择，然后如果拉取最新的版本的话，拉倒下面就教程。 hub.docker.com&#x2F;_&#x2F;redis 1234567#拉取redis的镜像docker pull redis#查看本地redis镜像docker images#运行redisdocker run --name myredis -p 6379:6379 -d redis redis-server --appendonly yes复制代码 docker run表示运行的意思 –name myredis 表示起个名字叫myredis -p 6379:6379表示把服务器的6379映射到docker的6379端口，这样就可以通过服务器的端口访问docker的端口 -d 表示以后台服务形式运行redis redis redis-server –appendonly yes表示开启持久化缓存模式，可以存到硬盘 安装mysql hub.docker.com&#x2F;_&#x2F;mysql MYSQL_ROOT_PASSWORD&#x3D;admin表示root的初始密码 mysql:5.7.27表示操作的是mysql的5.7.27版本，没有后面的版本号的话，默认是拉取最新版本的mysql。 123docker pull mysql:5.7.27docker run --name mymysql -e MYSQL_ROOT_PASSWORD=admin -d -p 3306:3306 mysql:5.7.27 复制代码 连上mysql，创建数据库eblog，然后把数据库脚本导入进去。 脚本位置：github.com&#x2F;MarkerHub&#x2F;e… 安装RabbitMq一行命令搞定，注意RABBITMQ_DEFAULT_PASS&#x3D;password是设置密码的意思哈。 12docker run -d --hostname my-rabbit --name myrabbit -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management复制代码 安装ElasticSearchdocker 安装 Elasticsearch6.4.3版本 及中文插件安装。 系统配置 不配置的话，可能会启动失败 具体报错：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]。 解决： sudo sysctl -w vm.max_map_count&#x3D;262144 启动 ES docker run -p 9200:9200 -p 9300:9300 -d –name es_643 elasticsearch:6.4.3 进入镜像 docker exec -it es_643 &#x2F;bin&#x2F;bash es配置文件位置： &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml 安装中文分词插件 12./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.3/elasticsearch-analysis-ik-6.4.3.zip复制代码 退出并重启镜像 exit docker restart es_643 构建eblog的docker镜像接下来，我们需要先去clone eblog博客项目，对项目进行打包成jar包。 12345clone https://github.com/MarkerHub/eblog.gitcd eblog# 打包mvn clean package -Dmaven.test.skip=true复制代码 然后把项目 eblog-0.0.1-SNAPSHOT.jar 包上传到服务器中 同eblog-0.0.1-SNAPSHOT.jar的目录，创建一个名称为Dockerfile文件。 内容如下： Dockerfile 123456789101112FROM java:8EXPOSE 8080VOLUME /tmpENV TZ=Asia/ShanghaiRUN ln -sf /usr/share/zoneinfo/&#123;TZ&#125; /etc/localtime &amp;&amp; echo &quot;&#123;TZ&#125;&quot; &gt; /etc/timezoneADD eblog-0.0.1-SNAPSHOT.jar /app.jarRUN bash -c &#x27;touch /app.jar&#x27;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]复制代码 FROM java:8 表示基于jdk8环境 EXPOSE 8080 表示对外暴露的端口是8080 VOLUME &#x2F;tmp 表示挂载到&#x2F;tmp目录 ADD eblog-0.0.1-SNAPSHOT.jar &#x2F;app.jar 表示把jar包复制到镜像服务里面的根目录，并改名称app.jar RUN bash -c ‘touch &#x2F;app.jar’ 表示执行创建app.jar ENTRYPOINT [“java”,”-jar”,”&#x2F;app.jar”] 表示执行启动命令java -jar 接下来，我们安装Dockrfile的命令，把eblog-0.0.1-SNAPSHOT.jar构建成docker的镜像。 12345#构建镜像，注意后面有个点哈。docker build -t eblog .#查看镜像docker images复制代码 这步骤完成之后，我们就可以在准备工作就已经完成啦，接下来，我们就直接启动我们的项目哈。 启动eblog项目启动命令如下： 12docker run -p 8080:8080 -p 9326:9326 --name eblog --link es_643:ees --link myrabbit:erabbit --link mymysql:emysql --link myredis:eredis -d eblog复制代码 -p 8080:8080 -p 9326:9326 ：9326是因为即时聊天需要用到的ws端口 –link es:ees 表示关联容器，把容器es起别名为ees 查看eblog打印日志 12docker logs -f eblog复制代码 这时候我们查看就可以通过8080端口访问我们的项目了！！！ 到此项目运行成功！！ 总结使用docker compose编排形式会更简单！ 视频演示链接：www.bilibili.com/video/BV1dk…","categories":[],"tags":[{"name":"Docker部署SpringBoot项目","slug":"Docker部署SpringBoot项目","permalink":"http://example.com/tags/Docker%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/"}]},{"title":"VueAdmin部署","slug":"VueAdmin部署","date":"2022-10-07T04:43:30.000Z","updated":"2022-10-07T04:44:00.857Z","comments":true,"path":"2022/10/07/VueAdmin部署/","link":"","permalink":"http://example.com/2022/10/07/VueAdmin%E9%83%A8%E7%BD%B2/","excerpt":"","text":"手把手教你Docker+nginx部署Springboot+vue前后端分离项目上线前准备这里我们同步演示怎么部署到win环境和linux（centos7）系统中，前端服务器采用nginx部署，并使用docker统一管理前后端服务器。 所以我们会用到： nginx docker compose 希望你看视频前有点基础哈，当然了，这次部署比较简单，不需要很精通，一般看了我的视频应该都能部署成功的哈。 话不多说，直接上手！别忘了给我一个一键三联哈，顺便关注我B站，感谢！ 1、win环境win环境我就用本机来演示了，我们需要分别打包前后端，前后端打包都是一条命令即可，只不过我们打包之前注意需要配置好线上的环境参数等。 1.1、前端先来配置一下后端的调用路径，因为现在部署在本地localhost，所以在axios.js中，我们配置好链接，因为等下后端部署也是本机，所以我这里直接这样配置就好了，如下： src\\axios.js 1axios.defaults.baseURL = &quot;http://localhost:8081&quot; 上面配置的就是前端访问后端接口的服务。然后前端部署还需要考虑一个问题：打包之后项目资源引用路径，比如我们打包后链接是否需要带项目名称等。按照Vue官方的部署说明，我们添加一个vue.config.js文件， vueblog-vue&#x2F;vue.config.js 123module.exports = &#123;publicPath: &#x27;/&#x27;&#125; 当然了，publicPath默认其实是空的，也就是publicPath: ‘’，两个效果貌似其实是一样的，哈哈哈，我只是提醒一下有这回事而已，嘿嘿。设置完毕之后，我们执行打包命令： 12# 打包命令npm run build 命令执行之后，我们在项目根目录下就可以找到一个dist的目录，这个就是打包之后的文件夹，里面有个index.html，但是我们点击直接打开是看不到任何内容的，这时候，我们需要部署到nginx中。 首先我们下载一个nginx，下载地址：http://nginx.org/en/download.html，这里我们下载nginx/Windows-1.18.0版本，下载之后解压zip。根据我们对nginx的熟悉，静态文件我们放在html文件夹下面，所以先把html文件夹中的index.html和50x.html删掉，然后把打包出来的dist文件夹内的所有文件都复制到nginx的html中，如图： 双击nginx.exe启动nginx，然后浏览器输入http://localhost，出现了我们熟悉的界面，虽然没有博客数据，链接也自动跳转到了http://localhost/blogs， 我们点击任意一个链接或者按钮或者刷新界面，这时候出现了404： 刷新之后nginx就找不到路由了，这是为啥，得和你们科普一下，vue项目的入口是index.html文件，nginx路由的时候都必须要先经过这个文件，所以我们得给nginx定义一下规则，让它匹配不到资源路径的时候，先去读取index.html，然后再路由。所以我们配置一下nginx.conf文件。具体操作就是找到location &#x2F;,添加上一行代码try_files $uri $uri&#x2F; &#x2F;index.html last;如下： nginx-1.18.0&#x2F;conf&#x2F;nginx.conf 12345location / &#123; root html; try_files $uri $uri/ /index.html last; index index.html index.htm;&#125; 这一行代码是什么意思呢？ try_files的语法规则： 格式1：try_files file … uri，表示按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理，last表示匹配不到就内部直接匹配最后一个。 重启nginx之后，链接再刷新都正常啦。但是没有数据，所以我们去部署一下后端。windows环境nginx的重启我一般都是打开任务管理器直接干掉nginx进程，然后再重新双击的~~ 1.2、后端后端的打包就简单多了，应该大家都挺熟悉的，注意配置redis、mysql的链接密码啥的，然后执行命令，本机测试，redis和mysql我都已经提前安装好的了，sql文件也在vueblog-java的resources目录下。 对了，pom.xml文件里面，spring-boot-maven-plugin之前注释掉了，现在一定要打开。不然执行jar会找不到主类。 pom.xml 执行打包命令： 12# 跳过测试打包mvn clean package -Dmaven.test.skip=true 得到target下的vueblog-0.0.1-SNAPSHOT.jar，然后再执行命令 1java -jar vueblog-0.0.1-SNAPSHOT.jar --spring.profiles.active=default 后端上线之后，我们再访问下前端，发现已经可以正常浏览网页啦！spring.profiles.active表示指定环境配置文件。 2、linux环境linux环境部署相对复杂一点，因为我们还要部署redis、mysql等。之前我发布过一个视频，是部署传统的博客项目eblog，采用的是docker容器，但是我们没有docker compose进行编排，这次我们使用docker compose来编排我们的服务，一起性搞定部署。 二话不说，我们先来安装一下docker和docker compose，对于docker知识还不是特别懂的同学，建议自行去补习补习哈。 2.1、安装docker1234567#安装yum install docker#检验安装是否成功[root@localhost opt]# docker --versionDocker version 1.13.1, build 7f2769b/1.13.1#启动systemctl start docker 2.2、安装docker compose可以参考：https://docs.docker.com/compose/install/ 12345sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose#sudo chmod +x /usr/local/bin/docker-compose# 检查是否安装成功docker-compose --version 2.3、编写Dockerfile文件因为我们的项目需要成为docker的镜像，所以我们必须先编写Dockerfile文件构建我们的项目镜像然后进行编排，Dockerfile文件可以帮我们进行构建。 Dockerfile 12345FROM java:8EXPOSE 8080ADD vueblog-0.0.1-SNAPSHOT.jar app.jarRUN bash -c &#x27;touch /app.jar&#x27;ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;, &quot;--spring.profiles.active=pro&quot;] 上面几行命令其实很简单，首先依赖jdk8环境，对外暴露8080，然后就是复制vueblog-0.0.1-SNAPSHOT.jar到docker容器中并命名为app.jar，最后是执行命令 java -jar &#x2F;app.jar —spring.profiles.active&#x3D;pro ，使用的是我们另外编写的一个线上环境配置。 application-pro.yml 1234567891011# DataSource Configspring:datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc//localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: adminshiro-redis:enabled: trueredis-manager: host: 127.0.0.1:6379 等会儿我们需要修改application-pro.yml的redis和mysql链接等信息的一些配置，需要注意。 2.4、编写docker-compose.yml文件我们需要用到的软件与服务分别有nginx、mysql、redis、还有我们的springboot项目，所以编写如下： docker-compose.yml 1234567891011121314151617181920212223242526version: &quot;3&quot;services:nginx: # 服务名称，用户自定义 image: nginx:latest # 镜像版本 ports: - 80:80 # 暴露端口 volumes: # 挂载 - /root/nginx/html:/usr/share/nginx/html - /root/nginx/nginx.conf:/etc/nginx/nginx.conf privileged: true # 这个必须要，解决nginx的文件调用的权限问题mysql: image: mysql:5.7.27 ports: - 3306:3306 environment: # 指定用户root的密码 - MYSQL_ROOT_PASSWORD=adminredis: image: redis:latestvueblog: image: vueblog:latest build: . # 表示以当前目录下的Dockerfile开始构建镜像 ports: - 8081:8081 depends_on: # 依赖与mysql、redis，其实可以不填，默认已经表示可以 - mysql - redis 上面的意思，我都用注释解释一遍了，希望可以讲清楚！需要注意的是，nginx中我们对nginx的放置静态资源的html文件夹和配置文件nginx.conf进行了一个挂载，所以我们打包后的文件放置到宿主机 &#x2F;root&#x2F;nginx&#x2F;html 文件目录就行了哈 2.5、修改application-pro.yml 然后我们再回头看看application-pro.yml文件，mysql和redis的链接之前还是localhost，现在我们需要修改成容器之间的调用，如何知道mysql和redis的链接地址呢？docker compose就帮我们解决了这个问题，我们可以使用镜像容器的服务名称来表示链接。比如docker-compose.yml中mysql的服务名称就叫mysql、redis就叫redis。 所以我们最终得到的配置文件如下： 2.6、准备好nginx的挂载目录和配置docker-compose.yml中已经提到， 宿主机的挂载目录：&#x2F;root&#x2F;nginx&#x2F;html 挂载配置：&#x2F;root&#x2F;nginx&#x2F;nginx.conf 所以我们在root目录下新建nginx目录，并进入nginx目录下新建html目录和一个nginx.conf配置文件。 然后对nginx.conf进行编写，具体配置如下： nginx.conf 123456789101112131415161718192021222324#user root;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; try_files $uri $uri/ /index.html last; # 别忘了这个哈 index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 2.7、上传前端 前端打包之后先修改前端调用后端的接口，因为我是虚拟机，所以配置如下： axios.js 1axios.defaults.baseURL = &quot;http://192.168.0.117:8081&quot; 然后 npm run build 打包得到 dist 文件夹，并把dist压缩成dist.zip上传到linux之后解压到 &#x2F;root&#x2F;nginx&#x2F;html 目录下。如下图： 2.8、部署后端一切准备就绪之后，我们就开始编排部署了哈。 首先本地打包vueblog项目，vueblog-0.0.1-SNAPSHOT.jar，并上传到linux中，同时docker-compose.yml、Dockerfile也上传到同一目录下。如图所示： 然后我们执行一下编排命令: 123# 开始编排cd ~docker-compose up -d 其中-d表示后台服务形式启动 然后我们稍等片刻，特别是开始Building vueblog的时候可能时间有点长，耐心等待即可！ 最后提示如下： 说明我们已经成功编排啦。 nginx是80端口，所以我们直接输入ip地址，如下可以看到一个界面然后有弹窗： 这个简单，是因为我们的数据库还没创建哈。接下来我们去手动创建一下数据库并导入sql文件。 vueblog-java&#x2F;src&#x2F;main&#x2F;resources&#x2F;vueblog.sql 然后再刷新一下浏览器链接，数据就出来啦，搞定，轻松！","categories":[],"tags":[{"name":"VueAdmin部署","slug":"VueAdmin部署","permalink":"http://example.com/tags/VueAdmin%E9%83%A8%E7%BD%B2/"}]},{"title":"VueAdmin前端","slug":"VueAdmin前端","date":"2022-10-07T04:42:05.000Z","updated":"2022-10-07T04:42:58.690Z","comments":true,"path":"2022/10/07/VueAdmin前端/","link":"","permalink":"http://example.com/2022/10/07/VueAdmin%E5%89%8D%E7%AB%AF/","excerpt":"","text":"开发SpringBoot+Jwt+Vue的前后端分离后台管理系统VueAdmin - 前端笔记社长 1年前 ⋅ 54017 阅读 一个spring security + jwt + vue的前后端分离项目！综合运用！ 关注公众号 MarkerHub，回复【 VueAdmin 】可以加群讨论学习、另外还会不定时安排B站视频直播答疑！ 首发公众号：MarkerHub 作者：吕一明 视频讲解：https://www.bilibili.com/video/BV1af4y1s7Wh/ 线上演示：https://www.markerhub.com/vueadmin/ 转载请保留此应用，万分感谢！ 1. 前言在之前，我写了一个前后端分离的简易博客系统vueblog，在B站也已经收获了13万的播放量了，也还算受欢迎吧，感谢大家的认同与支持！同时有些刚入门的同学还是说有些地方不清楚，跟着做的时候还是会出现错误，或者不理解为啥这样处理，这次我更详细点。 而接下来，我们即将开发一个前后端分离的后台管理系统VueAdmin。这个管理系统与我们之前的博客系统技术选型上其实有很多相似之处，只不过权限框架我选用了spring security，然后相对来说权限模块开发就多点代码，也仅此而已了。对了前端的系统界面也是我们一步步开发的，所以希望能帮助大家熟悉一个后台管理系统，也希望大家学到东西哈。 我的公众号MarkerHub，希望大家能关注支持我哈！ 2. 安装vue环境，并新建Vue项目前端我们依然选择的是Vue+ElementUI的组合，主要还是因为这个主流呀。针对Vue，如果还不熟悉的同学，建议去看看这个视频【4个小时带你快速入门vue】，我也是学这个视频入门的，就学了半天，哈哈。主要Js基础扎实点学起来挺快的。 首先我们安装vue的环境，我实践的环境是windows 10哈。 1、首先我们上node.js官网(https://nodejs.org/zh-cn/)，下载最新的长期版本，直接运行安装完成之后，我们就已经具备了node和npm的环境啦。 安装完成之后检查下版本信息： 这就表示你已经安装成功啦，牛逼开始的第一步！ 2、接下来，我们安装vue的环境 123456# 安装淘宝npmnpm install -g cnpm --registry=https://registry.npm.taobao.org# vue-cli 安装依赖包cnpm install --g vue-cli# 打开vue的可视化管理工具界面vue ui 上面我们分别安装了淘宝npm，cnpm是为了提高我们安装依赖的速度。vue ui是@vue&#x2F;cli3.0增加一个可视化项目管理工具，可以运行项目、打包项目，检查等操作。对于初学者来说，可以少记一些命令，哈哈。3、创建vueadmin-vue项目 运行vue ui之后， 会为我们打开一个http://localhost:8080 的页面： 我们将在这个页面完成我们的前端Vue项目的新建。然后切换到【创建】，注意创建的目录最好是和你运行vue ui同一级。这样方便管理和切换。 然后点击按钮【在此创建新项目】下一步中，项目文件夹中输入项目名称“vueblog-vue”，其他不用改。 点击下一步，选择【手动】，再点击下一步，如图点击按钮，勾选上路由Router、状态管理Vuex，去掉js的校验。 下一步中，也选上【Use history mode for router】，点击创建项目，然后弹窗中选择按钮【创建项目，不保存预设】，就进入项目创建啦。 稍等片刻之后，项目就初始化完成了。上面的步骤中，我们创建了一个vue项目，并且安装了Router、Vuex。这样我们后面就可以直接使用。 Router： WebApp的链接路径管理系统，简单就是建立起url和页面之间的映射关系 Vuex： 一个专为 Vue.js 应用程序开发的状态管理模式，简单来说就是为了方便数据的操作而建立的一个临时” 前端数据库“，用于各个组件间共享和检测数据变化。 ok，我们使用IDEA导入项目，看看创建好的项目长啥样子： 当然了，IDEA我们要预先先安装好一个Vue插件，这样我们就可以使用IDEA像WebStorm一样开发Vue项目啦，毕竟都是同一个家族出品的哈哈。 然后我们在IDEA窗口的底部打开Terminal命令行窗口，输入npm run serve运行vue项目，我们就可以通过http://localhost:8080/打开我们的项目了。 效果如下，Hello Vue！ 线上演示：https://www.markerhub.com/vueadmin/ 3. 安装element-ui接下来我们引入element-ui组件（https://element.eleme.cn），这样我们就可以获得好看的vue组件，开发好看的后台管理系统的界面啦。 命令很简单： 12345# 切换到项目根目录cd vueadmin-vue# 或者直接在idea中执行下面命令# 安装element-uicnpm install element-ui --save 然后我们打开项目src目录下的main.js，引入element-ui依赖。 123import Element from &#x27;element-ui&#x27;import &quot;element-ui/lib/theme-chalk/index.css&quot;Vue.use(Element) 这样我们就可以愉快得在官网上选择组件复制代码到我们项目中直接使用啦。 4. 安装axios、qs、mockjs axios：一个基于 promise 的 HTTP 库，类ajax qs：查询参数序列化和解析库 mockjs：为我们生成随机数据的工具库 接下来，我们来安装axios（http://www.axios-js.com/），axios是一个基于 promise 的 HTTP 库，这样我们进行前后端对接的时候，使用这个工具可以提高我们的开发效率。 安装命令： 1cnpm install axios --save 然后同样我们在main.js中全局引入axios。 12import axios from &#x27;axios&#x27;Vue.prototype.$axios = axios // 组件中，我们就可以通过this.$axios.get()来发起我们的请求了哈。当然了，后面我们添加axios拦截的时候我们需要修改引入的编写。同时，我们同步安装一个qs，什么是qs？qs是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object,帮助我们查询字符串解析和序列化字符串。 1cnpm install qs --save 然后因为后台我们现在还没有搭建，无法与前端完成数据交互，因此我们这里需要mock数据，因此我们引入mockjs（http://mockjs.com/），方便后续我们提供api返回数据。 1cnpm install mockjs --save-dev 然后我们在src目录下新建mock.js文件，用于编写随机数据的api，然后我们需要在main.js中引入这个文件： src&#x2F;main.js 1require(&quot;./mock&quot;) //引入mock数据，关闭则注释该行 后面我们mackjs会自动为我们拦截ajax，并自动匹配路径返回数据！ 5. 页面路由 接下来，在开发页面之前我们需要先定义路由。传统项目开发，我们都是通过链接到达控制器然后再到页面渲染的。而类似于Vue这样的前后端分离性质的框架，我们是先访问页面，然后再异步加载数据渲染。而在Vue中，路由的管理是有个专门的组件叫Router管理的。 我们在新建项目的时候也提了一下，大家还记得吧。我们当时说： Router：WebApp的链接路径管理系统，简单就是建立起url和页面之间的映射关系 所以我们要打开页面然后开发页面，我们需要先配置路由，然后再开发，这样我们可以试试看到效果。项目中，src\\router\\index.js就是用来配置路由的。 我们在views文件夹下定义几个页面： Login.vue（登录页面） Index.vue（首页） 我们新建Vue页面的时候可以这样新建： 然后再路由中心配置配置url与vue页面的映射关系，参考原本的默认写法，我们很容易写出以下代码： src\\router\\index.js 12345678910111213141516171819202122import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Login from &quot;../views/Login&quot;;Vue.use(VueRouter)const routes = [&#123; path: &#x27;/index&#x27;, name: &#x27;Index&#x27;, component: () =&gt; import(&#x27;../views/Index.vue&#x27;)&#125;,&#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login&#125;]const router = new VueRouter(&#123;mode: &#x27;history&#x27;,base: process.env.BASE_URL,routes&#125;)export default router 得到效果如下： 通过npm run serve运行项目，打开http://localhost:8080/login发现页面长这样，明显我们新建的Login.vue里面是没有内容的，但这里有个Home|About，明显是被其他地方嵌套过来的，这是啥原因呢？ 这里解释一下，我们新建的Vue项目，如果没其他配置，那么默认的就是一个单页面应用，也就是说这个应用是由一个外壳页面和多个页面片段组成的，页面跳转的时候其实始终都没有离开外壳页面，替换的只是加载的页面片段而已。 那么对应到我们的vueadmin项目，外壳页面就是App.vue，片段页面就是Login.vue，所以我们刚刚通过&#x2F;login链接看到的页面效果就是App.vue+Login.vue的结果。所以我们进入App.vue页面看看： src&#x2F;App.vue 果然我们在template标签中找到了相关的html，我们把id为nav的这个div直接删除不要了。这个在这里就是现实我们链接到的片段页面，也就是Login.vue。所以这样就清晰了，我们输入url的时候会调整到App.vue，然后路由会匹配到我们对应的vue页面，这样完成的页面就渲染出来了。 然后我们再调整一下全局的样式，具体代码如下： src&#x2F;App.vue 1234567891011121314&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; html, body, #app &#123; font-family: &#x27;Helvetica Neue&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;Microsoft Yahei&#x27;, sans-serif; height: 100%; padding: 0; margin: 0; font-size: 15px; &#125;&lt;/style&gt; 6. 登陆界面开发ok，万事具备，接下来我们来开发我们第一个页面Login.vue（http://localhost:8080/login），目前页面是完全空白的。一般登录页面就一个简单的表单：用户名、登录密码和验证码。然后我还想在表单左边添加一个图片，是我自己的公众号的二维码，然后中间用一条竖线分开。 一开始的时候为了页面风格的统一，我们采用了Element Ui的组件库，所以这里我们就直接去element的官网。上面描述中我们需要左右分开显示，所以先找到Loyout布局然后再弄表单，然后我们涉及到的后台交互有2个： 获取登录验证码 提交登录表单完成登录 因为后台系统我们暂时还没有开发，所以这里我们需要自己mock数据完成交互。前面我们已经引入了mockjs，所以我们到mock.js文件中开发我们的api。 登录交互过程我们梳理一下交互流程： 浏览器打开登录页面 动态加载登录验证码，因为这是前后端分离的项目，我们不再使用session进行交互，所以后端我打算禁用session，那么验证码的验证就是问题了，所以后端设计上我打算生成验证码同时生成一个随机码，随机码作为key，验证码为value保存到redis中，然后把随机码和验证码图片的Base64字符串码发送到前端 前端提交用户名、密码、验证码还有随机码 后台验证验证码是否匹配以及密码是否正确 ok，这样我们就知道mock应该弄成什么样的api了。 mock.js - 获取登录验证码 12345678910111213141516171819202122232425// 引入mockjsconst Mock = require(&#x27;mockjs&#x27;)// 获取 mock.Random 对象// 参考：https://github.com/nuysoft/Mock/wiki/Mock.Randomconst Random = Mock.Randomlet Result = &#123; code: 200, msg: &#x27;操作成功&#x27;, data: null&#125;/** * Mock.mock( url, post/get , function(options))； * url 表示需要拦截的 URL， * post/get 需要拦截的 Ajax 请求类型 * * 用于生成响应数据的函数 */// 获取验证码图片base64编码以及一个随机码Mock.mock(&#x27;/captcha&#x27;, &#x27;get&#x27;, () =&gt; &#123; Result.data = &#123; token: Random.string(32), // 获取一个32位的随机字符串, captchaImg: Random.dataImage( &quot;120x40&quot;, &quot;11111&quot; ) //生成验证码为11111的base64图片编码 &#125; return Result&#125;) mock生成数据还算简单，一般都是利用Mock.Random对象来生成一些随机数据，具体的用法可以参考https://github.com/nuysoft/Mock/wiki/Mock.Random。然后Result是为了统一返回结果，因为后台设计的时候，前后端交互，一般都有固定的返回格式，所以就有了Result。 mock.js - 登录接口 123456// 因为mock不认识/login?username=xxx，所以用了正则表达式Mock.mock(RegExp(&#x27;/login*&#x27;), &#x27;post&#x27;, (config) =&gt; &#123; // 这里无法在header添加authorization，直接跳过 console.log(&quot;mock----------------login&quot;) return Result&#125;) Mock我们不需要什么处理，只需要放回的数据符合前端的要求就行哈。这样我们前端就可以继续往后面开发。 然后编写登录页面的js src&#x2F;views&#x2F;Login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;template&gt; &lt;el-row type=&quot;flex&quot; class=&quot;row-bg&quot; justify=&quot;center&quot;&gt; &lt;el-col :xl=&quot;6&quot; :lg=&quot;7&quot;&gt; &lt;div class=&quot;login-form&quot;&gt; &lt;h2&gt;欢迎来到VueAdmin管理系统&lt;/h2&gt; &lt;el-image style=&quot;width: 180px; height: 180px&quot; :src=&quot;require(&#x27;@/assets/markerhub/MarkerHub.jpg&#x27;)&quot; &gt;&lt;/el-image&gt; &lt;p&gt; 公众号 MarkerHub &lt;/p&gt; &lt;p&gt; 扫码二维码，回复【VueAdmin】获取登录密码 &lt;/p&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;1&quot;&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;/el-col&gt; &lt;el-col :xl=&quot;6&quot; :lg=&quot;7&quot;&gt; &lt;el-form label-position=&quot;right&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; :model=&quot;loginForm&quot; ref=&quot;loginForm&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot; style=&quot;width: 380px;&quot;&gt; &lt;el-input v-model=&quot;loginForm.username&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot; style=&quot;width: 380px;&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;验证码&quot; prop=&quot;code&quot; style=&quot;width: 380px;&quot;&gt; &lt;el-input v-model=&quot;loginForm.code&quot; style=&quot;width: 172px; float: left;&quot; maxlength=&quot;5&quot;&gt;&lt;/el-input&gt; &lt;el-image class=&quot;captchaImg&quot; :src=&quot;captchaImg&quot; @click=&quot;getCaptcha&quot;&gt;&lt;/el-image&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;loginForm&#x27;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;getPass&quot;&gt;获取密码&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt; import qs from &#x27;qs&#x27; export default &#123; name: &quot;Login&quot;, data() &#123; return &#123; loginForm: &#123; username: &#x27;admin&#x27;, password: &#x27;markerhub&#x27;, code: &#x27;11111&#x27;, token: &#x27;&#x27;, &#125;, rules: &#123; username: [ &#123;required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27;&#125; ], password: [ &#123;required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27;&#125; ], code: [ &#123;required: true, message: &#x27;请输入验证码&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123;min: 5, max: 5, message: &#x27;验证码为5个字符&#x27;, trigger: &#x27;blur&#x27;&#125; ], &#125;, captchaImg: &#x27;&#x27; &#125; &#125;, methods: &#123; submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$axios.post(&#x27;/login?&#x27; + qs.stringify(this.loginForm)).then(res =&gt; &#123; console.log(res.data) const jwt = res.headers[&#x27;authorization&#x27;] // 将jwt存储到应用store中 this.$store.commit(&quot;SET_TOKEN&quot;, jwt) this.$router.push(&quot;/index&quot;) &#125;).catch(error =&gt; &#123; this.getCaptcha(); console.log(&#x27;error submit!!&#x27;); &#125;) &#125; else &#123; this.getCaptcha(); console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125;, getPass() &#123; this.$message(&quot;请扫描左边的二维码，回复【VueAdmin】获取登录密码&quot;); &#125;, getCaptcha() &#123; this.$axios.get(&#x27;/captcha&#x27;).then(res =&gt; &#123; this.loginForm.token = res.data.data.token this.captchaImg = res.data.data.captchaImg &#125;) &#125; &#125;, created() &#123; this.getCaptcha() &#125; &#125;&lt;style scoped&gt; .el-col &#123; display: flex; justify-content: center; align-items: center; height: 100%; text-align: center; &#125; .el-row &#123; height: 100%; background-color: #fafafa; &#125; .el-divider &#123; height: 200px; &#125; .captchaImg &#123; float: left; margin-left: 8px; border-radius: 4px; &#125;&lt;/style&gt; 配合一点样式的调整，这样登录界面我们就开发完毕啦，如果觉得不清楚，可以去看开发视频哈，一步一步的教学，写文字毕竟讲述还是不够仔细的。 token的状态同步再讲一下，submitForm方法中，提交表单之后做了几个动作，从Header中获取用户的authorization，也就是含有用户登录信息的jwt，然后提交到store中进行状态管理。this.$store.commit(“SET_TOKEN”, jwt)表示调用store中的SET_TOKEN方法，所以我们需要在store中编写方法： src&#x2F;store&#x2F;index.js 12345678910111213export default new Vuex.Store(&#123; state: &#123; token: &#x27;&#x27; &#125;, mutations: &#123; SET_TOKEN: (state, token) =&gt; &#123; state.token = token localStorage.setItem(&quot;token&quot;, token) &#125; &#125;, modules: &#123; &#125;&#125;) 这样登录之后获取到的jwt就可以存储到应用的store以及localStorage中，方便使用直接从localStorage中获取即可！这样用户登录成功之后就会跳转到&#x2F;index页面this.$router.push(“&#x2F;index”)。 定义全局axios拦截器这里有个问题，那么如果登录失败，我们是需要弹窗显示错误的，比如验证码错误，用户名或密码不正确等。不仅仅是这个登录接口，所有的接口调用都会有这个情况，所以我们想做个拦截器，对返回的结果进行分析，如果是异常就直接弹窗显示错误，这样我们就省得每个接口都写一遍了。 在src目录下创建一个文件axios.js（与main.js同级），定义axios的拦截： src&#x2F;axios.js 1234567891011121314151617181920212223242526272829303132333435363738import axios from &quot;axios&quot;;import Element from &#x27;element-ui&#x27;import router from &quot;./router&quot;;axios.defaults.baseURL = &quot;http://localhost:8081&quot;const request = axios.create(&#123; timeout: 5000, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json; charset=utf-8&#x27; &#125;&#125;)request.interceptors.request.use(config =&gt; &#123; config.headers[&#x27;Authorization&#x27;] = localStorage.getItem(&quot;token&quot;) // 请求头带上token return config&#125;)request.interceptors.response.use(response =&gt; &#123; let res = response.data; console.log(&quot;response&quot;) console.log(res) if (res.code === 200) &#123; return response &#125; else &#123; Element.Message.error(res.msg? res.msg : &#x27;系统异常！&#x27;, &#123;duration: 3 * 1000&#125;) return Promise.reject(response.data.msg) &#125; &#125;, error =&gt; &#123; console.log(error) if(error.response.data) &#123; error.message = error.response.data.msg &#125; if(error.response.status === 401) &#123; router.push(&quot;/login&quot;) &#125; Element.Message.error(error.message, &#123;duration: 3 * 1000&#125;) return Promise.reject(error) &#125;)export default request 前置拦截，其实可以统一为所有需要权限的请求装配上header的token信息，后置拦截中，判断status.code和error.response.status，如果是401未登录没权限的就调到登录页面，其他的就直接弹窗显示错误。然后再main.js中导入axios.js 12import request from &quot;./axios&quot;;Vue.prototype.$axios = request 同时，记得去掉我们之前添加的 12import axios from &#x27;axios&#x27;Vue.prototype.$axios = axios // 这样axios每次请求都会被前置拦截器和后置拦截器拦截了。登录异常弹窗效果如下： 7. 后台管理界面开发ok，登录界面我们已经开发完毕，并且我们已经能够进入管理系统的首页了，接下来我们就来开发首页的页面。 一般来说，管理系统的页面我们都是头部是一个简单的信息展示系统名称和登录用户信息，然后中间的左边是菜单导航栏，右边是内容，对应到elementui的组件中，我们可以找到这个Container 布局容器用于布局，方便快速搭建页面的基本结构。 而我们采用这个布局： 而这个页面，一般来说Header和Aside都是不会变化的，只有Main部分会跟着链接变化而变化，所以我们可以提炼公共部分出来，放在Home.vue中，然后Main部分放在Index.vue中， 那么问题来了，我们如何才能做到点击左边的Aside，然后局部刷新Main中的内容呢？在Vue中，我们可以通过嵌套路由（子路由）的形式。也就是我们需要重新定义路由，一级路由是Home.vue，Index.vue是作为Home.vue页面的子路由，然后Home.vue中我们通过来展示Index.vue的内容即可。 在router中，我们这样修改： src&#x2F;router&#x2F;index.js 12345678910111213141516171819202122const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home, children: [ &#123; path: &#x27;/index&#x27;, name: &#x27;Index&#x27;, meta: &#123; title: &quot;首页&quot; &#125;, component: () =&gt; import(&#x27;@/views/Index.vue&#x27;) &#125; ] &#125;, &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login &#125;,] 可以看到原本的Index已经作为了Home的children，所以在链接到&#x2F;index的时候我们会展示父级Home的内容，然后再显示Index内容。 src&#x2F;views&#x2F;Home.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;div&gt;菜单栏&lt;/div&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;height: 55px;&quot;&gt; &lt;Strong&gt;ManHub后台管理系统&lt;/Strong&gt; &lt;div class=&quot;header-avatar block&quot;&gt; &lt;el-avatar class=&quot;el-avatar&quot; size=&quot;medium&quot; :src=&quot;userInfo.avatar&quot;&gt;&lt;/el-avatar&gt; &lt;el-dropdown&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; &#123;&#123;userInfo.username&#125;&#125;&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item :underline=&quot;false&quot;&gt; &lt;router-link :to=&quot;&#123;name: &#x27;UserCenter&#x27;&#125;&quot;&gt;个人中心&lt;/router-link&gt; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item @click.native=&quot;logout&quot;&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;el-link href=&quot;https://space.bilibili.com/13491144&quot;&gt;视频讲解&lt;/el-link&gt; &lt;el-link href=&quot;http://markerhub.com&quot;&gt;网站&lt;/el-link&gt; &lt;/div&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;div style=&quot;margin: 0 15px;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt; export default &#123; name: &quot;Home.vue&quot;, data() &#123; return &#123; userInfo: &#123; id: &#x27;-1&#x27;, username: &#x27;admin&#x27;, avatar: &#x27;https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg&#x27; &#125; &#125; &#125;, &#125; 样式部分我就不贴出来了，看git上的代码哈。首页中间内容，不知道放啥，就放我的公众号二维码吧，哈哈，欢迎关注关注！ src&#x2F;views&#x2F;Index.vue 123456789101112&lt;template&gt; &lt;div style=&quot;text-align: center;&quot;&gt; &lt;h2&gt;&lt;/h2&gt; &lt;el-image style=&quot;width: 180px; height: 180px&quot; :src=&quot;require(&#x27;@/assets/markerhub/javacat.jpg&#x27;)&quot; &gt;&lt;/el-image&gt; &lt;p&gt; 更多项目学习，扫描关注公众号！ &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 总体下来效果如下： 有点感觉了，然后昨天的菜单栏我们也弄下，我们找到NavMenu 导航菜单组件，然后加到Home.vue中，因为考虑到后面我们需要做动态菜单，所以我想单独这个页面出来，因此我新建了个SideMenu.vue： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;el-menu class=&quot;el-menu-vertical-demo&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; &gt; &lt;router-link to=&quot;/index&quot;&gt; &lt;el-menu-item index=&quot;Index&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-s-home&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;首页&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-s-operation&quot;&gt;&lt;/i&gt; &lt;span&gt;系统管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-s-custom&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;用户管理&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-rank&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;角色管理&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;菜单管理&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-s-tools&quot;&gt;&lt;/i&gt; &lt;span&gt;系统工具&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-s-order&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;数字字典&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/template&gt; export default &#123; name: &quot;SideMenu&quot;, data() &#123; &#125; &#125;&lt;style scoped&gt; .el-menu-vertical-demo &#123; height: 100%; &#125; a&#123; text-decoration:none; &#125;&lt;/style&gt; SideMenu.vue作为一个组件添加到Home.vue中，我们首选需要导入，然后声明compoents，然后才能使用标签，所以在Home.vue中代码如下： 123456789101112131415161718192021&lt;template&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;SideMenu&gt;&lt;/SideMenu&gt; &lt;/el-aside&gt; &lt;el-container&gt; ... &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt; import SideMenu from &quot;./inc/SideMenu&quot;; export default &#123; name: &quot;Home.vue&quot;, components: &#123; SideMenu &#125;, data() &#123; ... &#125;, &#125; 注意SideMenu出现的地方哈，最后效果如下： 这就很接近我们想要的效果了哈。 我们先来新建几个页面，先在views下新建文件夹sys，然后再新建vue页面，具体看下面，这样我们就能把链接和页面可以连接起来。 src\\views\\sys Dict.vue 数字字典 Menu.vue 菜单管理 Role.vue 角色管理 User.vue 用户管理 虽然建立了页面，但是因为我们没有在router中注册链接与组件的关系，所以我们现在打开链接还是打开不了页面的。下面我们就要动态联系起来。 8. 用户登录信息展示管理界面的右上角的用户信息现在是写死的，因为我们现在已经登录成功，所以我们可以通过接口去请求获取到当前的用户信息了，这样我们就可以动态显示用户的信息，这个接口比较简单，然后退出登录的链接也一起完成，就请求接口同时把浏览器中的缓存删除就退出了哈。 src\\views\\Home.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;el-header style=&quot;height: 55px;&quot;&gt; &lt;Strong&gt;ManHub后台管理系统&lt;/Strong&gt; &lt;div class=&quot;header-avatar block&quot;&gt; &lt;el-avatar class=&quot;el-avatar&quot; size=&quot;medium&quot; :src=&quot;userInfo.avatar&quot;&gt;&lt;/el-avatar&gt; &lt;el-dropdown&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; &#123;&#123;userInfo.username&#125;&#125;&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item :underline=&quot;false&quot;&gt; &lt;router-link :to=&quot;&#123;name: &#x27;UserCenter&#x27;&#125;&quot;&gt;个人中心&lt;/router-link&gt; &lt;/el-dropdown-item&gt; &lt;el-dropdown-item @click.native=&quot;logout&quot;&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;el-link &gt;视频讲解&lt;/el-link&gt; &lt;el-link&gt;公众号&lt;/el-link&gt; &lt;/div&gt;&lt;/el-header&gt;...data() &#123; return &#123; userInfo: &#123; id: &#x27;&#x27;, username: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125;&#125;,created() &#123; this.getUserInfo()&#125;,methods: &#123; getUserInfo() &#123; this.$axios.get(&quot;/sys/userInfo&quot;).then(res =&gt; &#123; this.userInfo = res.data.data; &#125;) &#125;, logout() &#123; this.$axios.post(&quot;/logout&quot;).then(res =&gt; &#123; console.log(res.data.data) localStorage.clear() sessionStorage.clear() this.$store.commit(&quot;resetState&quot;) this.$router.push(&quot;/login&quot;) &#125;) &#125;&#125; 记得mockjs中返回用户的信息，比较简单我就不写了这个。 9. 动态菜单栏开发上面代码中，左侧的菜单栏的数据是写死的，在实际场景中我们不可能这样做，因为菜单是需要根据登录用户的权限动态显示菜单的，也就是用户看到的菜单栏可能是不一样的，这些数据需要去后端访问获取。 首先我们先把写死的数据简化成一个json数组数据，然后for循环展示出来，代码如下： &#x2F;src&#x2F;views&#x2F;inc&#x2F;SideMenu.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;el-menu class=&quot;el-menu-vertical-demo&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; &gt; ... &lt;el-submenu default-active=&quot;Index&quot; :index=&quot;menu.name&quot; v-for=&quot;menu in menuList&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;menu.icon&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;menu.title&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;router-link :to=&quot;item.path&quot; v-for=&quot;item in menu.children&quot;&gt; &lt;el-menu-item :index=&quot;item.name&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/template&gt; export default &#123; name: &quot;SideMenu&quot;, data() &#123; return &#123; menuList: [ &#123; name: &#x27;SysManga&#x27;, title: &#x27;系统管理&#x27;, icon: &#x27;el-icon-s-operation&#x27;, path: &#x27;&#x27;, component: &#x27;&#x27;, children: [ &#123; name: &#x27;SysUser&#x27;, title: &#x27;用户管理&#x27;, icon: &#x27;el-icon-s-custom&#x27;, path: &#x27;/sys/users&#x27;, children: [] &#125; ] &#125;, &#123; name: &#x27;SysTools&#x27;, title: &#x27;系统工具&#x27;, icon: &#x27;el-icon-s-tools&#x27;, path: &#x27;&#x27;, children: [ &#123; name: &#x27;SysDict&#x27;, title: &#x27;数字字典&#x27;, icon: &#x27;el-icon-s-order&#x27;, path: &#x27;/sys/dicts&#x27;, children: [] &#125;, ] &#125; ], &#125; &#125; &#125; 可以看到，我用for循环显示数据，那么这样变动菜单栏时候只需要修改data中的menuList即可。效果和之前的完全一样。现在menuList的数据我们是直接写到页面data上的，一般我们是要请求后端的，所以这里我们定义一个mock接口，因为是动态菜单，一般我们也要考虑到权限问题，所以我们请求数据的时候一般除了动态菜单，还要权限的数据，比如菜单的添加、删除是否有权限，是否能显示该按钮等，有了权限数据我们就定动态决定是否展示这些按钮了。 src&#x2F;mock.js 1234567891011121314151617181920Mock.mock(&#x27;/sys/menu/nav&#x27;, &#x27;get&#x27;, () =&gt; &#123; // 菜单json let nav = [ &#123; name: &#x27;SysManga&#x27;, ... &#125;, &#123; name: &#x27;SysTools&#x27;, ... &#125; ] // 权限数据 let authoritys = [&#x27;SysUser&#x27;, &quot;SysUser:save&quot;] Result.data = &#123;&#125; Result.data.nav = nav Result.data.authoritys = authoritys return Result&#125;) 上面json数据太长，所以我部分用省略号…替代了，以后的代码也会这样哈。这样我们就定义好了导航菜单的接口，什么时候调用呢？应该登录成功完成之后调用，但是并不是每一次打开我们都需要去登录，也就是浏览器已经存储到用户token的时候我们不需要再去登录的了，所以我们不能放在登录完成的方法里。那么是当前这个Home.vue页面吗？看起来没什么问题，方正每次都会进入这个页面，然后搞个开关控制是否重新加载就行？ 我们这里还要考虑一个问题，就是导航菜单的路由问题，啥意思？就是点击菜单之后路由到哪个页面是需要在router中声明的。 这个路由问题我提供两个解决方案： 1、全部写死，也就是提前写好所有的路由，不管用户有没有权限，后面在通过权限数据来判断用户是否有权限访问路由。 2、动态渲染，就是把加载到的导航菜单数据动态绑定路由 这里我们使用第二种解决方案，这类简单点，后续我们再开发页面的时候就不需要去改动路由，可以动态绑定。 综上，我们把加载菜单数据这个动作放在router.js中。Router有个前缀拦截，就是在路由到页面之前我们可以做一些判断或者加载数据。 在router.js中添加一下代码： src&#x2F;router&#x2F;index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960router.beforeEach((to, from, next) =&gt; &#123; let hasRoute = store.state.menus.hasRoute let menus = store.state.menus.menuList let token = localStorage.getItem(&quot;token&quot;) if (to.path == &#x27;/login&#x27;) &#123; console.log(&quot;login!!!!!!!!!!!&quot;) next() &#125; else if (!token) &#123; console.log(&quot;还没有token！！！&quot;) next(&#123;path: &quot;/login&quot;&#125;) &#125;else if (to.path == &#x27;/&#x27; || to.path == &#x27;&#x27;) &#123; next(&#123;path: &quot;/index&quot;&#125;) &#125;else if (!hasRoute) &#123; let newRoutes = router.options.routes; axios.get(&quot;/sys/menu/nav&quot;, &#123;headers:&#123; Authorization: localStorage.getItem(&quot;token&quot;) &#125;&#125;).then(res =&gt; &#123; console.log(res.data.data) store.commit(&quot;setMenuList&quot;, res.data.data.nav) store.commit(&quot;setPermList&quot;, res.data.data.authoritys) res.data.data.nav.forEach(menu =&gt; &#123; if (menu.children) &#123; menu.children.forEach(e =&gt; &#123; let route = menuToRoute(e) if(route) &#123; newRoutes[0].children.push(route) &#125; &#125;) &#125; &#125;) console.log(&quot;oldRoutes---------------&quot;) console.log(newRoutes) router.addRoutes(newRoutes) store.commit(&quot;changeRouteStatus&quot;, true) next(&#123;path: to.path&#125;) &#125;) &#125; else &#123; console.log(&quot;已经有路由了------------&quot;) next() &#125;&#125;)const menuToRoute = (menu) =&gt; &#123; console.log(&quot;正在添加menu--》&quot;) console.log(menu) if (!menu.component) &#123; return null &#125; // 复制属性 let route = &#123; name: menu.name, path: menu.path, meta: &#123; icon: menu.icon, title: menu.title &#125; &#125; route.component = () =&gt; import(&#x27;@/views/&#x27; + menu.component +&#x27;.vue&#x27;) return route&#125;export default router 可以看到，我们通过menuToRoute就是把menu数据转换成路由对象，然后router.addRoutes(newRoutes)动态添加路由对象。同时上面的menu对象中，有个menu.component，这个就是连接对应的组件，我们需要添加上去，比如说&#x2F;sys&#x2F;users链接对应到component(sys&#x2F;User)。这样我们才能绑定添加到路由。所以我会修改mock中的nav的数据成这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let nav = [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;系统管理&quot;, &quot;icon&quot;: &quot;el-icon-s-operation&quot;, &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;sys:manage&quot;, &quot;component&quot;: &quot;&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;用户管理&quot;, &quot;icon&quot;: &quot;el-icon-s-custom&quot;, &quot;path&quot;: &quot;/sys/users&quot;, &quot;name&quot;: &quot;sys:user:list&quot;, &quot;component&quot;: &quot;sys/User&quot;, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;角色管理&quot;, &quot;icon&quot;: &quot;el-icon-rank&quot;, &quot;path&quot;: &quot;/sys/roles&quot;, &quot;name&quot;: &quot;sys:role:list&quot;, &quot;component&quot;: &quot;sys/Role&quot;, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: 4, &quot;title&quot;: &quot;菜单管理&quot;, &quot;icon&quot;: &quot;el-icon-menu&quot;, &quot;path&quot;: &quot;/sys/menus&quot;, &quot;name&quot;: &quot;sys:menu:list&quot;, &quot;component&quot;: &quot;sys/Menu&quot;, &quot;children&quot;: [] &#125; ] &#125;, &#123; &quot;id&quot;: 5, &quot;title&quot;: &quot;系统工具&quot;, &quot;icon&quot;: &quot;el-icon-s-tools&quot;, &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;sys:tools&quot;, &quot;component&quot;: null, &quot;children&quot;: [ &#123; &quot;id&quot;: 6, &quot;title&quot;: &quot;数字字典&quot;, &quot;icon&quot;: &quot;el-icon-s-order&quot;, &quot;path&quot;: &quot;/sys/dicts&quot;, &quot;name&quot;: &quot;sys:dict:list&quot;, &quot;component&quot;: &quot;sys/Dict&quot;, &quot;children&quot;: [] &#125; ] &#125;] 同时上面router中我们还通过判断是否登录页面，是否有token等判断提前判断是否能加载菜单，同时还做了个开关hasRoute来动态判断是否已经加载过菜单。 还需要在store中定义几个方法用于存储数据，我们定义一个menu模块，所以在store中新建文件夹modules，然后新建menus.js src&#x2F;store&#x2F;modules&#x2F;menus.js 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default &#123; state: &#123; // 菜单栏数据 menuList: [], // 权限数据 permList: [], hasRoute: false &#125;, mutations: &#123; changeRouteStatus(state, hasRoute) &#123; state.hasRoute = hasRoute sessionStorage.setItem(&quot;hasRoute&quot;, hasRoute) &#125;, setMenuList(state, menus) &#123; state.menuList = menus &#125;, setPermList(state, authoritys) &#123; state.permList = authoritys &#125; &#125;&#125; 记得在store中import这个模块，然后添加到modules： src&#x2F;store&#x2F;index.js 12345678import menus from &quot;./modules/menus&quot;...export default new Vuex.Store(&#123;...modules: &#123; menus&#125;&#125;) 这样我们菜单的数据就可以加载了，然后再SideMenu.vue中直接获取store中的menuList数据即可显示菜单出来了。 src&#x2F;views&#x2F;inc&#x2F;SideMenu.vue 12345data() &#123; return &#123; menuList: this.$store.state.menus.menuList, &#125;&#125; 最后效果如下： 好了，好像已经有点完善了哈哈。 10. 动态标签页开发上面做完之后，总还觉得少点什么，对了标签页，我看别的后台管理系统都有这个，效果是这样的： 搞起搞起，别人有我不能没有，于是我去element-ui中寻了一圈，发现Tab标签页组件挺符合我们要求的，可以动态增减标签页。 理想的动作是这样的： 当我们点击导航菜单，上方会添加一个对应的标签，注意不能重复添加，发现已存在标签直接切换到这标签即可 删除当前标签的时候会自动切换到前一个标签页 点击标签页的时候会调整到对应的内容页中 综合Vue的思想，我们可以这样设计：在Store中统一存储：1、当前标签Tab，2、已存在的标签Tab列表，然后页面从Store中获取列表显示，并切换到当前Tab即可。删除时候我们循环当前Tab列表，剔除Tab，并切换到指定Tab。 我们先和左侧菜单一样单独定义一个组件Tabs.vue放在views&#x2F;inc文件夹内： src&#x2F;views&#x2F;inc&#x2F;Tabs.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;el-tabs v-model=&quot;editableTabsValue&quot; type=&quot;card&quot; closable @tab-remove=&quot;removeTab&quot; @tab-click=&quot;clickTab&quot;&gt; &lt;el-tab-pane v-for=&quot;item in editableTabs&quot; :key=&quot;item.name&quot; :label=&quot;item.title&quot; :name=&quot;item.name&quot; &gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt;&lt;/template&gt; export default &#123; name: &quot;Tabs&quot;, data() &#123; return &#123; &#125; &#125;, computed: &#123; editableTabs: &#123; get() &#123; return this.$store.state.menus.editableTabs; &#125;, set(val) &#123; this.$store.state.menus.editableTabs = val &#125; &#125;, editableTabsValue: &#123; get() &#123; return this.$store.state.menus.editableTabsValue; &#125;, set(val) &#123; this.$store.state.menus.editableTabsValue = val; &#125; &#125; &#125;, methods: &#123; clickTab(target) &#123; this.$router.push(&#123;name: target.name&#125;) &#125;, removeTab(targetName) &#123; let tabs = this.editableTabs; let activeName = this.editableTabsValue; // 首页不能删除 if (targetName === &quot;Index&quot;) &#123; return &#125; if (activeName === targetName) &#123; tabs.forEach((tab, index) =&gt; &#123; if (tab.name === targetName) &#123; let nextTab = tabs[index + 1] || tabs[index - 1]; if (nextTab) &#123; activeName = nextTab.name; &#125; &#125; &#125;); &#125; this.editableTabsValue = activeName; this.editableTabs = tabs.filter(tab =&gt; tab.name !== targetName); this.$router.push(&#123;name: activeName&#125;) &#125; &#125; &#125; 上面代码中，computed表示当其依赖的属性的值发生变化时，计算属性会重新计算，反之，则使用缓存中的属性值。这样我们就可以实时监测Tabs标签的动态变化实时显示（相当于实时get、set）。其他clickTab、removeTab的逻辑其实也还算简单，特别是removeTab注意考虑多种情况就可以。然后我们来到store中的menu.js，我们添加 editableTabsValue和editableTabs，然后把首页作为默认显示的页面。 src&#x2F;store&#x2F;modules&#x2F;menus.js 123456789101112131415state: &#123; // 菜单栏数据 menuList: [], // 权限数据 permList: [], hasRoute: false, editableTabsValue: &#x27;Index&#x27;, editableTabs: [ &#123; title: &#x27;首页&#x27;, name: &#x27;Index&#x27; &#125; ],&#125;, ok，然后再Home.vue中引入我们Tabs.vue这个组件，添加代码的地方比较零散，所以我就写重要代码出来就好，自行添加到指定的地方哈。 src&#x2F;views&#x2F;Home.vue 12345678910111213# 引入组件import Tabs from &quot;./inc/Tabs&quot;# 声明组件components: &#123; SideMenu, Tabs&#125;,&lt;el-main&gt; # 使用组件 &lt;Tabs&gt;&lt;/Tabs&gt; &lt;div style=&quot;margin: 0 15px;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/el-main&gt; 最后效果如下： 好了完成了第一步了，现在我们需要点击菜单导航，然后再tabs列表中添加tab标签页，那么我们来到SideMenu.vue，我们给el-menu-item每个菜单都添加一个点击事件： src&#x2F;views&#x2F;inc&#x2F;SideMenu.vue 123456789101112131415161718192021222324252627&lt;el-menu # 当前选择的菜单 :default-active=&quot;activeMenu&quot; ...&gt;...&lt;router-link :to=&quot;item.path&quot; v-for=&quot;item in menu.children&quot;&gt; &lt;el-menu-item :index=&quot;item.name&quot; @click=&quot;selectMenu(item)&quot;&gt; ... &lt;/el-menu-item&gt;&lt;/router-link&gt;computed: &#123; # 选择tab标签时候顺便也要激活当前对应的导航 activeMenu() &#123; return this.$store.state.menus.editableTabsValue &#125;&#125;,methods: &#123; selectMenu(item) &#123; console.log(item) let obj = &#123; name: item.name, title: item.title &#125; this.$store.commit(&quot;addTabs&quot;, obj) &#125;&#125; 因为tabs标签列表我们是存储在store中的，因此我们需要commit提交事件，因此我们在menu.js中添加addTabs方法： src&#x2F;store&#x2F;modules&#x2F;menus.js 12345678910111213141516mutations: &#123; addTabs(state, tab) &#123; console.log(tab) // 判断是否在栈内 let index = state.editableTabs.findIndex(item =&gt; item.name === tab.name) if (index === -1) &#123; // 添加到tabs中 state.editableTabs.push(tab) &#125; // 当前激活的tab state.editableTabsValue = tab.name &#125;, setActiveTab(state, tabName) &#123; state.editableTabsValue = tabName &#125;,&#125; 添加tab标签的时候注意需要激活指定当前标签，也就是设置editableTabsValue。然后我们也添加了setActiveTab方法，方便其他地方指定激活某个标签。具体效果如下： 上面的演示看似没什么问题了，但其实细节还是很多的，比如当我们刷新浏览器、或者直接通过输入链接打开页面时候就不会自动帮我们根据链接回显激活Tab。 从上面图中我们可以看出刷新浏览器之后链接&#x2F;sys&#x2F;users不变，内容不变，但是Tab却不见了，所以我们需要修补一下，当用户是直接通过输入链接形式打开页面的时候我们也能根据链接自动添加激活指定的tab。那么在哪里添加这个回显的方法呢？router中？其实可以，只不过我们需要做判断，因为每次点击导航都会触发router。有没有更简便的方法？有的！因为刷新或者打开页面都是一次性的行为，所以我们可以在更高层的App.vue中做这个回显动作，具体如下： src\\App.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; name: &quot;App&quot;, watch: &#123; // 解决刷新浏览器没有tab的问题 $route(to, from) &#123; if (to.path != &#x27;/login&#x27;) &#123; let obj = &#123; name: to.name, title: to.meta.title &#125; this.$store.commit(&quot;addTabs&quot;, obj) &#125; &#125; &#125; &#125; 上面代码可以看到，除了login页面，其他页面都会触发addTabs方法，这样我们就可以添加tab和激活tab了。 完美搞定！ 11. 个人中心个人中心用来展示用户的基本信息和修改密码，相对简单： src&#x2F;views&#x2F;UserCenter.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;template&gt; &lt;div style=&quot;text-align: center;&quot;&gt; &lt;h2&gt;你好！&#123;&#123; userInfo.username &#125;&#125; 同学&lt;/h2&gt; &lt;el-form :model=&quot;passForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;passForm&quot; label-width=&quot;100px&quot;&gt; &lt;el-form-item label=&quot;旧密码&quot; prop=&quot;currentPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;passForm.currentPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;新密码&quot; prop=&quot;password&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;passForm.password&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;passForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;passForm&#x27;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&#x27;passForm&#x27;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; name: &quot;Login&quot;, data() &#123; var validatePass = (rule, value, callback) =&gt; &#123; if (value === &#x27;&#x27;) &#123; callback(new Error(&#x27;请再次输入密码&#x27;)); &#125; else if (value !== this.passForm.password) &#123; callback(new Error(&#x27;两次输入密码不一致!&#x27;)); &#125; else &#123; callback(); &#125; &#125;; return &#123; userInfo: &#123; &#125;, passForm: &#123; password: &#x27;111111&#x27;, checkPass: &#x27;111111&#x27;, currentPass: &#x27;111111&#x27; &#125;, rules: &#123; password: [ &#123; required: true, message: &#x27;请输入新密码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; min: 6, max: 12, message: &#x27;长度在 6 到 12 个字符&#x27;, trigger: &#x27;blur&#x27; &#125; ], checkPass: [ &#123; required: true, validator: validatePass, trigger: &#x27;blur&#x27; &#125; ], currentPass: [ &#123; required: true, message: &#x27;请输入当前密码&#x27;, trigger: &#x27;blur&#x27; &#125;, ] &#125; &#125; &#125;, created() &#123; this.getUserInfo() &#125;, methods: &#123; getUserInfo() &#123; this.$axios.get(&quot;/sys/userInfo&quot;).then(res =&gt; &#123; this.userInfo = res.data.data; &#125;) &#125;, submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; const _this = this this.$axios.post(&#x27;/sys/user/updataPass&#x27;, this.passForm).then(res =&gt; &#123; _this.$alert(res.data.msg, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, callback: action =&gt; &#123; this.$refs[formName].resetFields(); &#125; &#125;); &#125;) &#125; else &#123; console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125; &#125; &#125;&lt;style scoped&gt;.el-form &#123; width: 420px; margin: 50px auto;&#125;&lt;/style&gt; 12. 菜单界面 菜单管理我们用到了Table表格组件的树形结构数据，我们只需要根据例子自己组装数据，就可以自动显示出来了，在新增数据的时候有个地方需要讲一下： 这里本应该是个树形数据的结构，但是现有的elementui不是很满足，于是我就拿了个简单的下拉框，然后子菜单就加上一个【- 】作为前缀，这样看起来就像一个树形结构了，也比较清晰。具体代码如下： src&#x2F;views&#x2F;sys&#x2F;Menu.vue 12345678910111213&lt;el-form-item label=&quot;上级菜单&quot; prop=&quot;parentId&quot; label-width=&quot;100px&quot;&gt; &lt;!--模拟树形下拉框--&gt; &lt;el-select v-model=&quot;editForm.parentId&quot; placeholder=&quot;请选择上级菜单&quot; &gt; &lt;template v-for=&quot;item in tableData&quot;&gt; &lt;el-option :label=&quot;item.name&quot; :value=&quot;item.id&quot;&gt;&lt;/el-option&gt; &lt;template v-for=&quot;child in item.children&quot;&gt; &lt;el-option :label=&quot;child.name&quot; :value=&quot;child.id&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;- &#x27; + child.name &#125;&#125;&lt;/span&gt; &lt;/el-option&gt; &lt;/template&gt; &lt;/template&gt; &lt;/el-select&gt;&lt;/el-form-item&gt; 其他都是基本的增删改查，填数据啥的，就比较繁琐和简单了，贴代码了哈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;template&gt; &lt;div&gt; &lt;!--搜索框--&gt; &lt;el-form :inline=&quot;true&quot; :model=&quot;searchForm&quot;&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = true&quot; v-if=&quot;hasAuth(&#x27;sys:menu:save&#x27;)&quot;&gt;新增&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!--列表--&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%;margin-bottom: 20px;&quot; row-key=&quot;id&quot; border stripe default-expand-all :tree-props=&quot;&#123;children: &#x27;children&#x27;, hasChildren: &#x27;hasChildren&#x27;&#125;&quot;&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;perms&quot; label=&quot;权限编码&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;icon&quot; label=&quot;图标&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;type&quot; label=&quot;类型&quot; width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag v-if=&quot;scope.row.type === 0&quot; size=&quot;small&quot;&gt;目录&lt;/el-tag&gt; &lt;el-tag v-else-if=&quot;scope.row.type === 1&quot; size=&quot;small&quot; type=&quot;success&quot;&gt;菜单&lt;/el-tag&gt; &lt;el-tag v-else-if=&quot;scope.row.type === 2&quot; size=&quot;small&quot; type=&quot;info&quot;&gt;按钮&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;path&quot; label=&quot;菜单URL&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;component&quot; label=&quot;菜单组件&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;orderNum&quot; label=&quot;排序号&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;statu&quot; label=&quot;状态&quot; width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag v-if=&quot;scope.row.statu === 0&quot; size=&quot;small&quot; type=&quot;danger&quot;&gt;禁用&lt;/el-tag&gt; &lt;el-tag v-else-if=&quot;scope.row.statu === 1&quot; size=&quot;small&quot; type=&quot;success&quot;&gt;正常&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; @click=&quot;editHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:menu:update&#x27;)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-popconfirm title=&quot;确定要删除这条记录吗？&quot; @confirm=&quot;delHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:menu:delete&#x27;)&quot;&gt; &lt;el-button type=&quot;text&quot; slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-dialog title=&quot;菜单信息&quot; :visible.sync=&quot;dialogFormVisible&quot; width=&quot;600px&quot; @closed=&quot;resetForm(&#x27;editForm&#x27;)&quot;&gt; &lt;el-form :model=&quot;editForm&quot; :rules=&quot;editFormRules&quot; ref=&quot;editForm&quot;&gt; &lt;el-form-item label=&quot;上级菜单&quot; prop=&quot;parentId&quot; label-width=&quot;100px&quot;&gt; &lt;!--模拟树形下拉框--&gt; &lt;el-select v-model=&quot;editForm.parentId&quot; placeholder=&quot;请选择上级菜单&quot; &gt; &lt;template v-for=&quot;item in tableData&quot;&gt; &lt;el-option :label=&quot;item.name&quot; :value=&quot;item.id&quot;&gt;&lt;/el-option&gt; &lt;template v-for=&quot;child in item.children&quot;&gt; &lt;el-option :label=&quot;child.name&quot; :value=&quot;child.id&quot;&gt; &lt;span&gt;&#123;&#123; &#x27;- &#x27; + child.name &#125;&#125;&lt;/span&gt; &lt;/el-option&gt; &lt;/template&gt; &lt;/template&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;菜单名称&quot; prop=&quot;name&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;权限编码&quot; prop=&quot;perms&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.perms&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;图标&quot; prop=&quot;icon&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.icon&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;菜单URL&quot; prop=&quot;path&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.path&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;菜单组件&quot; prop=&quot;component&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.component&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;类型&quot; prop=&quot;type&quot; label-width=&quot;100px&quot;&gt; &lt;el-radio-group v-model=&quot;editForm.type&quot;&gt; &lt;el-radio :label=0&gt;目录&lt;/el-radio&gt; &lt;el-radio :label=1&gt;菜单&lt;/el-radio&gt; &lt;el-radio :label=2&gt;按钮&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;状态&quot; prop=&quot;statu&quot; label-width=&quot;100px&quot;&gt; &lt;el-radio-group v-model=&quot;editForm.statu&quot;&gt; &lt;el-radio :label=0&gt;禁用&lt;/el-radio&gt; &lt;el-radio :label=1&gt;正常&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序号&quot; prop=&quot;orderNum&quot; label-width=&quot;100px&quot;&gt; &lt;el-input-number v-model=&quot;editForm.orderNum&quot; :min=&quot;1&quot; label=&quot;排序号&quot;&gt;1&lt;/el-input-number&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetForm(&#x27;editForm&#x27;)&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitEditForm(&#x27;editForm&#x27;)&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; name: &quot;Menu&quot;, data() &#123; return &#123; searchForm: &#123; name: &#x27;&#x27; &#125;, tableData: [], multipleSelection: [], dialogFormVisible: false, editForm: &#123; &#125;, editFormRules: &#123; parentId: [ &#123;required: true, message: &#x27;请选择上级菜单&#x27;, trigger: &#x27;blur&#x27;&#125; ], name: [ &#123;required: true, message: &#x27;请输入名称&#x27;, trigger: &#x27;blur&#x27;&#125; ], perms: [ &#123;required: true, message: &#x27;请输入权限编码&#x27;, trigger: &#x27;blur&#x27;&#125; ], type: [ &#123;required: true, message: &#x27;请选择状态&#x27;, trigger: &#x27;blur&#x27;&#125; ], orderNum: [ &#123;required: true, message: &#x27;请填入排序号&#x27;, trigger: &#x27;blur&#x27;&#125; ], statu: [ &#123;required: true, message: &#x27;请选择状态&#x27;, trigger: &#x27;blur&#x27;&#125; ] &#125; &#125; &#125;, methods: &#123; getMenuTree() &#123; this.$axios.get(&quot;/sys/menu/list&quot;, &#123; params: &#123; name: this.searchForm.name &#125; &#125;).then(res =&gt; &#123; console.log(res) this.tableData = res.data.data &#125;) &#125;, submitEditForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$axios.post(&#x27;/sys/menu/&#x27; + (this.editForm.id? &quot;update&quot; : &quot;save&quot;) ,this.editForm) .then(res =&gt; &#123; console.log(res.data) this.resetForm(formName) this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getMenuTree() &#125; &#125;); &#125;) &#125; else &#123; console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, editHandle(id) &#123; console.log(id) this.$axios.get(&quot;/sys/menu/info/&quot; + id).then(res =&gt; &#123; this.editForm = res.data.data this.dialogFormVisible = true &#125;) &#125;, delHandle(id) &#123; this.$axios.post(&quot;/sys/menu/delete/&quot; + id).then(res =&gt; &#123; console.log(res) this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getMenuTree() &#125; &#125;); &#125;) &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); this.editForm = &#123;&#125; this.dialogFormVisible = false &#125; &#125;, created() &#123; this.getMenuTree() &#125; &#125; 13. 角色界面 角色需要和菜单权限做关联，菜单是个树形结构的， 因为我们父节点是列表，所以注意不要选中父节点就自动选子节点，注意分开哈哈。 贴代码啦： src&#x2F;views&#x2F;sys&#x2F;Role.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;template&gt; &lt;div&gt; &lt;!--搜索框--&gt; &lt;el-form :inline=&quot;true&quot; :model=&quot;searchForm&quot; class=&quot;searchForm&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;searchForm.name&quot; placeholder=&quot;名称&quot; clearable&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button @click=&quot;getRoleList()&quot;&gt;搜索&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = true&quot; v-if=&quot;hasAuth(&#x27;sys:role:save&#x27;)&quot;&gt;新增&lt;/el-button&gt; &lt;el-popconfirm title=&quot;确定要删除这些记录吗？&quot; @confirm=&quot;delHandle(null)&quot; style=&quot;margin-left: 10px;&quot; v-if=&quot;hasAuth(&#x27;sys:role:delete&#x27;)&quot;&gt; &lt;el-button type=&quot;danger&quot; slot=&quot;reference&quot; :disabled=&quot;delBtnStu&quot;&gt;批量删除&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!--列表--&gt; &lt;el-table ref=&quot;multipleTable&quot; border stripe :data=&quot;tableData&quot; tooltip-effect=&quot;dark&quot; style=&quot;width: 100%&quot; @selection-change=&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;code&quot; label=&quot;唯一编码&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;remark&quot; label=&quot;描述&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;statu&quot; label=&quot;状态&quot; width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag v-if=&quot;scope.row.statu === 0&quot; size=&quot;small&quot; type=&quot;danger&quot;&gt;禁用&lt;/el-tag&gt; &lt;el-tag v-else-if=&quot;scope.row.statu === 1&quot; size=&quot;small&quot; type=&quot;success&quot;&gt;正常&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;220&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; @click=&quot;permHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:role:perm&#x27;)&quot;&gt;分配权限&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-button type=&quot;text&quot; @click=&quot;editHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:role:update&#x27;)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-popconfirm title=&quot;确定要删除这条记录吗？&quot; @confirm=&quot;delHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:role:delete&#x27;)&quot;&gt; &lt;el-button type=&quot;text&quot; slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--页码--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;current&quot; :page-sizes=&quot;[10, 20, 50, 100]&quot; :page-size=&quot;size&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt; &lt;/el-pagination&gt; &lt;!-- 编辑对话框 --&gt; &lt;el-dialog title=&quot;角色信息&quot; :visible.sync=&quot;dialogFormVisible&quot; width=&quot;600px&quot; @closed=&quot;resetForm(&#x27;editForm&#x27;)&quot;&gt; &lt;el-form :model=&quot;editForm&quot; :rules=&quot;editFormRules&quot; ref=&quot;editForm&quot;&gt; &lt;el-form-item label=&quot;角色名称&quot; prop=&quot;name&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;唯一编码&quot; prop=&quot;code&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.code&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;描述&quot; prop=&quot;remark&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.remark&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;状态&quot; prop=&quot;statu&quot; label-width=&quot;100px&quot;&gt; &lt;el-radio-group v-model=&quot;editForm.statu&quot;&gt; &lt;el-radio :label=&quot;0&quot;&gt;禁用&lt;/el-radio&gt; &lt;el-radio :label=&quot;1&quot;&gt;正常&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetForm(&#x27;editForm&#x27;)&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitEditForm(&#x27;editForm&#x27;)&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 分配权限对话框 --&gt; &lt;el-dialog title=&quot;分配权限&quot; :visible.sync=&quot;permDialogFormVisible&quot; width=&quot;600px&quot; @closed=&quot;resetForm(&#x27;permForm&#x27;)&quot;&gt; &lt;el-form :model=&quot;permForm&quot; ref=&quot;permForm&quot;&gt; &lt;el-tree :data=&quot;permTreeData&quot; show-checkbox ref=&quot;permTree&quot; :check-strictly=checkStrictly node-key=&quot;id&quot; :default-expand-all=true :props=&quot;defaultProps&quot;&gt; &lt;/el-tree&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetForm(&#x27;permForm&#x27;)&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitPermForm(&#x27;permForm&#x27;)&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; name: &quot;Role&quot;, data() &#123; return &#123; searchForm: &#123; name: &#x27;&#x27; &#125;, tableData: [], multipleSelection: [], dialogFormVisible: false, permDialogFormVisible: false, delBtnStu: true, current: 1, total: 0, size: 10, editForm: &#123; &#125;, editFormRules: &#123; name: [ &#123;required: true, message: &#x27;请输入名称&#x27;, trigger: &#x27;blur&#x27;&#125; ], code: [ &#123;required: true, message: &#x27;请输入唯一编码&#x27;, trigger: &#x27;blur&#x27;&#125; ], statu: [ &#123;required: true, message: &#x27;请选择状态&#x27;, trigger: &#x27;blur&#x27;&#125; ] &#125;, permForm: &#123; &#125;, defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;name&#x27; &#125;, permTreeData: [], treeCheckedKeys: [], checkStrictly: true &#125; &#125;, methods: &#123; toggleSelection(rows) &#123; if (rows) &#123; rows.forEach(row =&gt; &#123; this.$refs.multipleTable.toggleRowSelection(row); &#125;); &#125; else &#123; this.$refs.multipleTable.clearSelection(); &#125; &#125;, handleSelectionChange(val) &#123; this.multipleSelection = val; this.delBtnStu = val.length == 0 &#125;, getRoleList() &#123; this.$axios.get(&#x27;/sys/role/list&#x27;, &#123; params: &#123; name: this.searchForm.name, current: this.current, size: this.size &#125; &#125;).then(res =&gt; &#123; this.tableData = res.data.data.records this.current = res.data.data.current this.size = res.data.data.size this.total = res.data.data.total console.log(res) &#125;) this.$axios.get(&quot;/sys/menu/list&quot;).then(res =&gt; &#123; this.permTreeData = res.data.data &#125;) &#125;, handleSizeChange(val) &#123; this.size = val this.getRoleList() &#125;, handleCurrentChange(val) &#123; this.current = val this.getRoleList() &#125;, submitEditForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$axios.post(&#x27;/sys/role/&#x27; + (this.editForm.id? &quot;update&quot; : &quot;save&quot;) ,this.editForm) .then(res =&gt; &#123; console.log(res.data) this.resetForm(formName) this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getRoleList() &#125; &#125;); &#125;) &#125; else &#123; console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, editHandle(id) &#123; console.log(id) this.$axios.get(&quot;/sys/role/info/&quot; + id).then(res =&gt; &#123; this.editForm = res.data.data this.dialogFormVisible = true &#125;) &#125;, delHandle(id) &#123; console.log(id) var ids = [] console.log(id ? 31:32) id ? ids.push(id) : this.multipleSelection.forEach(row =&gt; &#123; ids.push(row.id) &#125;) console.log(ids) this.$axios.post(&quot;/sys/role/delete&quot;, ids).then(res =&gt; &#123; console.log(res) this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getRoleList() &#125; &#125;); &#125;) &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); this.editForm = &#123;&#125; this.dialogFormVisible = false this.permDialogFormVisible = false &#125;, permHandle(id) &#123; this.permDialogFormVisible = true this.$axios.get(&quot;/sys/role/info/&quot; + id).then(res =&gt; &#123; this.$refs.permTree.setCheckedKeys(res.data.data.menuIds); this.permForm = res.data.data console.log(&quot;this.treeCheckedKeys&quot;) console.log(this.treeCheckedKeys) &#125;) &#125;, submitPermForm(formName) &#123; var menuIds = [] menuIds = this.$refs.permTree.getCheckedKeys() // menuIds = menuIds.concat(this.$refs.permTree.getHalfCheckedKeys()) // 半选中状态的父节点 console.log(menuIds) console.log(this.permForm.id) this.$axios.post(&quot;/sys/role/perm/&quot; + this.permForm.id, menuIds).then(res =&gt; &#123; this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.resetForm(formName) &#125; &#125;); this.permDialogFormVisible = false &#125;) &#125;, &#125;, created() &#123; this.getRoleList() &#125; &#125; 14. 用户界面 线上演示：https://www.markerhub.com/vueadmin/ 用户管理有个操作叫分配角色，和角色添加权限差不多的操作 贴代码啦： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332&lt;template&gt; &lt;div&gt; &lt;!--搜索框--&gt; &lt;el-form :inline=&quot;true&quot; :model=&quot;searchForm&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;searchForm.username&quot; placeholder=&quot;名称&quot; clearable&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button&gt;搜索&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = true&quot; v-if=&quot;hasAuth(&#x27;sys:user:save&#x27;)&quot;&gt;新增&lt;/el-button&gt; &lt;el-popconfirm title=&quot;确定要删除这些记录吗？&quot; @confirm=&quot;delHandle(null)&quot; style=&quot;margin-left: 10px;&quot; v-if=&quot;hasAuth(&#x27;sys:user:delete&#x27;)&quot;&gt; &lt;el-button type=&quot;danger&quot; slot=&quot;reference&quot; :disabled=&quot;delBtnStu&quot;&gt;批量删除&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;!--列表--&gt; &lt;el-table ref=&quot;multipleTable&quot; border stripe :data=&quot;tableData&quot; tooltip-effect=&quot;dark&quot; style=&quot;width: 100%&quot; @selection-change=&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;头像&quot; width=&quot;50&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-avatar size=&quot;small&quot; :src=&quot;scope.row.avatar&quot;&gt;&lt;/el-avatar&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;username&quot; label=&quot;用户名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;角色名称&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag style=&quot;margin-right: 5px;&quot; size=&quot;small&quot; type=&quot;info&quot; v-for=&quot;item in scope.row.roles&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;email&quot; label=&quot;邮箱&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;phone&quot; label=&quot;手机号&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;状态&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag v-if=&quot;scope.row.statu === 0&quot; size=&quot;small&quot; type=&quot;danger&quot;&gt;禁用&lt;/el-tag&gt; &lt;el-tag v-else-if=&quot;scope.row.statu === 1&quot; size=&quot;small&quot; type=&quot;success&quot;&gt;正常&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;created&quot; label=&quot;创建时间&quot; width=&quot;200&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column width=&quot;260px&quot; label=&quot;操作&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;text&quot; @click=&quot;roleHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:user:role&#x27;)&quot;&gt;分配角色&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-button type=&quot;text&quot; @click=&quot;repassHandle(scope.row.id, scope.row.username)&quot; v-if=&quot;hasAuth(&#x27;sys:user:repass&#x27;)&quot;&gt;重置密码&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-button type=&quot;text&quot; @click=&quot;editHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:user:update&#x27;)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-divider direction=&quot;vertical&quot;&gt;&lt;/el-divider&gt; &lt;el-popconfirm title=&quot;确定要删除这条记录吗？&quot; @confirm=&quot;delHandle(scope.row.id)&quot; v-if=&quot;hasAuth(&#x27;sys:user:delete&#x27;)&quot;&gt; &lt;el-button type=&quot;text&quot; slot=&quot;reference&quot;&gt;删除&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--页码--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;current&quot; :page-sizes=&quot;[10, 20, 50, 100]&quot; :page-size=&quot;size&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt; &lt;/el-pagination&gt; &lt;el-dialog title=&quot;用户信息&quot; :visible.sync=&quot;dialogFormVisible&quot; width=&quot;600px&quot;&gt; &lt;el-form :model=&quot;editForm&quot; :rules=&quot;editFormRules&quot; ref=&quot;editForm&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.username&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;el-alert title=&quot;初始密码为888888&quot; :closable=&quot;false&quot; type=&quot;info&quot; style=&quot;line-height: 12px;&quot; &gt;&lt;/el-alert&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.email&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机号&quot; prop=&quot;phone&quot; label-width=&quot;100px&quot;&gt; &lt;el-input v-model=&quot;editForm.phone&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;状态&quot; prop=&quot;statu&quot; label-width=&quot;100px&quot;&gt; &lt;el-radio-group v-model=&quot;editForm.statu&quot;&gt; &lt;el-radio :label=&quot;0&quot;&gt;禁用&lt;/el-radio&gt; &lt;el-radio :label=&quot;1&quot;&gt;正常&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetForm(&#x27;editForm&#x27;)&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitEditForm(&#x27;editForm&#x27;)&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 分配权限对话框 --&gt; &lt;el-dialog title=&quot;分配角色&quot; :visible.sync=&quot;roleDialogFormVisible&quot; width=&quot;600px&quot; @closed=&quot;resetForm(&#x27;roleForm&#x27;)&quot;&gt; &lt;el-form :model=&quot;roleForm&quot; ref=&quot;roleForm&quot;&gt; &lt;el-tree :data=&quot;roleTreeData&quot; show-checkbox ref=&quot;roleTree&quot; node-key=&quot;id&quot; :default-expand-all=true :props=&quot;defaultProps&quot;&gt; &lt;/el-tree&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetForm(&#x27;roleForm&#x27;)&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitRoleForm(&#x27;roleForm&#x27;)&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; name: &quot;User&quot;, data() &#123; return &#123; searchForm: &#123; username: &#x27;&#x27; &#125;, editForm: &#123; &#125;, editFormRules: &#123; username: [ &#123;required: true, message: &#x27;请输入用户名称&#x27;, trigger: &#x27;blur&#x27;&#125; ], email: [ &#123;required: true, message: &#x27;请输入邮箱&#x27;, trigger: &#x27;blur&#x27;&#125; ], statu: [ &#123;required: true, message: &#x27;请选择状态&#x27;, trigger: &#x27;blur&#x27;&#125; ] &#125;, current: 1, total: 0, size: 10, dialogFormVisible: false, tableData: [], multipleSelection: [], delBtnStu: true, roleDialogFormVisible: false, roleForm: &#123; &#125;, defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;name&#x27; &#125;, roleTreeData: [], treeCheckedKeys: [], &#125; &#125;, methods: &#123; toggleSelection(rows) &#123; if (rows) &#123; rows.forEach(row =&gt; &#123; this.$refs.multipleTable.toggleRowSelection(row); &#125;); &#125; else &#123; this.$refs.multipleTable.clearSelection(); &#125; &#125;, handleSelectionChange(rows) &#123; this.multipleSelection = rows; this.delBtnStu = rows.length == 0 &#125;, getUserList() &#123; this.$axios.get(&#x27;/sys/user/list&#x27;, &#123; params: &#123; name: this.searchForm.name, current: this.current, size: this.size &#125; &#125;).then(res =&gt; &#123; this.tableData = res.data.data.records this.current = res.data.data.current this.size = res.data.data.size this.total = res.data.data.total &#125;) &#125;, handleSizeChange(val) &#123; this.size = val this.getUserList() &#125;, handleCurrentChange(val) &#123; this.current = val this.getUserList() &#125;, submitEditForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; this.$axios.post(&#x27;/sys/user/&#x27; + (this.editForm.id? &quot;update&quot; : &quot;save&quot;) ,this.editForm) .then(res =&gt; &#123; console.log(res.data) this.resetForm(formName) this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getUserList() &#125; &#125;); &#125;) &#125; else &#123; console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, editHandle(id) &#123; console.log(id) this.$axios.get(&quot;/sys/user/info/&quot; + id).then(res =&gt; &#123; this.editForm = res.data.data this.dialogFormVisible = true &#125;) &#125;, delHandle(id) &#123; var ids = [] id ? ids.push(id) : this.multipleSelection.forEach(row =&gt; &#123; ids.push(row.id) &#125;) console.log(ids) this.$axios.post(&quot;/sys/user/delete&quot;, ids).then(res =&gt; &#123; this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.getUserList() &#125; &#125;); &#125;) &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); this.editForm = &#123;&#125; this.dialogFormVisible = false this.roleDialogFormVisible = false &#125;, roleHandle(id) &#123; this.$axios.get(&quot;/sys/user/info/&quot; + id).then(res =&gt; &#123; const sysuser = res.data.data var roleIds = [] sysuser.roles.forEach(row =&gt; &#123; roleIds.push(row.id) &#125;) console.log(&quot;roleIds&quot;) console.log(roleIds) this.roleForm = res.data.data console.log(&quot;this.treeCheckedKeys&quot;) console.log(this.treeCheckedKeys) this.$axios.get(&quot;/sys/role/list&quot;).then(res =&gt; &#123; this.roleTreeData = res.data.data.records this.$refs.roleTree.setCheckedKeys(roleIds); &#125;) &#125;) this.roleDialogFormVisible = true &#125;, submitRoleForm(formName) &#123; var roleIds = [] roleIds = this.$refs.roleTree.getCheckedKeys() console.log(roleIds) console.log(this.roleForm.id) this.$axios.post(&quot;/sys/user/role/&quot; + this.roleForm.id, roleIds).then(res =&gt; &#123; this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; this.resetForm(formName) this.getUserList() &#125; &#125;); this.roleDialogFormVisible = false &#125;) &#125;, repassHandle(id, username) &#123; this.$confirm(&#x27;将重置用户【&#x27; + username + &#x27;】的密码, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; this.$axios.post(&quot;/sys/user/repass&quot;, id).then(res =&gt; &#123; this.$message(&#123; showClose: true, message: &#x27;恭喜你，操作成功&#x27;, type: &#x27;success&#x27;, onClose: () =&gt; &#123; &#125; &#125;); &#125;) &#125;) &#125; &#125;, created() &#123; this.getUserList() &#125; &#125; 15. 按钮权限的控制上面的菜单、角色、用户有增删改查操作，但是不是每个用户都有权限的，没权限的用户我们应该隐藏按钮，因此我们需要通过条件来判断按钮是否应该显示，那么应该怎么定义一个方法可以让全局都能使用呢？ 我们再src下面新建一个js文件用于定义一个全局使用的方法： src&#x2F;globalFun.js 12345678910import Vue from &#x27;vue&#x27;Vue.mixin(&#123; methods: &#123; hasAuth(perm) &#123; var authority = this.$store.state.menus.permList console.log(authority) return authority.indexOf(perm) &gt; -1 &#125; &#125;&#125;) 之前我们在加载菜单的时候说过，我们同时要加载权限数据，现在就需要用到权限数据了，这里数组，因此我们通过按钮的权限是否在所有权限列表内就行了。mixin的作用是多个组件可以共享数据和方法，在使用mixin的组件中引入后，mixin中的方法和属性也就并入到该组件中，可以直接使用，在已有的组件数据和方法进行了扩充。引入mixin分全局引用和局部引用。 然后我们需要在main.js中引入这个文件 src\\main.js 1import gobal from &quot;./globalFun&quot; 这样全局就可以使用啦，比如我们在新增按钮这里做判断： src&#x2F;views&#x2F;sys&#x2F;Menu.vue 1&lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = true&quot; v-if=&quot;hasAuth(&#x27;sys:menu:save&#x27;)&quot;&gt;新增&lt;/el-button&gt; 通过v-if来判断返回是否为true从而判断是否显示。 16. 结束语视频讲解：https://www.bilibili.com/video/BV1af4y1s7Wh/ 线上演示：https://www.markerhub.com/vueadmin/ 首发公众号：MarkerHub 撰写人：吕一明 转载请保留此声明，感谢！ #vueadmin #后台管理系统 #前后端分离 #springboot项目 全部评论: 14 条 Hub-riaqw2022-06-21ヾ(≧∇≦*)ゝ Hub-1uqwj2022-06-09索多四类 Hub-atheo2022-05-17不是基于 vue-element-templet开发的吗 Hub-dyfk02022-05-02有没有源码 Hub-y1w162022-04-02看看资源管理器服务的redis开启没有 @Hub-qmfh9: 为什么我下载了源码什么都配置好了 跨域去8081还是报错401 百度了都配好了 还是不行 求告知为什么 Hub-qmfh92022-03-20为什么我下载了源码什么都配置好了 跨域去8081还是报错401 百度了都配好了 还是不行 求告知为什么 1 2 3 &gt; 我有话说: 发送 – 目录 – [1. 前言](https://www.zhuawaba.com/post/18#1. 前言) [2. 安装vue环境，并新建Vue项目](https://www.zhuawaba.com/post/18#2. 安装vue环境，并新建Vue项目) [3. 安装element-ui](https://www.zhuawaba.com/post/18#3. 安装element-ui) [4. 安装axios、qs、mockjs](https://www.zhuawaba.com/post/18#4. 安装axios、qs、mockjs) [5. 页面路由](https://www.zhuawaba.com/post/18#5. 页面路由) \\6. 登陆界面开发 登录交互过程 token的状态同步 定义全局axios拦截器 [7. 后台管理界面开发](https://www.zhuawaba.com/post/18#7. 后台管理界面开发) [8. 用户登录信息展示](https://www.zhuawaba.com/post/18#8. 用户登录信息展示) [9. 动态菜单栏开发](https://www.zhuawaba.com/post/18#9. 动态菜单栏开发) [10. 动态标签页开发](https://www.zhuawaba.com/post/18#10. 动态标签页开发) [11. 个人中心](https://www.zhuawaba.com/post/18#11. 个人中心) [12. 菜单界面](https://www.zhuawaba.com/post/18#12. 菜单界面) [13. 角色界面](https://www.zhuawaba.com/post/18#13. 角色界面) [14. 用户界面](https://www.zhuawaba.com/post/18#14. 用户界面) [15. 按钮权限的控制](https://www.zhuawaba.com/post/18#15. 按钮权限的控制) \\16. 结束语 关注官方公众号：Java问答社 接收最新有赏问答推送！ 最新发布 \\1. 一个依赖搞定 Spring Boot 反爬虫，防止接口盗刷！ \\2. Java8 Stream 极大简化了代码，它是如何实现的？ \\3. 马上大四了，秋招还是春招好？先找工作还是找实习？ \\4. 万字详解 Linux 常用指令（值得收藏） \\5. 4年工作经验，多线程间的5种通信方式都说不出来，你敢信？ \\6. 40 个 常用的 SpringBoot 注解，你知道几个？ 最新评论 已干完 为什么老是提示账号密码错误 redis起作用吗？开不开都能用，开了也没见往里面写值 怎么说，搞不搞 请问下这个退出功能是正常的吗OωO jar 能用，激活码需要从网上另找一个能用的 Copyright © 广州码客科技有限公司 粤ICP备19147782号 公众号：Java问答社 Powered by mblog","categories":[],"tags":[{"name":"VueAdmin前端","slug":"VueAdmin前端","permalink":"http://example.com/tags/VueAdmin%E5%89%8D%E7%AB%AF/"}]},{"title":"VueAdmin后端","slug":"VueAdmin后端","date":"2022-10-07T04:41:17.000Z","updated":"2022-10-07T04:43:20.030Z","comments":true,"path":"2022/10/07/VueAdmin后端/","link":"","permalink":"http://example.com/2022/10/07/VueAdmin%E5%90%8E%E7%AB%AF/","excerpt":"","text":"开发SpringBoot+Jwt+Vue的前后端分离后台管理系统VueAdmin - 后端笔记社长 1年前 ⋅ 44836 阅读 为了让更多同学学习到前后端分离管理系统的搭建过程，这里我写了详细的开发过程的文档，使用的是springsecurity + jwt + vue的技术栈组合，如果有帮助，别忘了点个赞和关注我的公众号哈！ 线上预览：https://markerhub.com/vueadmin 效果图： 首发公众号：MarkerHub 作者：吕一明 项目源码：关注公众号 MarkerHub 回复【 234 】获取 线上预览：https://markerhub.com/vueadmin 项目视频：https://www.bilibili.com/video/BV1af4y1s7Wh/ 转载请保留此声明，感谢！ 另外我还有另外一个前后端博客项目博客VueBlog，如果有需要可以关注公众号MarkerHub，回复【VueBlog】获取哈！！ 1. 前言从零开始搭建一个项目骨架，最好选择合适熟悉的技术，并且在未来易拓展，适合微服务化体系等。所以一般以Springboot作为我们的框架基础，这是离不开的了。 然后数据层，我们常用的是Mybatis，易上手，方便维护。但是单表操作比较困难，特别是添加字段或减少字段的时候，比较繁琐，所以这里我推荐使用Mybatis Plus（https://mp.baomidou.com/），为简化开发而生，只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。 作为一个项目骨架，权限也是我们不能忽略的，上一个项目vueblog我们使用了shiro，但是有些同学想学学SpringSecurity，所以这一期我们使用security作为我们的权限控制和会话控制的框架。 考虑到项目可能需要部署多台，一些需要共享的信息就保存在中间件中，Redis是现在主流的缓存中间件，也适合我们的项目。 然后因为前后端分离，所以我们使用jwt作为我们用户身份凭证，并且session我们会禁用，这样以前传统项目使用的方式我们可能就不再适合使用，这点需要注意了。 ok，我们现在就开始搭建我们的项目脚手架！ 技术栈： SpringBoot mybatis plus spring security lombok redis hibernate validatior jwt 2. 新建springboot项目，注意版本这里，我们使用IDEA来开发我们项目，新建步骤比较简单，我们就不截图了。 开发工具与环境： idea mysql jdk 8 maven3.3.9 新建好的项目结构如下，SpringBoot版本使用的目前最新的2.4.0版本 pom的jar包导入如下： 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;groupId&gt;com.markerhub&lt;/groupId&gt;&lt;artifactId&gt;vueadmin-java&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;vueadmin-java&lt;/name&gt;&lt;description&gt;公众号：MarkerHub&lt;/description&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; devtools：项目的热加载重启插件 lombok：简化代码的工具 3. 整合mybatis plus，生成代码接下来，我们来整合mybatis plus，让项目能完成基本的增删改查操作。步骤很简单：可以去官网看看：https://mp.baomidou.com/guide/ 第一步：导入jar包pom中导入mybatis plus的jar包，因为后面会涉及到代码生成，所以我们还需要导入页面模板引擎，这里我们用的是freemarker。 12345678910111213141516171819202122&lt;!--整合mybatis plus https://baomidou.com/--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--mp代码生成器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 第二步：然后去写配置文件1234567891011server: port: 8081# DataSource Configspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueadmin?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: adminmybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml 上面除了配置数据库的信息，还配置了myabtis plus的mapper的xml文件的扫描路径，这一步不要忘记了。然后因为前段默认是8080端口了，所以后端我们设置为8081端口，防止端口冲突。 第三步：开启mapper接口扫描，添加分页、防全表更新插件新建一个包：通过@mapperScan注解指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类。 com.markerhub.config.MybatisPlusConfig 123456789101112131415161718192021@Configuration@MapperScan(&quot;com.markerhub.mapper&quot;)public class MybatisPlusConfig &#123; /** * 新的分页插件,一缓和二缓遵循mybatis的规则, * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false * 避免缓存出现问题(该属性会在旧插件移除后一同移除) */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); // 防止全表更新和删除 interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor; &#125; @Bean public ConfigurationCustomizer configurationCustomizer() &#123; return configuration -&gt; configuration.setUseDeprecatedExecutor(false); &#125;&#125; 上面代码中，我们给Mybatis plus添加了2个拦截器，这是根据mp官网配置的： PaginationInnerInterceptor：新的分页插件 BlockAttackInnerInterceptor：防止全表更新和删除 第四步：创建数据库和表 因为是后台管理系统的权限模块，所以我们需要考虑的表主要就几个：用户表、角色表、菜单权限表、以及关联的用户角色中间表、菜单角色中间表。就5个表，至于什么字段其实都听随意的，用户表里面除了用户名、密码字段必要，其他其实都听随意，然后角色和菜单我们可以参考一下其他的系统、或者自己在做项目的过程中需要的时候在添加也行，反正重新生成代码也是非常简便的事情，综合考虑，数据库名称为vueadmin，我们建表语句如下： vueadmin.sql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50717Source Host : localhost:3306Source Database : vueadminTarget Server Type : MYSQLTarget Server Version : 50717File Encoding : 65001Date: 2021-01-23 09:41:50*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for sys_menu-- ----------------------------DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT &#x27;父菜单ID，一级菜单为0&#x27;, `name` varchar(64) NOT NULL, `path` varchar(255) DEFAULT NULL COMMENT &#x27;菜单URL&#x27;, `perms` varchar(255) DEFAULT NULL COMMENT &#x27;授权(多个用逗号分隔，如：user:list,user:create)&#x27;, `component` varchar(255) DEFAULT NULL, `type` int(5) NOT NULL COMMENT &#x27;类型 0：目录 1：菜单 2：按钮&#x27;, `icon` varchar(32) DEFAULT NULL COMMENT &#x27;菜单图标&#x27;, `orderNum` int(11) DEFAULT NULL COMMENT &#x27;排序&#x27;, `created` datetime NOT NULL, `updated` datetime DEFAULT NULL, `statu` int(5) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for sys_role-- ----------------------------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `code` varchar(64) NOT NULL, `remark` varchar(64) DEFAULT NULL COMMENT &#x27;备注&#x27;, `created` datetime DEFAULT NULL, `updated` datetime DEFAULT NULL, `statu` int(5) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`) USING BTREE, UNIQUE KEY `code` (`code`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for sys_role_menu-- ----------------------------DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `role_id` bigint(20) NOT NULL, `menu_id` bigint(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=102 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Table structure for sys_user-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL, `avatar` varchar(255) DEFAULT NULL, `email` varchar(64) DEFAULT NULL, `city` varchar(64) DEFAULT NULL, `created` datetime DEFAULT NULL, `updated` datetime DEFAULT NULL, `last_login` datetime DEFAULT NULL, `statu` int(5) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `UK_USERNAME` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for sys_user_role-- ----------------------------DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL, `role_id` bigint(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4; 第五步：代码生成 获取项目数据库所对应表和字段的信息 新建一个freemarker的页面模板 - SysUser.java.ftl - ${baseEntity} 提供相关需要进行渲染的动态数据 - BaseEntity、表字段、注释、baseEntity&#x3D;SuperEntity 使用freemarker模板引擎进行渲染！ - SysUser.java 123456789101112131415# 获取表SELECT *FROM information_schema. TABLESWHERE TABLE_SCHEMA = (SELECT DATABASE());# 获取字段SELECT *FROM information_schema. COLUMNSWHERE TABLE_SCHEMA = (SELECT DATABASE())AND TABLE_NAME = &quot;sys_user&quot;; 有了数据库之后，那么现在就已经可以使用mybatis plus了，官方给我们提供了一个代码生成器，然后我写上自己的参数之后，就可以直接根据数据库表信息生成entity、service、mapper等接口和实现类。因为代码比较长，就不贴出来了，说明一下重点： com.markerhub.CodeGenerator 上面代码生成的过程中，我默认所有的实体类都继承BaseEntity，控制器都继承BaseController，所以在代码生成之前，最好先编写这两个基类： com.markerhub.entity.BaseEntity 12345678@Datapublic class BaseEntity implements Serializable &#123; @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; private LocalDateTime created; private LocalDateTime updated; private Integer statu;&#125; com.markerhub.controller.BaseController 1234public class BaseController &#123; @Autowired HttpServletRequest req;&#125; 然后我们单独运行CodeGenerator的main方法，注意调整CodeGenerator的数据库连接、账号密码啥的，然后我们输入表名称，通过逗号隔开：sys_menu,sys_role,sys_role_menu,sys_user,sys_user_role执行结果成功： 然后我们生成了一些代码如下： 这里有点需要注意，因为关联的用户角色中间表、菜单角色中间表我们是没有created等几个公共字段的，所以我们把这两个实体继承BaseEntity去掉： 最后这样子的： 1234@Datapublic class SysRoleMenu &#123; ...&#125; 简洁！方便！经过上面的步骤，基本上我们已经把mybatis plus框架集成到项目中了，并且也生成了基本的代码，省了好多功夫。然后我们做个简单测试： com.markerhub.controller.TestController 123456789@RestControllerpublic class TestController &#123; @Autowired SysUserService userService; @GetMapping(&quot;/test&quot;) public Object test() &#123; return userService.list(); &#125;&#125; 然后sys_user随意添加几条数据，结果如下： ok，毛什么问题，大家不用在意密码是怎么生成的，后面我们会说到，你现在随意填写就好了。对了，好多人问我的浏览器的json数据怎么显示这么好看，这是因为我用了JSONView这个插件： 4. 结果封装因为是前后端分离的项目，所以我们有必要统一一个结果返回封装类，这样前后端交互的时候有个统一的标准，约定结果返回的数据是正常的或者遇到异常了。 这里我们用到了一个Result的类，这个用于我们的异步统一返回的结果封装。一般来说，结果里面有几个要素必要的 是否成功，可用code表示（如200表示成功，400表示异常） 结果消息 结果数据 所以可得到封装如下： com.markerhub.common.lang.Result 123456789101112131415161718192021222324252627282930@Datapublic class Result implements Serializable &#123; private int code; // 200是正常，非200表示异常 private String msg; private Object data; public static Result succ(Object data) &#123; return succ(200, &quot;操作成功&quot;, data); &#125; public static Result succ(int code, String msg, Object data) &#123; Result r = new Result(); r.setCode(code); r.setMsg(msg); r.setData(data); return r; &#125; public static Result fail(String msg) &#123; return fail(400, msg, null); &#125; public static Result fail(String msg, Object data) &#123; return fail(400, msg, data); &#125; public static Result fail(int code, String msg, Object data) &#123; Result r = new Result(); r.setCode(code); r.setMsg(msg); r.setData(data); return r; &#125;&#125; 另外出了在结果封装类上的code可以提现数据是否正常，我们还可以通过http的状态码来提现访问是否遇到了异常，比如401表示五权限拒绝访问等，注意灵活使用。 5. 全局异常处理有时候不可避免服务器报错的情况，如果不配置异常处理机制，就会默认返回tomcat或者nginx的5XX页面，对普通用户来说，不太友好，用户也不懂什么情况。这时候需要我们程序员设计返回一个友好简单的格式给前端。 处理办法如下：通过使用@ControllerAdvice来进行统一异常处理，@ExceptionHandler(value &#x3D; RuntimeException.class)来指定捕获的Exception各个类型异常 ，这个异常的处理，是全局的，所有类似的异常，都会跑到这个地方处理。 步骤二、定义全局异常处理，@ControllerAdvice表示定义全局控制器异常处理，@ExceptionHandler表示针对性异常处理，可对每种异常针对性处理。 com.markerhub.common.exception.GlobalExceptionHandler 123456789101112131415161718192021222324252627282930313233343536/** * 全局异常处理 */@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123; @ResponseStatus(HttpStatus.FORBIDDEN) @ExceptionHandler(value = AccessDeniedException.class) public Result handler(AccessDeniedException e) &#123; log.info(&quot;security权限不足：----------------&#123;&#125;&quot;, e.getMessage()); return Result.fail(&quot;权限不足&quot;); &#125; @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = MethodArgumentNotValidException.class) public Result handler(MethodArgumentNotValidException e) &#123; log.info(&quot;实体校验异常：----------------&#123;&#125;&quot;, e.getMessage()); BindingResult bindingResult = e.getBindingResult(); ObjectError objectError = bindingResult.getAllErrors().stream().findFirst().get(); return Result.fail(objectError.getDefaultMessage()); &#125; @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = IllegalArgumentException.class) public Result handler(IllegalArgumentException e) &#123; log.error(&quot;Assert异常：----------------&#123;&#125;&quot;, e.getMessage()); return Result.fail(e.getMessage()); &#125; @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = RuntimeException.class) public Result handler(RuntimeException e) &#123; log.error(&quot;运行时异常：----------------&#123;&#125;&quot;, e); return Result.fail(e.getMessage()); &#125;&#125; 上面我们捕捉了几个异常： ShiroException：shiro抛出的异常，比如没有权限，用户登录异常 IllegalArgumentException：处理Assert的异常 MethodArgumentNotValidException：处理实体校验的异常 RuntimeException：捕捉其他异常 6. 整合Spring Security很多人不懂spring security，觉得这个框架比shiro要难，的确，security更加复杂一点，同时功能也更加强大，我们首先来看一下security的原理，这里我们引用一张来自江南一点雨大佬画的一张原理图（https://blog.csdn.net/u012702547/article/details/89629415）： （引自江南一点雨的博客） 上面这张图一定要好好看，特别清晰，毕竟security是责任链的设计模式，是一堆过滤器链的组合，如果对于这个流程都不清楚，那么你就谈不上理解security。那么针对我们现在的这个系统，我们可以自己设计一个security的认证方案，结合江南一点雨大佬的博客，我们得到这样一套流程： https://www.processon.com/view/link/606b0b5307912932d09adcb3 流程说明： 客户端发起一个请求，进入 Security 过滤器链。 当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理。如果不是登出路径则直接进入下一个过滤器。 当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler ，登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。 进入认证BasicAuthenticationFilter进行用户认证，成功的话会把认证了的结果写入到SecurityContextHolder中SecurityContext的属性authentication上面。如果认证失败就会交给AuthenticationEntryPoint认证失败处理类，或者抛出异常被后续ExceptionTranslationFilter过滤器处理异常，如果是AuthenticationException就交给AuthenticationEntryPoint处理，如果是AccessDeniedException异常则交给AccessDeniedHandler处理。 当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层，否则到 AccessDeniedHandler 鉴权失败处理器处理。 Spring Security 实战干货：必须掌握的一些内置 Filter：https://blog.csdn.net/qq_35067322&#x2F;article&#x2F;details&#x2F;102690579 ok，上面我们说的流程中涉及到几个组件，有些是我们需要根据实际情况来重写的。因为我们是使用json数据进行前后端数据交互，并且我们返回结果也是特定封装的。我们先再总结一下我们需要了解的几个组件： LogoutFilter - 登出过滤器 logoutSuccessHandler - 登出成功之后的操作类 UsernamePasswordAuthenticationFilter - from提交用户名密码登录认证过滤器 AuthenticationFailureHandler - 登录失败操作类 AuthenticationSuccessHandler - 登录成功操作类 BasicAuthenticationFilter - Basic身份认证过滤器 SecurityContextHolder - 安全上下文静态工具类 AuthenticationEntryPoint - 认证失败入口 ExceptionTranslationFilter - 异常处理过滤器 AccessDeniedHandler - 权限不足操作类 FilterSecurityInterceptor - 权限判断拦截器、出口 有了上面的组件，那么认证与授权两个问题我们就已经接近啦，我们现在需要做的就是去重写我们的一些关键类。 引入Security与jwt首先我们导入security包，因为我们前后端交互用户凭证用的是JWT，所以我们也导入jwt的相关包，然后因为验证码的存储需要用到redis，所以引入redis。最后为了一些工具类，我们引入hutool。 pom.xml 12345678910111213141516171819202122232425262728293031&lt;!-- springboot security --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.axet&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;0.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hutool工具类--&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.11&lt;/version&gt;&lt;/dependency&gt; 启动redis，然后我们再启动项目，这时候我们再去访问http://localhost:8081/test，会发现系统会先判断到你未登录跳转到http://localhost:8081/login，因为security内置了登录页，用户名为user，密码在启动项目的时候打印在了控制台。登录完成之后我们才可以正常访问接口。因为每次启动密码都会改变，所以我们通过配置文件来配置一下默认的用户名和密码： application.yml 12345spring: security: user: name: user password: 111111 用户认证首先我们来解决用户认证问题，分为首次登陆，和二次认证。 首次登录认证：用户名、密码和验证码完成登录 二次token认证：请求头携带Jwt进行身份认证 使用用户名密码来登录的，然后我们还想添加图片验证码，那么security给我们提供的UsernamePasswordAuthenticationFilter能使用吗？ 首先security的所有过滤器都是没有图片验证码这回事的，看起来不适用了。其实这里我们可以灵活点，如果你依然想沿用自带的UsernamePasswordAuthenticationFilter，那么我们就在这过滤器之前添加一个图片验证码过滤器。当然了我们也可以通过自定义过滤器继承UsernamePasswordAuthenticationFilter，然后自己把验证码验证逻辑和认证逻辑写在一起，这也是一种解决方式。 我们这次解决方式是在UsernamePasswordAuthenticationFilter之前自定义一个图片过滤器CaptchaFilter，提前校验验证码是否正确，这样我们就可以使用UsernamePasswordAuthenticationFilter了，然后登录正常或失败我们都可以通过对应的Handler来返回我们特定格式的封装结果数据。 生成验证码首先我们先生成验证码，之前我们已经引用了google的验证码生成器，我们先来配置一下图片验证码的生成规则： com.markerhub.config.KaptchaConfig 1234567891011121314151617@Configurationpublic class KaptchaConfig &#123; @Bean public DefaultKaptcha producer() &#123; Properties properties = new Properties(); properties.put(&quot;kaptcha.border&quot;, &quot;no&quot;); properties.put(&quot;kaptcha.textproducer.font.color&quot;, &quot;black&quot;); properties.put(&quot;kaptcha.textproducer.char.space&quot;, &quot;4&quot;); properties.put(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.put(&quot;kaptcha.image.width&quot;, &quot;120&quot;); properties.put(&quot;kaptcha.textproducer.font.size&quot;, &quot;30&quot;); Config config = new Config(properties); DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); defaultKaptcha.setConfig(config); return defaultKaptcha; &#125;&#125; 上面我定义了图片验证码的长宽字体颜色等，自己可以调整哈。然后我们通过控制器提供生成验证码的方法： com.markerhub.controller.AuthController 123456789101112131415161718192021222324252627282930@Slf4j@RestControllerpublic class AuthController extends BaseController&#123; @Autowired private Producer producer; /** * 图片验证码 */ @GetMapping(&quot;/captcha&quot;) public Result captcha(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String code = producer.createText(); String key = UUID.randomUUID().toString(); BufferedImage image = producer.createImage(code); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ImageIO.write(image, &quot;jpg&quot;, outputStream); BASE64Encoder encoder = new BASE64Encoder(); String str = &quot;data:image/jpeg;base64,&quot;; String base64Img = str + encoder.encode(outputStream.toByteArray()); // 存储到redis中 redisUtil.hset(Const.captcha_KEY, key, code, 120); log.info(&quot;验证码 -- &#123;&#125; - &#123;&#125;&quot;, key, code); return Result.succ( MapUtil.builder() .put(&quot;token&quot;, key) .put(&quot;base64Img&quot;, base64Img) .build() ); &#125;&#125; 因为前后端分离，我们禁用了session，所以我们把验证码放在了redis中，使用一个随机字符串作为key，并传送到前端，前端再把随机字符串和用户输入的验证码提交上来，这样我们就可以通过随机字符串获取到保存的验证码和用户的验证码进行比较了是否正确了。然后因为图片验证码的方式，所以我们进行了encode，把图片进行了base64编码，这样前端就可以显示图片了。 而前端的处理，我们之前是使用了mockjs进行随机生成数据的，现在后端有接口之后，我们只需要在main.js中去掉mockjs的引入即可，这样前端就可以访问后端的接口而不被mock拦截了。 验证码认证过滤器图片验证码进行认证验证码是否正确。 CaptchaFilter 12345678910111213141516171819202122232425262728293031323334353637383940/** * 图片验证码校验过滤器，在登录过滤器前 */@Slf4j@Componentpublic class CaptchaFilter extends OncePerRequestFilter &#123; private final String loginUrl = &quot;/login&quot;; @Autowired RedisUtil redisUtil; @Autowired LoginFailureHandler loginFailureHandler; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String url = request.getRequestURI(); if (loginUrl.equals(url) &amp;&amp; request.getMethod().equals(&quot;POST&quot;)) &#123; log.info(&quot;获取到login链接，正在校验验证码 -- &quot; + url); try &#123; validate(request); &#125; catch (CaptchaException e) &#123; log.info(e.getMessage()); // 交给登录失败处理器处理 loginFailureHandler.onAuthenticationFailure(request, response, e); &#125; &#125; filterChain.doFilter(request, response); &#125; private void validate(HttpServletRequest request) &#123; String code = request.getParameter(&quot;code&quot;); String token = request.getParameter(&quot;token&quot;); if (StringUtils.isBlank(code) || StringUtils.isBlank(token)) &#123; throw new CaptchaException(&quot;验证码不能为空&quot;); &#125; if(!code.equals(redisUtil.hget(Const.captcha_KEY, token))) &#123; throw new CaptchaException(&quot;验证码不正确&quot;); &#125; // 一次性使用 redisUtil.hdel(Const.captcha_KEY, token); &#125;&#125; 上面代码中，因为验证码需要存储，所以添加了RedisUtil工具类，这个工具类代码我们就不贴出来了。 com.markerhub.util.RedisUtil 然后验证码出错的时候我们返回异常信息，这是一个认证异常，所以我们自定了一个CaptchaException： com.javacat.common.exception.CaptchaException 12345public class CaptchaException extends AuthenticationException &#123; public CaptchaException(String msg) &#123; super(msg); &#125;&#125; com.markerhub.common.lang.Const 123public class Const &#123; public static final String captcha_KEY = &quot;captcha&quot;;&#125; 然后认证失败的话，我们之前说过，登录失败的时候交给AuthenticationFailureHandler，所以我们自定义了LoginFailureHandler com.markerhub.security.LoginFailureHandler 1234567891011121314@Componentpublic class LoginFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); ServletOutputStream outputStream = response.getOutputStream(); Result result = Result.fail( &quot;Bad credentials&quot;.equals(exception.getMessage()) ? &quot;用户名或密码不正确&quot; : exception.getMessage() ); outputStream.write(JSONUtil.toJsonStr(result).getBytes(&quot;UTF-8&quot;)); outputStream.flush(); outputStream.close(); &#125;&#125; 其实主要就是获取异常的消息，然后封装到Result，最后转成json返回给前端而已哈。然后我们配置SecurityConfig com.markerhub.config.SecurityConfig 123456789101112131415161718192021222324252627282930313233343536373839@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired LoginFailureHandler loginFailureHandler; @Autowired CaptchaFilter captchaFilter; public static final String[] URL_WHITELIST = &#123; &quot;/webjars/**&quot;, &quot;/favicon.ico&quot;,&quot;/captcha&quot;, &quot;/login&quot;, &quot;/logout&quot;, &#125;; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and().csrf().disable() .formLogin() .failureHandler(loginFailureHandler) .and() .authorizeRequests() .antMatchers(URL_WHITELIST).permitAll() //白名单 .anyRequest().authenticated() // 不会创建 session .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .addFilterBefore(captchaFilter, UsernamePasswordAuthenticationFilter.class) // 登录验证码校验过滤器 ; &#125;&#125; 首先formLogin我们定义了表单登录提交的方式以及定义了登录失败的处理器，后面我们还要定义登录成功的处理器的。然后authorizeRequests我们除了白名单的链接之外其他请求都会被拦截。再然后就是禁用session，最后是设定验证码过滤器在登录过滤器之前。然后我们打开前端的&#x2F;login，发现出现了跨域的问题，后面我处理，我们先用postman调试接口。 可以看到，我们的随机码token和base64Img编码都是正常的。控制台上看到我们的验证是2yyxm： 然后我们尝试登录，因为之前我们已经设置了用户名密码为user&#x2F;111111，所以我们提交表单的时候再带上我们的token和验证码。 这时候我们就可以去提交表单了吗，其实还不可以，为啥？因为就算我们登录成功，security默认跳转到&#x2F;链接，但是又会因为没有权限访问&#x2F;，所有又会教你去登录，所以我们必须取消原先默认的登录成功之后的操作，根据我们之前分析的流程，登录成功之后会走AuthenticationSuccessHandler，因此在登录之前，我们先去自定义这个登录成功操作类： com.markerhub.security.LoginSuccessHandler 1234567891011121314151617181920@Componentpublic class LoginSuccessHandler implements AuthenticationSuccessHandler &#123; @Autowired JwtUtils jwtUtils; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); ServletOutputStream outputStream = response.getOutputStream(); // 生成jwt返回 String jwt = jwtUtils.generateToken(authentication.getName()); response.setHeader(jwtUtils.getHeader(), jwt); Result result = Result.succ(&quot;&quot;); outputStream.write(JSONUtil.toJsonStr(result).getBytes(&quot;UTF-8&quot;)); outputStream.flush(); outputStream.close(); &#125;&#125; 登录成功之后我们利用用户名生成jwt，jwtUtils这个工具类我就不贴代码了哈，去看我们项目源码，然后把jwt作为请求头返回回去，名称就叫Authorization哈。我们需要在配置文件中配置一些jwt的一些密钥信息： application.yml 1234567markerhub: jwt: # 加密秘钥 secret: f4e2e52034348f86b67cde581c0f9eb5 # token有效时长，7天，单位秒 expire: 604800 header: Authorization 然后我们再security配置中添加上登录成功之后的操作类： com.markerhub.config.SecurityConfig 12345678@AutowiredLoginSuccessHandler loginSuccessHandler;...# configure代码：http.cors().and().csrf().disable() .formLogin() .failureHandler(loginFailureHandler) .successHandler(loginSuccessHandler) 然后我们去postman的进行我们的登录测试： 上面我们可以看到，我们已经可以登录成功了。然后去结果的请求头中查看jwt： 搞定，登录成功啦，验证码也正常验证了。 身份认证 - 1登录成功之后前端就可以获取到了jwt的信息，前端中我们是保存在了store中，同时也保存在了localStorage中，然后每次axios请求之前，我们都会添加上我们的请求头信息，可以回顾一下： 前端项目的axios.js 所以后端进行用户身份识别的时候，我们需要通过请求头中获取jwt，然后解析出我们的用户名，这样我们就可以知道是谁在访问我们的接口啦，然后判断用户是否有权限等操作。 那么我们自定义一个过滤器用来进行识别jwt。 JWTAuthenticationFilter 12345678910111213141516171819202122232425262728293031323334@Slf4jpublic class JWTAuthenticationFilter extends BasicAuthenticationFilter &#123; @Autowired JwtUtils jwtUtils; @Autowired RedisUtil redisUtil; @Autowired SysUserService sysUserService; public JWTAuthenticationFilter(AuthenticationManager authenticationManager) &#123; super(authenticationManager); &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; log.info(&quot;jwt 校验 filter&quot;); String jwt = request.getHeader(jwtUtils.getHeader()); if (StrUtil.isBlankOrUndefined(jwt)) &#123; chain.doFilter(request, response); return; &#125; Claims claim = jwtUtils.getClaimByToken(jwt); if (claim == null) &#123; throw new JwtException(&quot;token异常！&quot;); &#125; if (jwtUtils.isTokenExpired(claim.getExpiration())) &#123; throw new JwtException(&quot;token已过期&quot;); &#125; String username = claim.getSubject(); log.info(&quot;用户-&#123;&#125;，正在登陆！&quot;, username); UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(username, null, new TreeSet&lt;&gt;()); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); chain.doFilter(request, response); &#125;&#125; 上面的逻辑也很简单，正如我前面说到的，获取到用户名之后我们直接把封装成UsernamePasswordAuthenticationToken，之后交给SecurityContextHolder参数传递authentication对象，这样后续security就能获取到当前登录的用户信息了，也就完成了用户认证。当认证失败的时候会进入AuthenticationEntryPoint，于是我们自定义认证失败返回的数据： com.markerhub.security.JwtAuthenticationEntryPoint 1234567891011121314151617181920/** * 定义认证失败处理类 */@Slf4j@Componentpublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException &#123; log.info(&quot;认证失败！未登录！&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); ServletOutputStream outputStream = response.getOutputStream(); Result result = Result.fail(&quot;请先登录！&quot;); outputStream.write(JSONUtil.toJsonStr(result).getBytes(&quot;UTF-8&quot;)); outputStream.flush(); outputStream.close(); &#125;&#125; 不过是啥原因，认证失败，我们就要求重新登录，所以返回的信息直接明了“请先登录！”哈哈。然后我们把认证过滤器和认证失败入口配置到SecurityConfig中： com.markerhub.config.SecurityConfig 1234567891011@BeanJWTAuthenticationFilter jwtAuthenticationFilter() throws Exception &#123; JWTAuthenticationFilter filter = new JWTAuthenticationFilter(authenticationManager()); return filter;&#125;.and().exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and().addFilter(jwtAuthenticationFilter()).addFilterBefore(captchaFilter, UsernamePasswordAuthenticationFilter.class) // 登录验证码校验过滤器 这样携带jwt请求头我们就可以正常访问我们的接口了。 身份认证 - 2之前我们的用户名密码配置在配置文件中的，而且密码也用的是明文，这明显不符合我们的要求，我们的用户必须是存储在数据库中，密码也是得经过加密的。所以我们先来解决这个问题，然后再去弄授权。 首先来插入一条用户数据，但这里有个问题，就是我们的密码怎么生成？密码怎么来的？这里我们使用Security内置了的BCryptPasswordEncoder，里面就有生成和匹配密码是否正确的方法，也就是加密和验证策略。因此我们再SecurityConfig中进行配置： com.markerhub.config.SecurityConfig 1234@BeanBCryptPasswordEncoder bCryptPasswordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 这样系统就会使用我们找个新的密码策略进行匹配密码是否正常了。之前我们配置文件配置的用户名密码去掉： application.yml 1234# security:# user:# name: user# password: 111111 ok，我们先使用BCryptPasswordEncoder给我们生成一个密码，给数据库添加一条数据先，我们再TestController中注入BCryptPasswordEncoder，然后使用encode进行密码加密，对了，记得在SecurityConfig中吧&#x2F;test&#x2F;**添加白名单哈，不然访问会提示你登录！！ com.markerhub.controller.TestController 12345678910111213141516@AutowiredBCryptPasswordEncoder bCryptPasswordEncoder;@GetMapping(&quot;/test/pass&quot;)public Result passEncode() &#123; // 密码加密 String pass = bCryptPasswordEncoder.encode(&quot;111111&quot;); // 密码验证 boolean matches = bCryptPasswordEncoder.matches(&quot;111111&quot;, pass); return Result.succ(MapUtil.builder() .put(&quot;pass&quot;, pass) .put(&quot;marches&quot;, matches) .build() );&#125; 可以看到我密码是111111，加密以及验证的结果如下：$2a$10$R7zegeWzOXPw871CmNuJ6upC0v8D373GuLuTw8jn6NET4BkPRZfgK data中的那一串字符串就是我们的密码了，可以看到marches也是true，说明密码验证也是正确的，我们添加到我们数据库sys_user表中： 1INSERT INTO `vueadmin`.`sys_user` (`id`, `username`, `password`, `avatar`, `email`, `city`, `created`, `updated`, `last_login`, `statu`) VALUES (&#x27;1&#x27;, &#x27;admin&#x27;, &#x27;$2a$10$R7zegeWzOXPw871CmNuJ6upC0v8D373GuLuTw8jn6NET4BkPRZfgK&#x27;, &#x27;https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg&#x27;, &#x27;123@qq.com&#x27;, &#x27;广州&#x27;, &#x27;2021-01-12 22:13:53&#x27;, &#x27;2021-01-16 16:57:32&#x27;, &#x27;2020-12-30 08:38:37&#x27;, &#x27;1&#x27;); 后面我们就可以使用admin&#x2F;111111登录我们的系统哈。但是先我们登录过程系统不是从我们数据库中获取数据的，因此，我们需要重新定义这个查用户数据的过程，我们需要重写UserDetailsService接口。 com.markerhub.security.UserDetailsServiceImpl 123456789101112131415@Slf4j@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired SysUserService sysUserService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser sysUser = sysUserService.getByUsername(username); if (sysUser == null) &#123; throw new UsernameNotFoundException(&quot;用户名或密码不正确!&quot;); &#125; return new AccountUser(sysUser.getId(), sysUser.getUsername(), sysUser.getPassword(), new TreeSet&lt;&gt;()); &#125;&#125; 因为security在认证用户身份的时候会调用UserDetailsService.loadUserByUsername()方法，因此我们重写了之后security就可以根据我们的流程去查库获取用户了。然后我们把UserDetailsServiceImpl配置到SecurityConfig中： com.markerhub.config.SecurityConfig 123456@AutowiredUserDetailsServiceImpl userDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService);&#125; 然后上面UserDetailsService.loadUserByUsername()默认返回的UserDetails，我们自定义了AccountUser去重写了UserDetails，这也是为了后面我们可能会调整用户的一些数据等。 com.markerhub.security.AccountUser 123456789101112131415161718192021222324252627282930public class AccountUser implements UserDetails &#123; private Long userId; private String password; private final String username; private final Collection&lt;? extends GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; public AccountUser(Long userId, String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(userId, username, password, true, true, true, true, authorities); &#125; public AccountUser(Long userId, String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; Assert.isTrue(username != null &amp;&amp; !&quot;&quot;.equals(username) &amp;&amp; password != null, &quot;Cannot pass null or empty values to constructor&quot;); this.userId = userId; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = authorities; &#125; public Long getUserId() &#123; return userId; &#125; ... &#125; 其实数据基本没变，我就添加多了一个用户的id而已。ok，万事俱备，我们再次尝试去登录，看能不能登录成功。 1、获取验证码： 2、从控制台获取到对应的验证码 3、提交登录表单 4、登录成功，并在请求头中获取到了Authorization，也就是JWT。完美！！ 解决授权然后关于权限部分，也是security的重要功能，当用户认证成功之后，我们就知道谁在访问系统接口，这是又有一个问题，就是这个用户有没有权限来访问我们这个接口呢，要解决这个问题，我们需要知道用户有哪些权限，哪些角色，这样security才能我们做权限判断。 之前我们已经定义及几张表，用户、角色、菜单、以及一些关联表，一般当权限粒度比较细的时候，我们都通过判断用户有没有此菜单或操作的权限，而不是通过角色判断，而用户和菜单是不直接做关联的，是通过用户拥有哪些角色，然后角色拥有哪些菜单权限这样来获得的。 问题1：我们是在哪里赋予用户权限的？有两个地方： 1、用户登录，调用调用UserDetailsService.loadUserByUsername()方法时候可以返回用户的权限信息。 2、接口调用进行身份认证过滤器时候JWTAuthenticationFilter，需要返回用户权限信息 问题2：在哪里决定什么接口需要什么权限？ Security内置的权限注解： @PreAuthorize：方法执行前进行权限检查 @PostAuthorize：方法执行后进行权限检查 @Secured：类似于 @PreAuthorize 可以在Controller的方法前添加这些注解表示接口需要什么权限。 比如需要Admin角色权限： 1@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;) 比如需要添加管理员的操作权限 1@PreAuthorize(&quot;hasAuthority(&#x27;sys:user:save&#x27;)&quot;) ok，我们再来整体梳理一下授权、验证权限的流程： 用户登录或者调用接口时候识别到用户，并获取到用户的权限信息 注解标识Controller中的方法需要的权限或角色 Security通过FilterSecurityInterceptor匹配URI和权限是否匹配 有权限则可以访问接口，当无权限的时候返回异常交给AccessDeniedHandler操作类处理 ok，流程清晰之后我们就开始我们的编码： UserDetailsServiceImpl 1234567891011@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; ... return new AccountUser(sysUser.getId(), sysUser.getUsername(), sysUser.getPassword(), getUserAuthority(sysUser.getId()));&#125;public List&lt;GrantedAuthority&gt; getUserAuthority(Long userId) &#123; // 通过内置的工具类，把权限字符串封装成GrantedAuthority列表 return AuthorityUtils.commaSeparatedStringToAuthorityList( sysUserService.getUserAuthorityInfo(userId) );&#125; com.markerhub.security.JWTAuthenticationFilter 1234SysUser sysUser = sysUserService.getByUsername(username);List&lt;GrantedAuthority&gt; grantedAuthorities = userDetailsService.getUserAuthority(sysUser.getId());UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(username, null, grantedAuthorities); 代码中的com.markerhub.service.impl.SysUserServiceImpl#getUserAuthorityInfo是重点： 1234567891011121314151617181920212223242526272829303132@Slf4j@Servicepublic class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123; ... @Override public String getUserAuthorityInfo(Long userId) &#123; SysUser sysUser = this.getById(userId); String authority = null; if (redisUtil.hasKey(&quot;GrantedAuthority:&quot; + sysUser.getUsername())) &#123; // 优先从缓存获取 authority = (String)redisUtil.get(&quot;GrantedAuthority:&quot; + sysUser.getUsername()); &#125; else &#123; List&lt;SysRole&gt; roles = sysRoleService.list(new QueryWrapper&lt;SysRole&gt;() .inSql(&quot;id&quot;, &quot;select role_id from sys_user_role where user_id = &quot; + userId)); List&lt;Long&gt; menuIds = sysUserMapper.getNavMenuIds(userId); List&lt;SysMenu&gt; menus = sysMenuService.listByIds(menuIds); String roleNames = roles.stream().map(r -&gt; &quot;ROLE_&quot; + r.getCode()).collect(Collectors.joining(&quot;,&quot;)); String permNames = menus.stream().map(m -&gt; m.getPerms()).collect(Collectors.joining(&quot;,&quot;)); authority = roleNames.concat(&quot;,&quot;).concat(permNames); log.info(&quot;用户ID - &#123;&#125; ---拥有的权限：&#123;&#125;&quot;, userId, authority); redisUtil.set(&quot;GrantedAuthority:&quot; + sysUser.getUsername(), authority, 60*60); &#125; return authority; &#125;&#125; 可以看到，我通过用户id分别获取到用户的角色信息和菜单信息，然后通过逗号链接起来，因为角色信息我们需要这样“ROLE_”+角色，所以才有了上面的写法：比如用户拥有Admin角色和添加用户权限，则最后的字符串是：ROLE_admin,syssave。 同时为了避免多次查库，我做了一层缓存，这里理解应该不难。 然后sysUserMapper.getNavMenuIds(userId)因为要查询数据库，具体SQL如下： com.markerhub.mapper.SysUserMapper#getNavMenuIds 123456789&lt;select id=&quot;getNavMenuIds&quot; resultType=&quot;java.lang.Long&quot;&gt; SELECT DISTINCT rm.menu_id FROM sys_user_role ur LEFT JOIN `sys_role_menu` rm ON rm.role_id = ur.role_id WHERE ur.user_id = #&#123;userId&#125;;&lt;/select&gt; 上面表示通过用户ID获取用户关联的菜单的id，因此需要用到两个中间表的关联了。ok，这样我们就赋予了用户角色和操作权限了。后面我们只需要在Controller添加上具体注解表示需要的权限，Security就会自动帮我们自动完成权限校验了。 权限缓存因为上面我在获取用户权限那里添加了个缓存，这时候问题来了，就是权限缓存的实时更新问题，比如当后台更新某个管理员的权限角色信息的时候如果权限缓存信息没有实时更新，就会出现操作无效的问题，那么我们现在点定义几个方法，用于清除某个用户或角色或者某个菜单的权限的方法： com.markerhub.service.impl.SysUserServiceImpl 1234567891011121314151617181920212223// 删除某个用户的权限信息@Overridepublic void clearUserAuthorityInfo(String username) &#123; redisUtil.del(&quot;GrantedAuthority:&quot; + username);&#125;// 删除所有与该角色关联的用户的权限信息@Overridepublic void clearUserAuthorityInfoByRoleId(Long roleId) &#123; List&lt;SysUser&gt; sysUsers = this.list(new QueryWrapper&lt;SysUser&gt;() .inSql(&quot;id&quot;, &quot;select user_id from sys_user_role where role_id = &quot; + roleId) ); sysUsers.forEach(u -&gt; &#123; this.clearUserAuthorityInfo(u.getUsername()); &#125;);&#125;// 删除所有与该菜单关联的所有用户的权限信息@Overridepublic void clearUserAuthorityInfoByMenuId(Long menuId) &#123; List&lt;SysUser&gt; sysUsers = sysUserMapper.listByMenuId(menuId); sysUsers.forEach(u -&gt; &#123; this.clearUserAuthorityInfo(u.getUsername()); &#125;);&#125; 上面最后一个方法查到了与菜单关联的所有用户的，具体sql如下： com.markerhub.mapper.SysUserMapper#listByMenuId 1234567891011&lt;select id=&quot;listByMenuId&quot; resultType=&quot;com.javacat.entity.SysUser&quot;&gt; SELECT DISTINCT su.* FROM sys_user_role ur LEFT JOIN `sys_role_menu` rm ON rm.role_id = ur.role_id LEFT JOIN `sys_user` su ON su.id = ur.user_id WHERE rm.menu_id = #&#123;menuId&#125;;&lt;/select&gt; 有了这几个方法之后，在哪里调用？这就简单了，在更新、删除角色权限、更新、删除菜单的时候调用，虽然我们现在还没写到这几个方法，后续我们再写增删改查的时候记得加上就行啦。 退出数据返回jwt -username token - 随机码 - redis com.markerhub.security.JwtLogoutSuccessHandler 123456789101112131415161718@Componentpublic class JwtLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Autowired JwtUtils jwtUtils; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; if (authentication != null) &#123; new SecurityContextLogoutHandler().logout(request, response, authentication); &#125; response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setHeader(jwtUtils.getHeader(), &quot;&quot;); ServletOutputStream out = response.getOutputStream(); Result result = Result.succ(&quot;&quot;); out.write(JSONUtil.toJsonStr(result).getBytes(&quot;UTF-8&quot;)); out.flush(); out.close(); &#125; 无权限数据返回 com.markerhub.security.JwtAccessDeniedHandler 1234567891011121314151617@Slf4j@Componentpublic class JwtAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;// response.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedException.getMessage()); log.info(&quot;权限不够！！&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setStatus(HttpServletResponse.SC_FORBIDDEN); ServletOutputStream outputStream = response.getOutputStream(); Result result = Result.fail(accessDeniedException.getMessage()); outputStream.write(JSONUtil.toJsonStr(result).getBytes(&quot;UTF-8&quot;)); outputStream.flush(); outputStream.close(); &#125;&#125; 致此，SpringSecurity就已经完美整合到了我们的项目中来了。 7. 解决跨域问题上面的调试我们都是使用的postman，如果我们和前端进行对接的时候，会出现跨域的问题，如何解决？ com.markerhub.config.CorsConfig 123456789101112131415161718192021222324252627@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addExposedHeader(&quot;Authorization&quot;); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); return new CorsFilter(source); &#125; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;)// .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) .maxAge(3600); &#125;&#125; 8. 前后端对接的问题因为我们之前开发前端的时候，我们都是使用mockjs返回随机数据的，一般来说问题不会很大，我就怕有些同学再去掉mock之后，和后端对接却显示不出数据，这就尴尬了。这时候我建议你去看我的开发视频哈。 后面因为都是接口的增删改查，难度其实不是特别大，所以大部分时候我都会直接贴代码，如果想看手把手教程，还是去看我的教学视频哈，B站搜索MarkerHub就可以啦，公众号也是叫MarkerHub。 9. 菜单接口开发我们先来开发菜单的接口，因为这3个表：用户表、角色表、菜单表，才有菜单表是不需要通过其他表来获取信息的。比如用户需要关联角色，角色需要关联菜单，而菜单不需要主动关联其他表。因此菜单表的增删改查是最简单的。 再回到我们的前端项目，登录完成之后我们通过JWT获取项目的导航菜单和权限，那么接下来我们就先编写这个接口。 获取菜单导航和权限的链接是&#x2F;sys&#x2F;menu&#x2F;nav，然后我们的菜单导航的json数据应该是这样的： 12345678&#123; title: &#x27;角色管理&#x27;, icon: &#x27;el-icon-rank&#x27;, path: &#x27;/sys/roles&#x27;, name: &#x27;SysRoles&#x27;, component: &#x27;sys/Role&#x27;, children: []&#125; 然后返回的权限数据应该是个数组： 1[&quot;sys:menu:list&quot;,&quot;sys:menu:save&quot;,&quot;sys:user:list&quot;...] 注意导航菜单那里有个children，也就是子菜单，是个树形结构，因为我们的菜单可能这样： 1系统管理 - 菜单管理 - 添加菜单 可以看到这就已经有3级了菜单了。所以在打代码时候要注意这个关系的关联。我们的SysMenu实体类中有个parentId，但是没有children，因此我们可以在SysMenu中添加一个children，当然了其实不添加也可以，因为我们也需要一个dto，这样我们才能按照上面json数据格式返回。 我们还是来添加一个children吧： com.markerhub.entity.SysMenu 1234567@Data@EqualsAndHashCode(callSuper = true)public class SysMenu extends BaseEntity &#123; ... @TableField(exist = false) private List&lt;SysMenu&gt; children = new ArrayList&lt;&gt;();&#125; 然后我们也先来定义一个SysMenuDto吧，知道要返回什么样的数据，我们就只需要去填充数据就好了 com.markerhub.common.dto.SysMenuDto 12345678910@Datapublic class SysMenuDto implements Serializable &#123; private Long id; private String title; private String icon; private String path; private String name; private String component; List&lt;SysMenuDto&gt; children = new ArrayList&lt;&gt;();&#125; ok，我们来开始我们的编码 com.markerhub.controller.SysMenuController#nav 123456789101112131415161718/** * 获取当前用户的菜单栏以及权限 */@GetMapping(&quot;/nav&quot;)public Result nav(Principal principal) &#123; String username = principal.getName(); SysUser sysUser = sysUserService.getByUsername(username); // ROLE_Admin,sys:user:save String[] authoritys = StringUtils.tokenizeToStringArray( sysUserService.getUserAuthorityInfo(sysUser.getId()) , &quot;,&quot;); return Result.succ( MapUtil.builder() .put(&quot;nav&quot;, sysMenuService.getcurrentUserNav()) .put(&quot;authoritys&quot;, authoritys) .map() );&#125; 方法中Principal principal表示注入当前用户的信息，getName就可以获取当当前用户的用户名了。sysUserService.getUserAuthorityInfo方法我们之前已经说过了，就在我们登录完成或者身份认证时候需要返回用户权限时候编写的。然后通过StringUtils.tokenizeToStringArray把字符串通过逗号分开组成数组形式。重点在与sysMenuService.getcurrentUserNav，获取当前用户的菜单导航， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Servicepublic class SysMenuServiceImpl extends ServiceImpl&lt;SysMenuMapper, SysMenu&gt; implements SysMenuService &#123; ... /** * 获取当前用户菜单导航 */ @Override public List&lt;SysMenuDto&gt; getcurrentUserNav() &#123; String username = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); SysUser sysUser = sysUserService.getByUsername(username); // 获取用户的所有菜单 List&lt;Long&gt; menuIds = sysUserMapper.getNavMenuIds(sysUser.getId()); List&lt;SysMenu&gt; menus = buildTreeMenu(this.listByIds(menuIds)); return convert(menus); &#125; /** * 把list转成树形结构的数据 */ private List&lt;SysMenu&gt; buildTreeMenu(List&lt;SysMenu&gt; menus)&#123; List&lt;SysMenu&gt; finalMenus = new ArrayList&lt;&gt;(); for (SysMenu menu : menus) &#123; // 先寻找各自的孩子 for (SysMenu e : menus) &#123; if (e.getParentId() == menu.getId()) &#123; menu.getChildren().add(e); &#125; &#125; // 提取出父节点 if (menu.getParentId() == 0L) &#123; finalMenus.add(menu); &#125; &#125; return finalMenus; &#125; /** * menu转menuDto */ private List&lt;SysMenuDto&gt; convert(List&lt;SysMenu&gt; menus) &#123; List&lt;SysMenuDto&gt; menuDtos = new ArrayList&lt;&gt;(); menus.forEach(m -&gt; &#123; SysMenuDto dto = new SysMenuDto(); dto.setId(m.getId()); dto.setName(m.getPerms()); dto.setTitle(m.getName()); dto.setComponent(m.getComponent()); dto.setIcon(m.getIcon()); dto.setPath(m.getPath()); if (m.getChildren().size() &gt; 0) &#123; dto.setChildren(convert(m.getChildren())); &#125; menuDtos.add(dto); &#125;); return menuDtos; &#125;&#125; 接口中sysUserMapper.getNavMenuIds我们之前就已经写过的了，通过用户id获取菜单的id，然后后面就是转成树形结构，buildTreeMenu方法的思想很简单，我们现实把菜单循环，让所有菜单先找到各自的子节点，然后我们在把最顶级的菜单获取出来，这样顶级下面有二级，二级也有自己的三级。最后就是convert把menu转成menuDto。这个比较简单，就不说了。好了，导航菜单已经开发完毕，我们来写菜单管理的增删改查，因为菜单列表也是个树形接口，这次我们就不是获取当前用户的菜单列表的，而是所有菜单然后组成树形结构，一样的思想，数据不一样而已。 com.markerhub.controller.SysMenuController 123456789101112131415161718192021222324252627282930313233343536373839404142434445@GetMapping(&quot;/info/&#123;id&#125;&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:list&#x27;)&quot;)public Result info(@PathVariable(&quot;id&quot;) Long id) &#123; return Result.succ(sysMenuService.getById(id));&#125;@GetMapping(&quot;/list&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:list&#x27;)&quot;)public Result list() &#123; List&lt;SysMenu&gt; menus = sysMenuService.tree(); return Result.succ(menus);&#125;@PostMapping(&quot;/save&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:save&#x27;)&quot;)public Result save(@Validated @RequestBody SysMenu sysMenu) &#123; sysMenu.setCreated(LocalDateTime.now()); sysMenu.setStatu(Const.STATUS_ON); sysMenuService.save(sysMenu); return Result.succ(sysMenu);&#125;@PostMapping(&quot;/update&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:update&#x27;)&quot;)public Result update(@Validated @RequestBody SysMenu sysMenu) &#123; sysMenu.setUpdated(LocalDateTime.now()); sysMenuService.updateById(sysMenu); // 清除所有与该菜单相关的权限缓存 sysUserService.clearUserAuthorityInfoByMenuId(sysMenu.getId()); return Result.succ(sysMenu);&#125;@Transactional@PostMapping(&quot;/delete/&#123;id&#125;&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:delete&#x27;)&quot;)public Result delete(@PathVariable Long id) &#123; int count = sysMenuService.count(new QueryWrapper&lt;SysMenu&gt;().eq(&quot;parent_id&quot;, id)); if (count &gt; 0) &#123; return Result.fail(&quot;请先删除子菜单&quot;); &#125; // 先清除所有与该菜单相关的权限缓存 sysUserService.clearUserAuthorityInfoByMenuId(id); sysMenuService.removeById(id); // 同步删除 sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenu&gt;().eq(&quot;menu_id&quot;, id)); return Result.succ(&quot;&quot;);&#125; 删除、更新菜单的时候记得调用根据菜单id清楚用户权限缓存信息的方法哈。然后每个方法前都会带有权限注解：@PreAuthorize(“hasAuthority(‘sysdelete’)”)，这就要求用户有特定的操作权限才能调用这个接口，sysdelete这些数据不是乱写出来的，我们必须和数据库的数据保持一致才行，然后component字段，也是要和前端进行沟通，因为这个是链接到的前端的组件页面。有了增删改查，我们就去先添加我们的所有的菜单权限数据先。效果如下： 基本上线填好所有菜单的列表和增删改查操作权限，就ok。 10. 角色接口开发角色的增删改查其实也简单，而且字段这么少，基本上吧菜单的增删改查复制过来，然后把menu改成role，在调整一下就差不多啦。然后有个角色关联菜单的操作，这个我们等下讲讲，先来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@RestController@RequestMapping(&quot;/sys/role&quot;)public class SysRoleController extends BaseController &#123; @GetMapping(&quot;/info/&#123;id&#125;&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:list&#x27;)&quot;) public Result info(@PathVariable Long id) &#123; SysRole role = sysRoleService.getById(id); List&lt;SysRoleMenu&gt; roleMenus = sysRoleMenuService.list(new QueryWrapper&lt;SysRoleMenu&gt;().eq(&quot;role_id&quot;, id)); List&lt;Long&gt; menuIds = roleMenus.stream().map(p -&gt; p.getMenuId()).collect(Collectors.toList()); role.setMenuIds(menuIds); return Result.succ(role); &#125; @GetMapping(&quot;/list&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:list&#x27;)&quot;) public Result list(String name) &#123; Page&lt;SysRole&gt; roles = sysRoleService.page(getPage(), new QueryWrapper&lt;SysRole&gt;() .like(StrUtil.isNotBlank(name), &quot;name&quot;, name) ); return Result.succ(roles); &#125; @PostMapping(&quot;/save&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:save&#x27;)&quot;) public Result save(@Validated @RequestBody SysRole sysRole) &#123; sysRole.setCreated(LocalDateTime.now()); sysRole.setStatu(Const.STATUS_ON); sysRoleService.save(sysRole); return Result.succ(sysRole); &#125; @PostMapping(&quot;/update&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:update&#x27;)&quot;) public Result update(@Validated @RequestBody SysRole sysRole) &#123; sysRole.setUpdated(LocalDateTime.now()); sysRoleService.updateById(sysRole); return Result.succ(sysRole); &#125; @Transactional @PostMapping(&quot;/delete&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:delete&#x27;)&quot;) public Result delete(@RequestBody Long[] ids)&#123; sysRoleService.removeByIds(Arrays.asList(ids)); // 同步删除 sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenu&gt;().in(&quot;role_id&quot;, ids)); sysUserRoleService.remove(new QueryWrapper&lt;SysUserRole&gt;().in(&quot;role_id&quot;, ids)); return Result.succ(&quot;&quot;); &#125; @Transactional @PostMapping(&quot;/perm/&#123;roleId&#125;&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:role:perm&#x27;)&quot;) public Result perm(@PathVariable Long roleId, @RequestBody Long[] menuIds) &#123; List&lt;SysRoleMenu&gt; sysRoleMenus = new ArrayList&lt;&gt;(); Arrays.stream(menuIds).forEach(menuId -&gt; &#123; SysRoleMenu roleMenu = new SysRoleMenu(); roleMenu.setMenuId(menuId); roleMenu.setRoleId(roleId); sysRoleMenus.add(roleMenu); &#125;); sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenu&gt;().eq(&quot;role_id&quot;, roleId)); sysRoleMenuService.saveBatch(sysRoleMenus); // 清除所有用户的权限缓存信息 sysUserService.clearUserAuthorityInfoByRoleId(roleId); return Result.succ(menuIds); &#125;&#125; 上面方法中： info方法 获取角色信息的方法，因为我们不仅仅在编辑角色时候会用到这个方法，在回显角色关联菜单的时候也需要被调用，因此我们需要把角色关联的所有的菜单的id也一并查询出来，也就是分配权限的操作。对应到前端就是这样的，点击分配权限，会弹出出所有的菜单列表，然后根据角色已经关联的菜单的id回显勾选上已经关联过的。效果如下： 然后点击保存分配权限的时候，我们需要把角色的id和所有勾选上的菜单id的数组一起传过来，所以才有了controller中的这样的写法： 1234@PreAuthorize(&quot;hasAuthority(&#x27;sys:role:perm&#x27;)&quot;)public Result perm(@PathVariable Long roleId, @RequestBody Long[] menuIds) &#123; ...代码上面贴出来&#125; 可以看到，因为@RequestBody，我们知道menuIds是否安装body里面的，这个需要注意，对应到的前端写法就是这样： ok，角色管理就讲到这里了，其他增删改查自己看下代码，不难哈。 11. 用户接口开发用户管理里面有个用户关联角色的分配角色操作，和角色关联菜单的写法差不多的，其他增删改查也复制黏贴改改就好，哈哈。 com.markerhub.controller.SysUserController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 公众号：MarkerHub */@RestController@RequestMapping(&quot;/sys/user&quot;)public class SysUserController extends BaseController &#123; @Autowired PasswordEncoder passwordEncoder; @GetMapping(&quot;/info/&#123;id&#125;&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:list&#x27;)&quot;) public Result info(@PathVariable Long id) &#123; SysUser user = sysUserService.getById(id); Assert.notNull(user, &quot;找不到该管理员！&quot;); List&lt;SysRole&gt; roles = sysRoleService.listRolesByUserId(user.getId()); user.setRoles(roles); return Result.succ(user); &#125; /** * 用户自己修改密码 * */ @PostMapping(&quot;/updataPass&quot;) public Result updataPass(@Validated @RequestBody PassDto passDto, Principal principal) &#123; SysUser sysUser = sysUserService.getByUsername(principal.getName()); boolean matches = passwordEncoder.matches(passDto.getCurrentPass(), sysUser.getPassword()); if (!matches) &#123; return Result.fail(&quot;旧密码不正确！&quot;); &#125; sysUser.setPassword(passwordEncoder.encode(passDto.getPassword())); sysUser.setUpdated(LocalDateTime.now()); sysUserService.updateById(sysUser); return Result.succ(null); &#125; /** * 超级管理员重置密码 */ @PostMapping(&quot;/repass&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:repass&#x27;)&quot;) public Result repass(@RequestBody Long userId) &#123; SysUser sysUser = sysUserService.getById(userId); sysUser.setPassword(passwordEncoder.encode(Const.DEFAULT_PASSWORD)); sysUser.setUpdated(LocalDateTime.now()); sysUserService.updateById(sysUser); return Result.succ(null); &#125; @GetMapping(&quot;/list&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:list&#x27;)&quot;) public Result page(String username) &#123; Page&lt;SysUser&gt; users = sysUserService.page(getPage(), new QueryWrapper&lt;SysUser&gt;() .like(StrUtil.isNotBlank(username), &quot;username&quot;, username) ); users.getRecords().forEach(u -&gt; &#123; u.setRoles(sysRoleService.listRolesByUserId(u.getId())); &#125;); return Result.succ(users); &#125; @PostMapping(&quot;/save&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:save&#x27;)&quot;) public Result save(@Validated @RequestBody SysUser sysUser) &#123; sysUser.setCreated(LocalDateTime.now()); sysUser.setStatu(Const.STATUS_ON); // 初始默认密码 sysUser.setPassword(Const.DEFAULT_PASSWORD); if (StrUtil.isBlank(sysUser.getPassword())) &#123; return Result.fail(&quot;密码不能为空&quot;); &#125; String password = passwordEncoder.encode(sysUser.getPassword()); sysUser.setPassword(password); // 默认头像 sysUser.setAvatar(Const.DEFAULT_AVATAR); sysUserService.save(sysUser); return Result.succ(sysUser); &#125; @PostMapping(&quot;/update&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:update&#x27;)&quot;) public Result update(@Validated @RequestBody SysUser sysUser) &#123; sysUser.setUpdated(LocalDateTime.now()); if (StrUtil.isNotBlank(sysUser.getPassword())) &#123; String password = passwordEncoder.encode(sysUser.getPassword()); sysUser.setPassword(password); &#125; sysUserService.updateById(sysUser); return Result.succ(sysUser); &#125; @PostMapping(&quot;/delete&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:delete&#x27;)&quot;) public Result delete(@RequestBody Long[] ids)&#123; sysUserService.removeByIds(Arrays.asList(ids)); sysUserRoleService.remove(new QueryWrapper&lt;SysUserRole&gt;().in(&quot;user_id&quot;, ids)); return Result.succ(&quot;&quot;); &#125; /** * 分配角色 * @return */ @Transactional @PostMapping(&quot;/role/&#123;userId&#125;&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;sys:user:role&#x27;)&quot;) public Result perm(@PathVariable Long userId, @RequestBody Long[] roleIds) &#123; System.out.println(roleIds); List&lt;SysUserRole&gt; userRoles = new ArrayList&lt;&gt;(); Arrays.stream(roleIds).forEach(roleId -&gt; &#123; SysUserRole userRole = new SysUserRole(); userRole.setRoleId(roleId); userRole.setUserId(userId); userRoles.add(userRole); &#125;); sysUserRoleService.remove(new QueryWrapper&lt;SysUserRole&gt;().eq(&quot;user_id&quot;, userId)); sysUserRoleService.saveBatch(userRoles); // 清除权限信息 SysUser sysUser = sysUserService.getById(userId); sysUserService.clearUserAuthorityInfo(sysUser.getUsername()); return Result.succ(roleIds); &#125;&#125; 上面用到一个sysRoleService.listRolesByUserId，通过用户id获取所有关联的角色，用到了中间表，可以写sql，这里我这样写的： com.markerhub.service.impl.SysRoleServiceImpl#listRolesByUserId 123456@Overridepublic List&lt;SysRole&gt; listRolesByUserId(Long userId) &#123; return this.list( new QueryWrapper&lt;SysRole&gt;() .inSql(&quot;id&quot;, &quot;select role_id from sys_user_role where user_id = &quot; + userId));&#125; userId一定要是自己数据库查出来的，千万别让前端传过来啥就直接调用这个方法，不然会可能会被攻击，嘿嘿嘿~最委托就是写完整的sql，而不是这样半个sql的写法。最后效果如下： 12. 项目部署部署项目其实和vueblog的部署是一样的，自己调整一下吧少年，我有写了视频和文档的： 13. 项目总结好了，我们终于又写完了一个项目，希望能让你们学到点东西，这次写的文档有点乱，多多担待，太长了，写着写着就不知道写哪了，哈哈。","categories":[],"tags":[{"name":"VueAdmin后端","slug":"VueAdmin后端","permalink":"http://example.com/tags/VueAdmin%E5%90%8E%E7%AB%AF/"}]},{"title":"Java新人入职——配置环境及安装开发工具","slug":"新人入职配置","date":"2022-10-07T04:00:35.000Z","updated":"2022-10-07T04:01:05.880Z","comments":true,"path":"2022/10/07/新人入职配置/","link":"","permalink":"http://example.com/2022/10/07/%E6%96%B0%E4%BA%BA%E5%85%A5%E8%81%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Java新人入职——配置环境及安装开发工具很多新人对于进入新公司，相关工具的安装和环境变量的设定很苦恼。又苦于没有完整的配置开发环境的资料，我这里写一篇操作步骤的案例， 至少让你能把开发工具安装起来，并实用起来，就不会那么无助了。毕竟连开发环境都弄不好的人，leader对你肯定也不抱希望。废话少说，具体操作如下： 一、首先肯定是安装jdk1、下载jdk版本 这里我的电脑是64位的，用的是Java8 ， jdk版本是jdk1.8.0_92。 下载地址：链接：http://pan.baidu.com/s/1pLht3eF 密码：vgwu 或者我的： https://pan.baidu.com/s/1GBK5E7y7pQNvwNW2Rc-Veg?pwd=ri85 ri85 这里我也提供一个Java7 的版本： 链接：http://pan.baidu.com/s/1hsOlk80 密码：i6k4 2、安装，并设定jdk、jre安装路径 安装路径你可以用默认的，但是一定要记住安装的地址，我一般指定额外的安装路径，比如E盘。如下图： 二、配置环境变量安装好jdk和jre后，就需要配置环境变量 1、安装JDK开发环境 下载网站：http://www.oracle.com/ 2、配置环境变量： 对于Java程序开发而言，主要会使用JDK的两个命令：javac.exe、java.exe。路径：C:\\Java\\jdk 1.7.0 _09\\bin。但是这些命令由于不属于windows自己的命令，所以要想使用，就需要进行路径配置。 单击“计算机-属性-高级系统设置”，单击“环境变量”。在“系统变量”栏下单击“新建”，创建新的系统环境变量。 (1)新建-&gt;变量名”JAVA_HOME”，变量值”C:\\Java\\jdk1.8.0_05”（即JDK的安装路径）(2)编辑-&gt;变量名”Path”，在原变量值的最后面加上“;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin”(3)新建-&gt;变量名“CLASSPATH”,变量值“.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar” 如：JAVA_HOME环境变量的操作如下： 3、确认环境配置是否真确： 在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。 java命令： javac命令： java -version命令： 4、在控制台下验证第一个java程序： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Java&quot;); &#125;&#125; 用记事本编写好，点击“保存”，并存入C盘根目录后，输入javac Test.java和java Test命令，即可运行程序（打印出结果“Hello Java”）。注：这两个命令是在D:\\java\\jdk1.8.0_20\\bin目录下。 程序解析： 首先编写java源代码程序，扩展名.java； 在命令行模式中，输入命令：javac 源文件名.java，对源代码进行编译，生成class字节码文件； 编译完成后，如果没有报错信息，输入命令：java HelloWorld，对class字节码文件进行解释运行,执行时不需要添加.class扩展名。见下图： 注：若在CMD中输入javac test.java命令后，显示’javac’不是内部或外部命令，原因是因为没有提前安装好JDK开发环境或环境变量配置有误。 三、安装开发工具。1、这里我用的是eclipse，具体开发工具用啥，大家看着处理：链接：https://pan.baidu.com/s/1MeNwUsYCtOerLswuMngBEg 密码：rw2u 下载后解压即可用。 2、配置eclipse使用的java版本 打开eclipse，选择Windows——Preferences——Java——Installed JREs 。 设定你的jre环境，具体如下图： 3、配置svn插件 下载地址：链接：http://pan.baidu.com/s/1mifxHMg 密码：aj84 。 下载完后解压，把subSvn&#x2F;eclipse 目录下features、plugins两个目录下的jar文件，分别拷贝到对应的 eclipse 安装目录的对应的features、plugins文件夹目录下。重启eclipse，这样svn插件就弄好了 4、配置tomcat a、下载tomcat，我这里用的是tomcat8 。 下载地址：链接：http://pan.baidu.com/s/1eSPBiee 密码：2883 ， 下载完成后解压到你的指定目录。 b、打开eclipse，选择Windows——Preferences——Server——Runtime Environments。 然后你可以添加一个服务，选择Apache服务，选择你的tomcat版本，具体操作如下图： 选择好后，点击Next c、配置完成后，到eclipse的Server窗口，右键New一个Server。具体如下图： 到这里，tomcat就配置完成了，但是很多人的项目发布目录还是eclipse自带的目录，建议更改到tomcat的webapps目录下。具体操作如下： 这里就配置完成了，保存下即可 5、配置maven a、下载maven，并解压 ，下载地址：链接：http://pan.baidu.com/s/1gf9ufb9 密码：kdh1 https://pan.baidu.com/s/1voiaKRSAyRDihcxJGJQKcg?pwd=8vsx 密码：8vsx b、打开eclipse，选择Windows——Preferences——Maven——Installations——Add ，添加一个maven，选择maven的解压目录。 具体如下图： c、指定settings目录。在当前的maven配置窗口，选择User Settings，并在User Settings路径那里指定你配置的maven的 settings文件。具体如下图： 6、其他配置 （1） 开发工具的编码配置 （2） 注释模板的配置 （3） 快捷键的设置 （4）背景色、字体等设置 （5）快速定位文件位置插件配置、快速打开cmd配置 等等，这些就需各位看官自己去百度啦","categories":[],"tags":[]},{"title":"人脸识别笔记","slug":"人脸识别笔记","date":"2022-09-13T01:59:16.000Z","updated":"2022-09-13T02:07:26.156Z","comments":true,"path":"2022/09/13/人脸识别笔记/","link":"","permalink":"http://example.com/2022/09/13/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"从零玩转人脸识别验证 (yby6.com)","categories":[],"tags":[]},{"title":"MongoDB安装教程","slug":"MongoDB安装教程","date":"2022-09-04T08:36:38.000Z","updated":"2022-09-04T08:37:12.591Z","comments":true,"path":"2022/09/04/MongoDB安装教程/","link":"","permalink":"http://example.com/2022/09/04/MongoDB%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、MongoDB简介MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成，MongoDB文档类似于JSON对象，字段值可以包含其他文档，数组及文档数组。 MongoDB服务端可运行在Linux、Windows或mac os x平台，支持32位和64位应用，默认端口为27017。 MongoDB支持各种编程语言: Python，Java，C++，PHP，C#等多种语言。 二、下载MongoDBMongoDB提供了可用于32位系统和64位系统的预编译二进制包（新版本没有了32位系统的安装文件），你可以进入MongoDB官网下载安装，MongoDB的预编译二进制包的下载地址为：https://www.mongodb.com/download-center/community，打开之后会看到如下图，直接点击Download下载即可，也可以在Version中选择你想要的版本： 三、安装MongoDB双击打开文件进行安装，在安装过程中，可以通过点击 “Custom(自定义)” 按钮来设置你的安装目录。 这里我选择安装在E:\\MongoDB这个目录下（安装目录会影响我们后面的配置）。 这里选择直接next： 这里安装 “Install MongoDB Compass” 不勾选，否则可能要很长时间都一直在执行安装，MongoDB Compass是一个图形界面管理工具，这里不安装也是没有问题的，可以自己去下载一个图形界面管理工具，比如Robo3T。 之后稍微等待一会就安装好了。 四、配置MongoDBMongoDB的安装过程是很简单的，但是配置就比较麻烦了，可能会遇到各种各样的问题，需要你有足够的耐心和仔细。 首先要在MongoDB的data文件夹里新建一个db文件夹和一个log文件夹： 然后在log文件夹下新建一个mongo.log： 然后将E:\\MongoDB\\bin添加到环境变量path中，此时打开cmd窗口运行一下mongo命令，出现如下情况： 这是为什么呢？这是因为我们还没有启动MongoDB服务，自然也就连接不上服务了。那要怎么启动呢？在cmd窗口中运行如下命令： mongod –dbpath E:\\MongoDB\\data\\db 需要注意的是：如果你没有提前创建db文件夹，是无法启动成功的。运行成功之后，我们打开浏览器，输入127.0.0.1:27017，看到如下图，就说明MongoDB服务已经成功启动了。 但是如果每次都要这么启动服务的话也太麻烦了吧，这里你可以选择设置成开机自启动，也可以选择用命令net start mongodb来手动启动，这里我选择使用后者，具体方法如下。 还是打开cmd窗口，不过这次是以管理员身份运行，然后输入如下命令： mongod –dbpath “E:\\MongoDB\\data\\db” –logpath “E:\\MongoDB\\data\\log\\mongo.log” -install -serviceName “MongoDB” 如果没有报错的话就说明成功添加到服务里了，可以使用win+R然后输入services.msc命令进行查看： 默认是自动运行的，这里我选择把它改成手动的。然后在cmd窗口中运行net start mongodb： 怎么解决呢？两个步骤： 1）运行sc delete mongodb删除服务； 2）再运行一次配置服务的命令： mongod –dbpath “E:\\MongoDB\\data\\db” –logpath “E:\\MongoDB\\data\\log\\mongo.log” -install -serviceName “MongoDB” 然后再运行net start mongodb，服务启动成功： 五、可能遇到的问题1.mongod不是内部或外部命令 出现这种问题说明你没有把bin目录添加到环境变量之中，重新添加一下即可解决。 2.服务名无效 首先是看你输入的服务名称是否有误，然后再查看本地服务中有没有MongoDB服务，如果没有服务，则运行命令添加服务即可。 3.发生服务特定错误：100 删除db文件夹下的mongod.lock和storage.bson两个文件，若删除完之后仍然出现这种问题，用sc delete mongodb删除服务，再配置一下服务就能解决了。","categories":[],"tags":[]},{"title":"SpringCloud微服务项目","slug":"SpringCloud微服务项目","date":"2022-09-01T02:01:10.000Z","updated":"2022-09-06T05:51:27.766Z","comments":true,"path":"2022/09/01/SpringCloud微服务项目/","link":"","permalink":"http://example.com/2022/09/01/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"前后端分离-微服务项目01-项目搭建与创作者接口-数据库创建创建数据库与表 1234567891011121314CREATE TABLE `video_author` ( `id` CHAR ( 19 ) NOT NULL COMMENT &#x27;创作者ID&#x27;, `name` VARCHAR ( 20 ) NOT NULL COMMENT &#x27;创作者姓名&#x27;, `intro` VARCHAR ( 500 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;创作者简介&#x27;, `career` VARCHAR ( 500 ) DEFAULT NULL COMMENT &#x27;创建者经历介绍&#x27;, `level` INT ( 10 ) UNSIGNED NOT NULL COMMENT &#x27;1:普通创作者 2:特约创作者&#x27;, `avatar` VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;创作者头像&#x27;, `sort` INT ( 10 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `is_deleted` TINYINT ( 1 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY ( `id` ),UNIQUE KEY `uk_name` ( `name` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;创作者&#x27;; 数据库设计规范 数据库名称尽量与应用名称保存一致 表名：业务名称_表的作用，video_author 表名, 字段名必须使用小写, 禁止以数字开头, 不要使用关键字 表名起的时候, 尽量不要使用复数名称 表当中必备三个字段：id：主键，gmt_create：记录创建的时间，gmt_modified：记录修改时间 如果一个表当中记录比较多的时候，超过了500万条，或者容量超过了2G考虑做分库分表, 假设表的内容3年都达不到500万条数据, 不要做分库分表 数据库当中字段如果是表示，是 与 否，通常字段起名，is_xxx 数据类型 使用 tinyint(1 表示真, 0表示假) 表示金钱的字段, 必须使用 decimal, 不能使用 float 或者 double, 有时候会都把小数类型统一使用 decimal 如果一个字段存储的内容几乎长度都相等，建议使用 char 类型，定长字符串类型 varhcar 可变字符串, 不预先分配存储空间, 如果长充超过 5000, 不建议使用 varchar, 建议使用 text，建议使用独立的一张表来进行存储, 全部都放到一起, 会影响查询速度 主索引, 起名: uk_字段, 普通索引, idx_字段名称 如果两个表有外键 ,不要在数据库当中添加外键约束，在应用层进行处理外键，不利于 分布式, 不利于做 并发 集群 02-项目搭建与创作者接口-父工程搭建创建父工程 删除 src 配置 maven 地址 导入依赖配置父工程的打包方式为 pom 1&lt;packaging&gt;pom&lt;/packaging&gt; 定义版本信息 12345678910111213141516171819202122232425&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;2.8.3&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.1.0&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-java-vod-upload.version&gt;1.4.11&lt;/aliyun-java-vod-upload.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt;&lt;/properties&gt; 锁定依赖信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 03-项目搭建与创作者接口-创建 service 模块以及 service_video 子模块 在父工程 video-parent 下面创建模块 service 打包方式改为 pom 1&lt;packaging&gt;pom&lt;/packaging&gt; 在 service 模块中添加项目需要的依赖，修改 service 模块的 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在父工程 service 模块下面创建子模块 service_video 创建方式同上只不过是创建之后的位置不同而已这个是 service 的子模块，service 模块的 src 也不需要删除 04-项目搭建与创作者接口-service-video工程创建配置文件 application.yml, 添加配置信息，配置内容如下，需要改为你实际的信息，如下是我的 yaml 123456789101112131415161718192021222324252627282930# application-dev.ymlserver: port: 8001spring: application: name: service-video profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: HikariPool jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8mybatis-plus: configuration: # SQL打印 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 使用代码生成器生成代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author BNTang */public class CodeGeneratorTest &#123; @Test public void main1() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_video\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成 service 层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_video&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;video_author&quot;); // 数据库表映射到实体的命名策略,驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;video_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 如上的配置需要你自行修改为你自己的如上还是那句话是我的实际信息，配置完毕了之后运行启动即可完成生成, 生成完毕之后删除生成器的 java 文件即可 获取作者列表功能创建入口文件 service_video 模块启动类，需要注意的是存放的位置，只要按照我放的位置来放即可，原因很简单，扫描的时候会扫描当前层级的文件和子文件，如果你放在某一个包中那么其它包中的文件就会扫描不到了，所以我放到了所有文件的外面这样就可以全部扫描到了 123456789/** * @author BNTang */@SpringBootApplicationpublic class VideoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(VideoApplication.class, args); &#125;&#125; 修改 application.yml 配置文件，小小的改动一下，添加一些额外的配置信息如下，你也可以复制我下面的直接替换之前的全部内容即可，改为你自己的实际信息即可 yaml 12345678910111213141516171819202122232425262728293031323334# application-dev.ymlserver: port: 8001logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-video profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: GuliHikariPool jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8mybatis-plus: configuration: # SQL打印 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 配置 mybatis-plus 测试 Controller 12345678910111213141516/** * &lt;p&gt; * 创作者 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-03-27 */@RestController@RequestMapping(&quot;/service_video/author&quot;)public class AuthorController &#123; @RequestMapping(&quot;/getAuthorList&quot;) public String getAuthorList() &#123; return &quot;getAuthorList&quot;; &#125;&#125; 启动访问接口，效果如下图 修改 Controller 编写创建者接口 1234567891011121314151617181920212223242526/** * &lt;p&gt; * 创作者 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-03-27 */@RestController@RequestMapping(&quot;/service_video/author&quot;)public class AuthorController &#123; /** * 使用代码生成器生成的 service 当中已经有很多的基础服务，直接调用即可 */ private final AuthorService authorService; public AuthorController(AuthorService authorService) &#123; this.authorService = authorService; &#125; @RequestMapping(&quot;/getAuthorList&quot;) public List&lt;Author&gt; getAuthorList() &#123; return authorService.list(null); &#125;&#125; 在浏览器中测试接口如下图 逻辑删除配置逻辑删除 Bean 123456789101112131415/** * @author BNTang **/@Configurationpublic class AppConfig &#123; /** * 逻辑删除配置Bean */ @Bean public ISqlInjector iSqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; 在实体类当中, 添加逻辑删除的注解 1@TableLogic 在控制当中，编写删除的方法 123456789/** * &lt;p&gt; * 根据Id删除创作者 * &lt;/p&gt; */@DeleteMapping(&quot;/deleteAuthor/&#123;id&#125;&quot;)public boolean deleteAuthor(@PathVariable String id) &#123; return authorService.removeById(id);&#125; 测试，如下图 05-项目搭建与创作者接口-集成SWagger2在工程当中创建一个公共模块 common 模块，并且修改打包方式为 pom 1&lt;packaging&gt;pom&lt;/packaging&gt; 添加 swagger 依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; common 模块下的 src 删除不需要，在 common 下面创建子模块 common_base 模块 在模块 common_base 中，创建 swagger 的配置类 123456789101112131415161718192021222324252627/** * @author BNTang */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() // 排除指定的路径,不生成api .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; private ApiInfo webApiInfo() &#123; return new ApiInfoBuilder() .title(&quot;视频中心API文档&quot;) .description(&quot;课程中心微服务接口&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;BNTang&quot;, &quot;https://www.cnblogs.com/BNTang&quot;, &quot;303158131@qq.com&quot;)) .build(); &#125;&#125; 在模块 service 模块中引入 common_base 123456&lt;!--common_base--&gt;&lt;dependency&gt; &lt;groupId&gt;top.it6666&lt;/groupId&gt; &lt;artifactId&gt;common_base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在 service_video 启动类上添加注解 1@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;) 然后在 Controller 当中添加 api 注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * &lt;p&gt; * 创作者 前端控制器 * Api 注解代表：分组 * &lt;/p&gt; * * @author BNTang * @since 2021-03-27 */@RestController@RequestMapping(&quot;/service_video/author&quot;)@Api(tags = &quot;作者组&quot;)public class AuthorController &#123; /** * 使用代码生成器生成的 service 当中已经有很多的基础服务，直接调用即可 */ private final AuthorService authorService; public AuthorController(AuthorService authorService) &#123; this.authorService = authorService; &#125; /** * &lt;p&gt; * 获取创作者列表 * &lt;/p&gt; */ @ApiOperation(value = &quot;所有的作者列表&quot;) @GetMapping(&quot;/getAuthorList&quot;) public List&lt;Author&gt; getAuthorList() &#123; return authorService.list(null); &#125; /** * &lt;p&gt; * 根据Id删除创作者 * &lt;/p&gt; */ @ApiOperation(value = &quot;逻辑删除作者&quot;) @DeleteMapping(&quot;/deleteAuthor/&#123;id&#125;&quot;) public boolean deleteAuthor(@ApiParam(name = &quot;id&quot;, value = &quot;作者Id&quot;, required = true) @PathVariable String id) &#123; return authorService.removeById(id); &#125;&#125; 详细说明请参考：https://www.cnblogs.com/zhuhui-site/p/10092322.html 重启工程访问：http://localhost:8001/swagger-ui.html swagger2 汉化汉化 2.7 以下的版本，首先在自己项目当中的 resources 中创建 META-INF\\resourece 文件夹如下图 需要注意有一个 / 不是以 . 来进行创建 把 swagger-ui.html 复制到自己工程的 META-INF\\resourece 中, 添加两行 js js内容如下 123&lt;!-- 加入国际化的js --&gt;&lt;script src=&quot;webjars/springfox-swagger-ui/lang/translator.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;webjars/springfox-swagger-ui/lang/zh-cn.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 06-项目搭建与创作者接口-统一返回数据格式在 common 模块中创建 common_utils 子模块 在 top.it6666.common_utils.utils 下创建一个接口为 状态码 新建 ResultCode 内容如下 12345678910111213/** * @author BNTang */public interface ResultCode &#123; /** * 成功状态码 */ Integer SUCCESS = 20000; /** * 失败的状态码 */ Integer ERROR = 20001;&#125; 紧接着在 top.it6666.common_utils.utils 下创建一个统一返回结果的类 ResponseResult.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author BNTang */@Datapublic class ResponseResult &#123; private ResponseResult() &#123; &#125; @ApiModelProperty(value = &quot;是否成功&quot;) private Boolean success; @ApiModelProperty(value = &quot;状态码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回的数据&quot;) private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); /** * 提供工具方法 */ public static ResponseResult ok() &#123; ResponseResult responseResult = new ResponseResult(); responseResult.setSuccess(true); responseResult.setCode(ResultCode.SUCCESS); responseResult.setMessage(&quot;成功&quot;); return responseResult; &#125; public static ResponseResult error() &#123; ResponseResult responseResult = new ResponseResult(); responseResult.setSuccess(false); responseResult.setCode(ResultCode.ERROR); responseResult.setMessage(&quot;失败&quot;); return responseResult; &#125; public ResponseResult success(Boolean success) &#123; this.setSuccess(success); return this; &#125; public ResponseResult message(String message) &#123; this.setMessage(message); return this; &#125; public ResponseResult code(Integer code) &#123; this.setCode(code); return this; &#125; public ResponseResult data(String key, Object value) &#123; this.data.put(key, value); return this; &#125; public ResponseResult data(Map&lt;String, Object&gt; map) &#123; this.setData(map); return this; &#125;&#125; 重点07-项目搭建与创作者接口-创作者CRUD引入 common_utils首先需要引入 common_utils 依赖的模块为 common_base xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.it6666&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后紧接着 service 模块也引入了 common_utils 了为啥呢，看下图 分页查询配置 Mp 分页插件至于修改那个模块中的那个文件我就以为图来表示了，以文字太麻烦了如下图，当然了你可以手写也可以直接拷贝我下方给出来的代码 123456789/** * &lt;p&gt; * 配置分页插件 * &lt;/p&gt; */@Beanpublic PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor();&#125; 然后在作者控制器中编写分页查询的代码，如下图 12345678910111213141516171819202122/** * &lt;p&gt; * 分页查询创作者 * &lt;/p&gt; */@ApiOperation(value = &quot;作者分页列表数据&quot;)@GetMapping(&quot;/pageList/&#123;page&#125;/&#123;limit&#125;&quot;)public ResponseResult pageList( @ApiParam(name = &quot;page&quot;, value = &quot;当前页&quot;, required = true) @PathVariable Long page, @ApiParam(name = &quot;limit&quot;, value = &quot;每页记录数&quot;, required = true) @PathVariable Long limit) &#123; // 分页查询 Page&lt;Author&gt; pageInfo = new Page&lt;&gt;(page, limit); authorService.page(pageInfo, null); // 获取当前页的数据 List&lt;Author&gt; records = pageInfo.getRecords(); // 获取总记录 long total = pageInfo.getTotal(); return ResponseResult.ok().data(&quot;total&quot;, total).data(&quot;rows&quot;, records);&#125; 添加分页条件筛选 需求：根据名称 name，头衔 level、时间 gmt_create 把前端传的数据给封装到一个类当中, 放到 VO 包中，新建 VO 包 vo 当中的实体，是用与前端交互封装数据对象的实体类 12345678910/** * @author BNTang */@Datapublic class AuthorQuery &#123; private String name; private Integer level; private String begin; private String end;&#125; 在分页方法当中添加查询的参数，在添加之前需要修改掉请求方式为 Post，get 请求没有办法传递 JSON，mp 生成的基础服务的分页方法满足不了我们自己的需求，这个时候我们需要自己手动的去添加方法并实现，修改 AuthorService.java 添加如下方法 1234567/** * 带条件查询的分页 * * @param pageInfo 分页信息 * @param authorQuery 查询条件 */void pageQuery(Page&lt;Author&gt; pageInfo, AuthorQuery authorQuery); 紧接着就是在对应的实现类当中进行实现该方法 1234567891011121314151617181920212223242526272829303132@Overridepublic void pageQuery(Page&lt;Author&gt; pageInfo, AuthorQuery authorQuery) &#123; QueryWrapper&lt;Author&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByAsc(&quot;sort&quot;); if (Objects.isNull(authorQuery)) &#123; // 没有条件 baseMapper.selectPage(pageInfo, queryWrapper); return; &#125; // 有条件，判断条件是否为空 if (!StringUtils.isEmpty(authorQuery.getName())) &#123; // 模糊查询 name queryWrapper.like(&quot;name&quot;, authorQuery.getName()); &#125; if (!Objects.isNull(authorQuery.getLevel())) &#123; queryWrapper.eq(&quot;level&quot;, authorQuery.getLevel()); &#125; // 查询创建的时间大于等于开始时间 if (!StringUtils.isEmpty(authorQuery.getBegin())) &#123; queryWrapper.ge(&quot;gmt_create&quot;, authorQuery.getBegin()); &#125; // 查询创建的时间在小于等于结束时间 if (!StringUtils.isEmpty(authorQuery.getEnd())) &#123; queryWrapper.le(&quot;gmt_create&quot;, authorQuery.getEnd()); &#125; baseMapper.selectPage(pageInfo, queryWrapper);&#125; 修改 AuthorController 修改内容如下图，当然你可以直接拷贝我下面的代码 12345678910111213141516171819202122232425/** * &lt;p&gt; * 分页查询创作者,还可以添加过滤条件进行查询 * &lt;/p&gt; */@ApiOperation(value = &quot;作者分页列表数据&quot;)@PostMapping(&quot;/pageList/&#123;page&#125;/&#123;limit&#125;&quot;)public ResponseResult pageList( @ApiParam(name = &quot;page&quot;, value = &quot;当前页&quot;, required = true) @PathVariable Long page, @ApiParam(name = &quot;limit&quot;, value = &quot;每页记录数&quot;, required = true) @PathVariable Long limit, @ApiParam(name = &quot;authorQuery&quot;, value = &quot;查询对象&quot;) @RequestBody(required = false) AuthorQuery authorQuery) &#123; // 分页查询 Page&lt;Author&gt; pageInfo = new Page&lt;&gt;(page, limit); authorService.pageQuery(pageInfo, authorQuery); // 获取当前页的数据 List&lt;Author&gt; records = pageInfo.getRecords(); // 获取总记录 long total = pageInfo.getTotal(); return ResponseResult.ok().data(&quot;total&quot;, total).data(&quot;rows&quot;, records);&#125; 改造完毕之后访问 swagger 页面进行测试一下接口效果如下图 根据 ID 查询测试自行访问 swagger 自测，后续不在贴图，代码如下修改 AuthorController.java 123456789101112131415/** * &lt;p&gt; * 根据id查询作者 * &lt;/p&gt; * * @param id 作者Id * @return 查询到的作者 */@ApiOperation(value = &quot;根据id查询作者&quot;)@GetMapping(&quot;/getAuthorWithId/&#123;id&#125;&quot;)public ResponseResult getAuthorWithId( @ApiParam(name = &quot;id&quot;, value = &quot;作者的id&quot;, required = true) @PathVariable String id) &#123; Author author = authorService.getById(id); return ResponseResult.ok().data(&quot;item&quot;, author);&#125; 添加作者配置自动填充移动 mp 依赖的位置原先 mp 依赖是放在 service 模块当中，现在移动到 common_base 当中因为我们在 service 引入了 common_base 所以就会包含 mp 的依赖 创建处理器, 设置自动填充日期 12345678910111213141516/** * @author BNTang **/@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject); this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125;&#125; 在实体类当中添加自动填充的注解 1@TableField(fill = FieldFill.INSERT) 1@TableField(fill = FieldFill.INSERT_UPDATE) 然后继续完善添加创作者的接口，修改 AuthorController 123456789101112131415/** * &lt;p&gt; * 添加作者 * &lt;/p&gt; * * @param author 需要添加的创作者 * @return 添加结果 */@ApiOperation(value = &quot;添加作者&quot;)@PostMapping(&quot;/addAuthor&quot;)public ResponseResult addAuthor( @ApiParam(name = &quot;author&quot;, value = &quot;作者对象&quot;, required = true) @RequestBody Author author) &#123; authorService.save(author); return ResponseResult.ok();&#125; 更新创作者修改 AuthorController 12345678910111213141516171819/** * &lt;p&gt; * 更新创作者 * &lt;/p&gt; * * @param author 更新的创作者 * @return 更新结果 */@ApiOperation(value = &quot;更新创作者&quot;)@PostMapping(&quot;/updateAuthor&quot;)public ResponseResult updateAuthor( @ApiParam(name = &quot;author&quot;, value = &quot;作者对象&quot;, required = true) @RequestBody Author author) &#123; boolean flag = authorService.updateById(author); if (flag) &#123; return ResponseResult.ok(); &#125; else &#123; return ResponseResult.error(); &#125;&#125; 08-项目搭建与创作者接口-统一异常与日志处理统一异常处理简介让异常结果显示为统一的样式结构，例如 错误信息 错误提示 可以使用 @ControllerAdvice 这个注解来进行实现这是 SpringMVC 提供的 实用步骤在 common_base 模块中引入依赖, 想要使用这个注解得要有 SpringMVC Web 相关的依赖才可以，所以这里需要将 Spring Web 启动器的依赖移动到 common_base 当中如下图，为啥要移动呢，因为 service_video 模块中依赖了 common_base 所以你把依赖移动到了 common_base 中 自然而然的 service_video 当中也会有，后面我们还有其它很多的依赖，都直接依赖一下这个 common_base 模块即可完成依赖共享 xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编辑全局异常处理器 1234567891011121314/** * @author BNTang * 全局异常处理器, 只要发生了异常,如果在自己控制当中.没有去捕获,就会到此控制器 */@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult error(Exception e) &#123; e.printStackTrace(); return ResponseResult.error(); &#125;&#125; 09-创作者前端-前后端分离与建立前端工程什么是前后端分离 前端单独进行部署 后端也是单独进行部署 两个系统之间使用 JSON 进行传输 建立前端工程前端是基于 Vue 来进行开发的，所以我本次使用的 UI 为 vue-element-amdin 进行二次开发, 不过使用的是 template 模板 admin 那套内容太多了，所以在这里我将一步一步的来完善该系统 前端使用的开发工具为 WebStorm 可以和我一样也可以不一样，本次编写博主使用的为 WebStorm UI 模板的目录结构 下载模板，https://github.com/PanJiaChen/vue-admin-template 如果对 Git 了解可以使用 SSH 的方式进行下载，没有的话就直接下载 zip 即可，下载解压之后的效果图如下 在跑起来这个前端之前你需要准备一个东西就是安装 Node.js 看本教程的时候如果你基础不好我建议还是先去学学前面的内容，在来回头看本教程，Node.js 的安装方式参考链接为：https://www.cnblogs.com/BNTang/p/13674486.html 还有就是需要配置一下包的下载源对象，默认是从国外进行下载，博主已经改好了，改到了国内的阿里源，切换方式上图的文章列表当中也有如下图 配置 Node 如上图打开终端，然后下载前端对应的包在终端当中执行如下脚本 12# 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题npm install --registry=https://registry.npm.taobao.org 配置运行脚本如下图，就不用每次运行都在终端当中自己打对应的运行脚本了 如上如果都配置好了，那么就直接点击启动的按钮启动工程，最终得到的效果图如下 前端开发步骤路径对应路由, 路由当中会对应我们的页面 添加路由 引入路由的页面 进入到组件当中, 编写页面, 加载对应的 js, 发送网络请求 发送网络请求 在 api 当中创建对应的 js 文件, 定义接口地址参数 前端界面修改添加Log 1&lt;img class=&quot;logo_img&quot; src=&quot;@/assets/logo_image/logo.jpg&quot;/&gt; 添加样式 123456789101112131415161718.title &#123; font-size: 35px; color: $light_gray; margin: 0 auto 20px auto; text-align: center; font-weight: bold; display: inline-block; padding-top: 10px;&#125;.logo_img &#123; width: 60px; height: 60px; margin-right: 10px; vertical-align: top;&#125;margin-bottom: 20px; 修改 favicon.ico 修改 Title 前端请求流程 替换前端请求服务器地址 编写服务器登录请求接口 1234567891011121314151617181920212223242526272829303132333435363738/** * @author BNTang */@RestController@RequestMapping(&quot;/user&quot;)@CrossOrigin@Api(tags = &quot;用户组&quot;)public class LoginController &#123; /** * &lt;p&gt; * 登录 * &lt;/p&gt; * * @return 登录成功之后的信息 */ @PostMapping(&quot;/login&quot;) @ApiOperation(value = &quot;登录&quot;) public ResponseResult login() &#123; return ResponseResult.ok().data(&quot;token&quot;, &quot;admin-token&quot;); &#125; /** * &lt;p&gt; * 登录之后的用户信息 * &lt;/p&gt; * * @return 登录之后的用户信息 */ @GetMapping(&quot;/info&quot;) @ApiOperation(value = &quot;获取登录之后的用户信息&quot;) public ResponseResult info() &#123; return ResponseResult.ok() .data(&quot;roles&quot;, &quot;[admin]&quot;) .data(&quot;name&quot;, &quot;BNTang&quot;) .data(&quot;avatar&quot;, &quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); &#125;&#125; 在前端调用请求的时候会产生跨域的问题，至于什么是跨域我就不在介绍了，自行问度娘，后续我在出文章进行讲解，目前没有统一的处理跨域所以需要在每一个 Controller 添加一个允许跨域访问的注解就是 @CrossOrigin 没有指定路径，代表当前下的所有都允许跨域访问 然后在修改 user.js 中的 api 为我们自己后台的地址修改文件和修改内容如下图所示 10-创作者前端-创作者列表修改路由跳转修改路由 需要注意把如下图的地方给注释掉，不要纠结为啥，因为路由重复了 1234567891011121314151617181920212223242526272829303132&#123; path: &#x27;/&#x27;, component: Layout, // redirect: &#x27;/dashboard&#x27;, children: [&#123; path: &#x27;/&#x27;, name: &#x27;首页&#x27;, component: () =&gt; import(&#x27;@/views/dashboard/index&#x27;), meta: &#123;title: &#x27;首页&#x27;, icon: &#x27;dashboard&#x27;&#125; &#125;] &#125;, &#123; path: &#x27;/author&#x27;, component: Layout, redirect: &#x27;/author/table&#x27;, name: &#x27;创作者管理&#x27;, meta: &#123;title: &#x27;创作者管理&#x27;, icon: &#x27;el-icon-s-help&#x27;&#125;, children: [ &#123; path: &#x27;table&#x27;, name: &#x27;创作者列表&#x27;, component: () =&gt; import(&#x27;@/views/video/author/list&#x27;), meta: &#123;title: &#x27;创作者列表&#x27;, icon: &#x27;table&#x27;&#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加创作者&#x27;, component: () =&gt; import(&#x27;@/views/video/author/save&#x27;), meta: &#123;title: &#x27;添加创作者&#x27;, icon: &#x27;tree&#x27;&#125; &#125; ] &#125;, 在上图中我新建了两个组件，如何新建的呢，快捷键为 Ctrl + Alt + Shift + insert 即可弹出如下的框子选择 Vue Component 如下图 不使用快捷键的话那么就直接在需要添加组件的文件包上面鼠标右键选择 New 也可以出现如上图的选项卡 创建组件一个 list，一个 save 内容如下图所示 编写 api 请求数据列表数据请求在 api 文件夹当中创建请求的 js 文件 1234567891011121314import request from &#x27;@/utils/request&#x27;export default &#123; // 1.作者列表-分页查询 getAuthorListPage(page, limit, authorQuery) &#123; return request(&#123; // 路由参数拼接 url: `/service_video/author/pageList/$&#123;page&#125;/$&#123;limit&#125;/`, method: &#x27;post&#x27;, // data 会自动转成 json 传递到接口当中 data: authorQuery &#125;) &#125;&#125; 在 list.vue 当中引入对应的 js 12// 引入 author.js 调用对应的请求方法import author from &#x27;@/api/video/author/author&#x27;; 定义成员变量, 发送请求 1234567891011121314151617181920212223242526272829303132333435export default &#123; name: &quot;list&quot;, // 定义变量与初始值 data() &#123; return &#123; // 查询的结果集 list: null, // 当前页 page: 1, // 每页多少条记录 limit: 10, // 总记录数 total: 0, // 查询封装的对象 authorQuery: &#123;&#125; &#125; &#125;, // 自定义方法 methods: &#123; getAuthorList(page = 1) &#123; this.page = page author.getAuthorListPage(this.page, this.limit, this.authorQuery) .then(resp =&gt; &#123; // 处理请求成功 console.log(resp); &#125;).catch(error =&gt; &#123; // 请求失败 &#125;); &#125; &#125;, // 页面渲染之前会自动调用此方法 created() &#123; this.getAuthorList(); &#125;&#125; 在后端服务器接口当中添加跨域注解 1@CrossOrigin 前端和后端工程都启动点击创作者列表效果如下图所示 Element-ui 表格组件https://element.eleme.io/#/zh-CN/component/table 数据展示创作者列表数据展示 12345678910111213141516171819&lt;!--表格--&gt;&lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;名称&quot; align=&quot;center&quot; prop=&quot;name&quot;/&gt; &lt;el-table-column label=&quot;级别&quot; align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;创作者简介&quot; align=&quot;center&quot; prop=&quot;intro&quot;/&gt; &lt;el-table-column label=&quot;添加时间&quot; align=&quot;center&quot; prop=&quot;gmtCreate&quot;/&gt; &lt;el-table-column label=&quot;排序&quot; align=&quot;center&quot; prop=&quot;sort&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot;&gt;修改&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot;&gt;删除&lt;/el-button&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 处理请求成功的回调如下 序号与级别处理 1234&lt;!-- 通过 slot 拿到表格当中绑定的数据 --&gt;&lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.$index + 1 &#125;&#125;&lt;/template&gt; 1234&lt;!-- 通过 slot 拿到表格当中绑定的数据 --&gt;&lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.level === 1 ? &quot;普通创作者&quot; : &quot;特约创作者&quot; &#125;&#125;&lt;/template&gt; 11-创作者前端-添加分页使用 Element-ui 分页组件 12345678910&lt;!--分页--&gt;&lt;el-pagination style=&quot;padding: 30px 0; text-align: center&quot; background :current-page=&quot;page&quot; :page-size=&quot;limit&quot; layout=&quot;total, prev, pager, next, jumper &quot; :total=&quot;total&quot; @current-change=&quot;getAuthorList&quot;/&gt; 定义请求方法，如下的方法代码之前的文章已经有了不在贴 修改使用汉字 Element-UI 显示，不然分页信息是英文如下图 修改 main.js 即可进行切换为汉字显示 12-创作者前端-条件查询添加查询表单 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 表单查询 --&gt;&lt;el-form :inline=&quot;true&quot; :model=&quot;authorQuery&quot; class=&quot;demo-form-inline&quot;&gt; &lt;!-- 姓名 --&gt; &lt;el-form-item label=&quot;姓名&quot;&gt; &lt;el-input v-model=&quot;authorQuery.name&quot; placeholder=&quot;姓名&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 下拉列表 --&gt; &lt;el-form-item label=&quot;级别&quot;&gt; &lt;el-select v-model=&quot;authorQuery.level&quot; clearable placeholder=&quot;选择级别&quot;&gt; &lt;el-option label=&quot;特约创作者&quot; value=&quot;0&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;普通创作者&quot; value=&quot;1&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!--日期选择--&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;authorQuery.begin&quot; type=&quot;datetime&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; placeholder=&quot;选择开始时间&quot;&gt; &lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;authorQuery.end&quot; type=&quot;datetime&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; placeholder=&quot;选择截止时间&quot;&gt; &lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;getAuthorList()&quot;&gt;查询&lt;/el-button&gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; 添加清空查询条件数据方法 1234567// 清空查询的数据resetData() &#123; // 清空表单 this.authorQuery = &#123;&#125;; // 重新查询 this.getAuthorList();&#125; 13-创作者前端-逻辑删除创作者监听删除按钮的点击，然后传入当前删除记录的 id 进行逻辑删除 12345678&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot;&gt;修改&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;deleteAuthorWithId(scope.row.id)&quot;&gt;删除 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 实现删除的方法编写删除的前端 api 12345678// 2.删除作者deleteAuthorWithId(id) &#123; return request(&#123; // 路由参数拼接 url: `/service_video/author/deleteAuthor/$&#123;id&#125;/`, method: &#x27;delete&#x27; &#125;)&#125; 修改后端的接口 实现前端删除的方法 javascript 1234567891011121314151617181920212223242526// 删除创作者deleteAuthorWithId(id) &#123; // 用户提示 this.$confirm(&#x27;此操作将永久删除该创作者！, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 调用删除的api author.deleteAuthorWithId(id).then(response =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); // 重新加载数据 this.getAuthorList(); &#125;).catch(error =&gt; &#123; this.$message.error(&#x27;删除失败！&#x27;); &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;);&#125; 14-创作者前端-添加创作者编写添加界面 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;作者名称&quot;&gt; &lt;el-input v-model=&quot;author.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序&quot;&gt; &lt;el-input-number v-model=&quot;author.sort&quot; controls-position=&quot;right&quot; :min=&quot;0&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;级别&quot;&gt; &lt;el-select v-model=&quot;author.level&quot; clearable placeholder=&quot;选择级别&quot;&gt; &lt;el-option label=&quot;特约创作者&quot; value=&quot;0&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;普通创作者&quot; value=&quot;1&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;工作经历&quot;&gt; &lt;el-input v-model=&quot;author.career&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;创作者简介&quot;&gt; &lt;el-input v-model=&quot;author.intro&quot; type=&quot;textarea&quot; :rows=&quot;10&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;false&quot; type=&quot;primary&quot; @click=&quot;saveClick()&quot;&gt;保存&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt; 编写添加接口 api javascript 123456789// 3.添加addAuthor(author) &#123; return request(&#123; url: `/service_video/author/addAuthor`, method: &#x27;post&#x27;, // data 会自动转成 json 传递到接口当中 data: author &#125;)&#125; 引入添加的接口，处理添加的请求 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;import author from &quot;@/api/video/author/author&quot;;export default &#123; name: &quot;save&quot;, data() &#123; return &#123; author: &#123; // 排序默认值 sort: 0 &#125; &#125; &#125;, methods: &#123; saveClick() &#123; //保存，添加 / 更新 this.addAuthor(); &#125;, // 添加 addAuthor() &#123; // 调用接口，做添加操作 author.addAuthor(this.author).then(resposne =&gt; &#123; // 添加成功 this.$message(&#123; type: &#x27;success&#x27;, message: resposne.message &#125;); // 跳转到列表页 this.$router.push(&#123;path: &#x27;/author/table&#x27;&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&#x27;添加失败！&#x27;); &#125;); &#125; &#125;&#125;&lt;/script&gt; 15-创作者前端-更新创作者点击编辑按钮进行页面路由跳转 定义点击编辑按钮的路由如下图 javascript 1234567&#123; path: &#x27;edit/:id&#x27;, name: &#x27;编辑&#x27;, component: () =&gt; import(&#x27;@/views/video/author/save&#x27;), meta: &#123;title: &#x27;编辑&#x27;, icon: &#x27;tree&#x27;&#125;, hidden: true&#125; 修改编辑按钮，修改点击编辑按钮跳转的路由地址，使用 router-link 如下图 123456&lt;!--修改跳转,让其跳转到路由当中,编辑路由页面和添加的是一样，编辑当中是有参数--&gt;&lt;router-link :to=&quot;&#x27;/author/edit/&#x27;+scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot;&gt;修改&lt;/el-button&gt;&lt;/router-link&gt; 更新数据回显编写请求 api javascript 12345678// 4.根据id查询作者getOneAuthor(id) &#123; return request(&#123; // 路由参数拼接 url: `/service_video/author/getAuthorWithId/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;)&#125; 获取参数，然后发送请求 javascript 123456789101112131415161718// 一进来就要获取参数created() &#123; // 判断有没有参数，如果有，获取参数 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; let authorId = this.$route.params.id; // 根据id获取该条参数对应的数据,发送请求到服务器当中获取数据 author.getOneAuthor(authorId).then(res =&gt; &#123; this.author = res.data.item; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;服务器繁忙，请稍后再试！&quot;); &#125;); &#125; else &#123; this.author = &#123; sort: 0, level: 1 &#125; &#125;&#125; 让下拉列表进行默认选中 更新数据添加更新创作者的请求 api javascript 123456789// 5.更新创作者updateAuthor(author) &#123; return request(&#123; url: &#x27;/service_video/author/updateAuthor&#x27;, method: &#x27;post&#x27;, // data会自动转成JSON传递到接口当中 data: author &#125;);&#125; 编写更新创作者请求的方法如下 javascript 123456789101112131415// 更新updateAuthor()&#123; // 调用更新的api author.updateAuthor(this.author).then(res=&gt;&#123; // 更新成功 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;更新成功!&#x27; &#125;); &#125;).catch(error=&gt;&#123; this.$message.error(&quot;更新失败！&quot;); &#125;); // 跳转到创作者列表页 this.$router.push(&#123;path: &#x27;/author/table&#x27;&#125;);&#125; 修改之前的添加方法，判断，当前是否为更新或者添加，达到复用 javascript 1234567891011saveClick() &#123; // 根据有没有 id 判断，是添加还是更新 // 如果有id，那么就是更新，否则就是添加 if (this.author.id) &#123; // 更新 this.updateAuthor(); &#125; else &#123; // 添加 this.addAuthor(); &#125;&#125;, 16-创作者前端-云对象存储申请首先进入阿里云官网：https://www.aliyun.com/ 搜索 oss 点击管理控制台，进去之后, 点击立即开通 开通之后的样子如下图 申请密钥 Api 地址地址：https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11186623.6.939.68ec46a1Dmwj0L 创建 service_upload 服务 修改 service_upload 服务的 pom.xml 引入依赖 xml 12345678910111213&lt;dependencies&gt; &lt;!-- 阿里云oss依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日期工具类依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加启动类并排除加载数据库相关信息 java 12345678910111213141516/** * @author BNTang * @version 1.0 * @project video_parent * @description OSS云上传服务 * @since Created in 2021/4/3 12:17 **/@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class UpLoadApplication &#123; public static void main(String[] args) &#123; /* exclude = DataSourceAutoConfiguration.class：默认会加载数据库相关信息，现在是上传服务，里面用不到数据库相关信息,不让工程加载数据库相关信息 */ SpringApplication.run(UpLoadApplication.class, args); &#125;&#125; 在 resources 中添加配置文件 application.yml 内容如下 yaml 1234567891011121314151617181920# application-dev.ymlserver: port: 8002logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-video profiles: active: dev# 定义oss相关属性oss: endpoint: oss-cn-hangzhou.aliyuncs.com accessKeyId: LTAI4GH19ep2P8caxW2E2N6A accessKeySecret: NAmWiBmKXofw7hs4JRcx7SLhF1MN6P bucketName: BNTang oss 相关属性怎么来的呢，继续进入到我们上方开通好的 oss 管理控制台中选择 Bucket 管理 如下图 按照我如下图进行选择即可，读写不能设置为私有，不然就不能访问了，同城冗余存储代表的是，如果出现故障了，它可以做备份，之前的数据还有，其它的就没什么要注意的了创建即可 创建好了之后界面如下图所示，我下图选中了一个 Endpoint 就是我们上方 oss 相关属性的 Endpoint 配置值，其它的在哪里呢，继续往下看 accessKey 就是我们之前创建的那个 accessKey 的界面中的 accessKey，不知道找了可以参考下图 可能你一来不是显示的，需要获取验证码输入之后就可以看到了，复制上方的一些信息替换成你自己实际的即可配置完毕了, bucketName 就是你创建的 bucketName 的名称 定义工具类加载配置信息 java 12345678910111213141516171819202122232425262728293031323334353637/** * @author BNTang * @version 1.0 * @project video_parent * @description 读取配置的属性信息 * @since Created in 2021/4/3 12:46 **/@Componentpublic class OssConstant implements InitializingBean &#123; @Value(&quot;$&#123;oss.endpoint&#125;&quot;) private String endpoint; @Value(&quot;$&#123;oss.accessKeyId&#125;&quot;) private String accessKeyId; @Value(&quot;$&#123;oss.accessKeySecret&#125;&quot;) private String accessKeySecret; @Value(&quot;$&#123;oss.bucketName&#125;&quot;) private String bucketName; public static String ENDPOINT; public static String ASSESS_KEY_ID; public static String ASSESS_KEY_SECRET; public static String BUCKET_NAME; /** * 在属性文件加载完毕后属性也设置完毕之后, 会自动调用 */ @Override public void afterPropertiesSet() &#123; ENDPOINT = endpoint; ASSESS_KEY_ID = accessKeyId; ASSESS_KEY_SECRET = accessKeySecret; BUCKET_NAME = bucketName; &#125;&#125; 定义上传的控制器接口 java 123456789101112131415161718192021222324252627282930313233/** * @author BNTang * @version 1.0 * @project video_parent * @description 上传oss控制器 * @since Created in 2021/4/3 12:53 **/@RestController@RequestMapping(&quot;/service_upload/file&quot;)@Api(tags = &quot;上传OSS&quot;)@CrossOriginpublic class UpLoadController &#123; private final UpLoadService upLoadService; public UpLoadController(UpLoadService upLoadService) &#123; this.upLoadService = upLoadService; &#125; /** * &lt;p&gt; * 上传文件 * &lt;/p&gt; * * @param file 文件 * @return 上传之后的文件下载地址 url */ @PostMapping(&quot;/uploadOssFile&quot;) public ResponseResult uploadOssFile(MultipartFile file) &#123; return ResponseResult.ok().data(&quot;url&quot;, upLoadService.uploadFile(file)); &#125;&#125; 定义上传的接口业务 java 1234567891011121314151617181920/** * @author BNTang * @version 1.0 * @project video_parent * @description 上传服务接口 * @since Created in 2021/4/3 12:56 **/public interface UpLoadService &#123; /** * &lt;p&gt; * 上传OSS文件 * &lt;/p&gt; * * @param file 文件 * @return 上传之后的url */ String uploadFile(MultipartFile file);&#125; OSS 上传业务实现 java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author BNTang * @version 1.0 * @project video_parent * @description OSS上传业务实现 * @since Created in 2021/4/3 12:57 **/@Servicepublic class UpLoadServiceImpl implements UpLoadService &#123; @Override public String uploadFile(MultipartFile file) &#123; // Endpoint以上海为例，其它Region请按实际情况填写。 String endpoint = OssConstant.ENDPOINT; // 云账号AccessKey有所有API访问权限 String accessKeyId = OssConstant.ASSESS_KEY_ID; String accessKeySecret = OssConstant.ASSESS_KEY_SECRET; String bucketName = OssConstant.BUCKET_NAME; // 创建OSSClient实例。 OSS ossClient = null; try &#123; // 创建OSSClient实例。 ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 上传文件流。 InputStream inputStream = file.getInputStream(); // 处理文件名称 String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); String fileName = uuid + file.getOriginalFilename(); // 把同一天上传的文件 放到同一个文件夹当中 2020/10/1/fileName String date = new DateTime().toString(&quot;yyyy/MM/dd&quot;); fileName = date + &quot;/&quot; + fileName; ossClient.putObject(bucketName, fileName, inputStream); // https://bntang.oss-cn-shanghai.aliyuncs.com/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B01.png return &quot;https://&quot; + bucketName + &quot;.&quot; + endpoint + &quot;/&quot; + fileName; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭OSSClient。 if (null != ossClient) &#123; ossClient.shutdown(); &#125; &#125; return null; &#125;&#125; 重启工程进行测试上传，访问 swagger 选择需要上传的文件进行上传，在进行访问 swagger 的时候发现，弹出了如下图的内容，如果出现了下图中的内容就代表没有添加扫描包的注解 修改 service_upload 的启动类添加如下注解即可 java 1@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;) 测试上传，成功，如下图 查看阿里云 OSS 存储文件列表如下图，发现已经OK了 17-创作者前端-前后端分离多服务之间的访问调用利用 nginx，在 nginx 当中配置服务地址代理规则 下载 nginx，http://nginx.org/en/download.html 修改 nginx 配置，修改 nginx-1.16.1\\conf 目录下的 nginx.conf 文件，修改内容如下 text 1234567location ~ /service_video &#123; proxy_pass http://localhost:8001;&#125;location ~ /service_upload &#123; proxy_pass http://localhost:8002;&#125; 启动 nginx，然后在浏览器中访问 http://localhost/ 看到如下界面说明 nginx 已经启动好了 那么如何关闭 nginx 呢，你们的有可能有一个命令行窗口，你关闭那个窗口其实 nginx 并没有真正的关闭，你不信你关闭了之后你在访问 http://localhost/ 还是可以看到如上图的界面，那么怎么关闭呢，关闭方式如下 sh 1nginx.exe -s stop 再次访问如上 nginx 的地址你会发现访问不到了，就说明关闭啦，配置好了 nginx 之后呢，然后在前端工程当中配置接口地址为 nginx 地址即可完成多服务访问的效果了，修改前端的 .env.development 修改内容如下图 如上的内容都配置完毕了之后这个时候你启动后端和前端来测试一下，还有 nginx 也需要启动，来看看可不可以达到多服务的访问呢 启动后端 访问登录发现出错了 问题原因就是我们登录的 Controller 没有加模块的前缀路径，修改 LoginController 紧接着前端登录接口的路径也需要同理的修改，如下 修改之后在访问，发现全部都OK啦，效果如下图 18-创作者前端-头像上传前端添加缩略图，和上传图片的组件，上传图片的组件我是从 vue-element-admin 中进行拷贝过来的，如果你想使用和我不同的上传组件可以自行去弄一个，我的话就使用 vue-element-admin 提供的了，下载 vue-element-admin 下载地址：https://github.com/PanJiaChen/vue-element-admin 在添加创作者页面当中导入该组件 javascript 12import imageCropper from &quot;@/components/ImageCropper&quot;;import panThumb from &quot;@/components/PanThumb&quot;; javascript 1components: &#123;imageCropper, panThumb&#125;, 修改添加页面，添加缩略图 123&lt;el-form-item&gt; &lt;pan-thumb :width=&quot;String(&#x27;100px&#x27;)&quot; :height=&quot;String(&#x27;100px&#x27;)&quot; :image=&quot;String(author.avatar)&quot;/&gt;&lt;/el-form-item&gt; 上传文件上传界面 123456789101112131415161718&lt;el-form-item&gt; &lt;pan-thumb :width=&quot;String(&#x27;100px&#x27;)&quot; :height=&quot;String(&#x27;100px&#x27;)&quot; :image=&quot;String(author.avatar)&quot;/&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;imageCropperShow=true&quot;&gt;上传头像&lt;/el-button&gt; &lt;!-- 上传头像的界面 --&gt; &lt;image-cropper v-show=&quot;imageCropperShow&quot; :width=&quot;500&quot; :height=&quot;300&quot; :key=&quot;cropperKey&quot; :url=&quot;BASE_API+&#x27;/service_upload/file/uploadOssFile&#x27;&quot; field=&quot;file&quot; @close=&quot;close&quot; @crop-upload-success=&quot;cropSuccess&quot; /&gt;&lt;/el-form-item&gt; 事件处理 javascript 123456789101112data() &#123; return &#123; author: &#123; // 排序默认值 sort: 0, level: 1 &#125;, imageCropperShow: false, cropperKey: 0, BASE_API: process.env.VUE_APP_BASE_API &#125;&#125;, javascript 1234567891011121314close() &#123; // 关闭弹框 this.imageCropperShow = false; // 该代码可以清空上传组件的默认样式，也就是说每次弹出来的窗口都是新的 this.cropperKey = this.cropperKey + 1;&#125;,cropSuccess(data) &#123; // 关闭弹框 this.imageCropperShow = false; // 显示图片 this.author.avatar = data.url; this.cropperKey = this.cropperKey + 1;&#125; 如上内容都完成好了之后，测试上传效果图如下所示 19-分类管理-数据库表创建数据库语句如下 12345678910CREATE TABLE `video_category` ( `id` CHAR ( 19 ) NOT NULL COMMENT &#x27;类别ID&#x27;, `title` VARCHAR ( 10 ) NOT NULL COMMENT &#x27;类别名称&#x27;, `parent_id` CHAR ( 19 ) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;父ID&#x27;, `sort` INT ( 10 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序字段&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY ( `id` ),KEY `idx_parent_id` ( `parent_id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 ROW_FORMAT = COMPACT COMMENT = &#x27;科目分类&#x27;; 20-分类管理-上传分类前端添加路由 javascript 123456789101112131415161718192021&#123; path: &#x27;/category&#x27;, component: Layout, redirect: &#x27;/category/list&#x27;, name: &#x27;视频分类管理&#x27;, meta: &#123;title: &#x27;视频分类管理&#x27;, icon: &#x27;el-icon-s-help&#x27;&#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;视频分类列表&#x27;, component: () =&gt; import(&#x27;@/views/video/category/list&#x27;), meta: &#123;title: &#x27;视频分类列表&#x27;, icon: &#x27;table&#x27;&#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;上传视频分类&#x27;, component: () =&gt; import(&#x27;@/views/video/category/save&#x27;), meta: &#123;title: &#x27;上传视频分类&#x27;, icon: &#x27;tree&#x27;&#125; &#125; ]&#125;, 完善上传页面，上传页面也就是所谓的添加页面，现在大部分使用 excel 导致的比较多，所以这次就采用 excel 导入上传的形式来做添加，添加内容如下，添加了之后会报错，因为方法还没添加，不过没什么问题，先添加，添加完毕了之后紧接着就是去写 excel 上传解析接口了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;!-- 下载 excel 模板 --&gt; &lt;el-form-item label=&quot;描述信息&quot;&gt; &lt;el-tag type=&quot;info&quot;&gt;excel模板说明&lt;/el-tag&gt; &amp;nbsp; &lt;el-tag&gt; &lt;i class=&quot;el-icon-download&quot;&gt;&lt;/i&gt; &lt;a href=&quot;javascript:(0)&quot;&gt;点击下载模板&lt;/a&gt; &lt;/el-tag&gt; &lt;/el-form-item&gt; &lt;!-- 上传excel --&gt; &lt;el-form-item label=&quot;上传信息&quot;&gt; &lt;el-upload ref=&quot;upload&quot; action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; :auto-upload=&quot;false&quot; :on-success=&quot;uploadSuccess&quot; :on-error=&quot;uploadError&quot; accept=&quot;.xls, .xlsx&quot; :limit=&quot;1&quot; :disabled=&quot;btnDisabled&quot; name=&quot;file&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt; &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&gt;上传到服务器 &lt;/el-button&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;save&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 21-分类管理-后台接口编写EasyExcelEasyExcel 概述Java 解析、生成 excel 比较有名的框架有 Apache poi、jxl，但他们都存在一个严重的问题就是非常耗内存，easyExcel 也是用来解析 excel 用的，但是他却解决了这个问题 EasyExcel 的原理 写数据创建模型，在创建模型之前在 service_video 模型中添加单元测试和热加载相关的依赖，如下 xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 然后在引入 easyExcel 相关的依赖 xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 模型内容如下 java 1234567@Datapublic class StudentData &#123; @ExcelProperty(value = &quot;学号&quot;, index = 0) private Integer no; @ExcelProperty(value = &quot;姓名&quot;, index = 1) private String name;&#125; 写数据，也就是导出 excel 文件 java 123456789101112131415161718192021222324252627282930313233/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/3 22:08 * @description **/@SpringBootTestpublic class ServiceVideoApplicationTests &#123; @Test public void writeExcel() &#123; String fileName = &quot;D:\\\\01.xlsx&quot;; List&lt;StudentData&gt; studentDataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; StudentData studentData = new StudentData(); studentData.setNo(i); studentData.setName(&quot;BNTang&quot; + i); studentDataList.add(studentData); &#125; /* * 1.fileName：文件路径与名称 * 2.StudentData.class：模型的字节码 * 3.sheet：名称 * 4.doWrite：要写的数据，是一个list */ EasyExcel.write(fileName, StudentData.class).sheet(&quot;学生&quot;).doWrite(studentDataList); &#125;&#125; 运行测试类，最终结果如下图所示 读数据创建监听器 java 12345678910111213141516171819202122232425262728293031public class ExcelListener extends AnalysisEventListener&lt;StudentData&gt; &#123; /** * &lt;p&gt; * 一行一行读取数据 * &lt;/p&gt; * * @param studentData 读取到的一行数据模型对象 * @param analysisContext analysisContext */ @Override public void invoke(StudentData studentData, AnalysisContext analysisContext) &#123; System.out.println(&quot;data = &quot; + studentData); &#125; @Override public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; System.out.println(&quot;表头: &quot; + headMap); &#125; /** * &lt;p&gt; * 所有的数据读取完毕之后会自动调用 * &lt;/p&gt; * * @param analysisContext analysisContext */ @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; System.out.println(&quot;读取完毕&quot;); &#125;&#125; 读数据 java 1234567@Testpublic void ReadExcel() &#123; String fileName = &quot;D:\\\\01.xlsx&quot;; // 每读取一行数据的时候, 就会调用监听器当中的方法 EasyExcel.read(fileName, StudentData.class, new ExcelListener()).sheet().doRead();&#125; 应用到工程当中建立模型 123456789101112131415/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/4 2:22 * @description 分类excel上传的模型类 **/@Datapublic class CategoryData &#123; @ExcelProperty(index = 0) private String oneCategoryData; @ExcelProperty(index = 1) private String twoCategoryData;&#125; 创建监听器 java 12345678910111213141516171819/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/4 2:25 * @description 分类管理上传excel监听器 **/@Componentpublic class CategoryExcelListener extends AnalysisEventListener&lt;CategoryData&gt; &#123; @Override public void invoke(CategoryData categoryData, AnalysisContext analysisContext) &#123; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125;&#125; 编写控制器，用来接收文件，然后编写对应文件处理的业务 java 123456789101112131415161718192021222324/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/4 2:27 * @description 分类管理控制器 **/@RestController@RequestMapping(&quot;/service_video/category&quot;)public class CategoryController &#123; private final CategoryService categoryService; public CategoryController(CategoryService categoryService) &#123; this.categoryService = categoryService; &#125; @PostMapping(&quot;/addCategory&quot;) public ResponseResult addCategory(MultipartFile file) &#123; // 调用业务上传excel categoryService.saveCategory(file); return ResponseResult.ok(); &#125;&#125; 如上报错是因为还没有编写对应的接口和实现类所以找不到下面我们就来编写，在继续往下写之前我先来弥补一下我之前的一个错误就是把 mp 的代码生成器给删除了，这个时候要生成分类管理表相关的实体了，所以这个时候把之前的生成器代码拿回来放到测试包下，然后改一下生成的表名，把之前新建的分类管理的 Controller 删除用 mp 生成器生成的 改好了之前点击启动生成即可，这个类以后就保留着，然后把如上 Controller 写的内容复制到 mp 生成器生成的 Controller 中去即可 修改对应的业务类，修改 CategoryService 接口，也就是分类管理的接口 java 12345678/** * &lt;p&gt; * 上传excel * &lt;/p&gt; * * @param file 上传的文件 */void saveCategory(MultipartFile file); 然后就是编写业务类了，内容如下 java 123456789101112131415161718192021222324252627282930/** * &lt;p&gt; * 科目分类 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-04 */@Servicepublic class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123; /** * excel监听器 */ private final CategoryExcelListener categoryExcelListener; public CategoryServiceImpl(CategoryExcelListener categoryExcelListener) &#123; this.categoryExcelListener = categoryExcelListener; &#125; @Override public void saveCategory(MultipartFile file) &#123; // 读取excel try &#123; EasyExcel.read(file.getInputStream(), CategoryData.class, categoryExcelListener).sheet().doRead(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 剩余的内容就是完善一下我们 excel 上传解析的监听器了，主要就是在监听器当中保存数据，最终监听器代码如下 java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/4 2:25 * @description 分类管理上传excel监听器 **/@Component@Slf4jpublic class CategoryExcelListener extends AnalysisEventListener&lt;CategoryData&gt; &#123; private final CategoryService categoryService; public CategoryExcelListener(CategoryService categoryService) &#123; this.categoryService = categoryService; &#125; @Override public void invoke(CategoryData categoryData, AnalysisContext analysisContext) &#123; // 写入到数据库当中 if (!Objects.isNull(categoryData)) &#123; // 如果一级分类不存在,就保存到数据库当中 Category oneCategory = this.isExistOneCategory(categoryData); if (Objects.isNull(oneCategory)) &#123; oneCategory = new Category(); oneCategory.setTitle(categoryData.getOneCategoryData()); oneCategory.setParentId(&quot;0&quot;); categoryService.save(oneCategory); &#125; // 保存2级分类,先判断2级分类是否已经存在 Category twoCategory = this.isExistTwoCategory(categoryData, oneCategory.getId()); if (Objects.isNull(twoCategory)) &#123; twoCategory = new Category(); twoCategory.setTitle(categoryData.getTwoCategoryData()); twoCategory.setParentId(oneCategory.getId()); categoryService.save(twoCategory); &#125; &#125; &#125; /** * &lt;p&gt; * 判断1级分类是否已经存在 * &lt;/p&gt; */ private Category isExistOneCategory(CategoryData categoryData) &#123; QueryWrapper&lt;Category&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;title&quot;, categoryData.getOneCategoryData()); queryWrapper.eq(&quot;parent_id&quot;, &quot;0&quot;); return categoryService.getOne(queryWrapper); &#125; /** * &lt;p&gt; * 判断2级分类是否已经存在 * &lt;/p&gt; */ private Category isExistTwoCategory(CategoryData categoryData, String pid) &#123; QueryWrapper&lt;Category&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;title&quot;, categoryData.getTwoCategoryData()); queryWrapper.eq(&quot;parent_id&quot;, pid); return categoryService.getOne(queryWrapper); &#125; /** * &lt;p&gt; * 所有的数据读取完毕之后会自动调用 * &lt;/p&gt; */ @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; log.info(&quot;上传分类 excel 解析完毕！&quot;); &#125;&#125; 如上主要的业务就是先看看数据库存不存在当前的分类有就不添加没有就添加，核心的方法为如下 然后启动工程发现出现了循环依赖注入的问题 为啥会出现这个问题呢，可参考：https://mrbird.cc/深入理解Spring循环依赖.html 修改所有注入的地方都改为 @Resource 的方式即可 启动工程上传模板发现，报错了，模板的内容如下图所示 很明显就是我们少添加了自动填充的实体类配置 修改实体类如下 然后在修改我们之前的分类 Controller 因为少加了一些内容加的内容如下 再次重启测试效果如下图所示 22-分类管理-前端上传接口调试首先添加两个事件的回调方法一个是上传成功的，另一个是上传失败的，分别如下 javascript 123456789101112131415161718192021methods: &#123; submitUpload() &#123; this.$refs.upload.submit(); this.btnDisabled = true; this.loading = true; &#125;, uploadSuccess(response) &#123; this.loading = false; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); // 跳转到列表页 this.$router.push(&#123;path: &#x27;/category/list&#x27;&#125;); &#125;, uploadError() &#123; this.$message.error(&quot;上传失败！&quot;); &#125;&#125; 在 data 中添加需要的变量等信息 javascript 1234567data() &#123; return &#123; btnDisabled: false, loading: false, BASE_API: process.env.VUE_APP_BASE_API &#125;&#125;, 给上传服务器按钮添加加载效果如下 上传服务器的地址绑定属性值的时候需要注意如下图所示的地方要使用 : 来绑定 下载模板功能我就不做了，我在这里说一下大概怎么做吧，就是你把模板上传到服务器当中拿到下载地址然后放在对应的 a 标签中即可完成下载 23-分类管理-分类列表添加 el-tree 组件到 list.vue 当中，当然你可以直接复制我下方的整体代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom:30px;&quot;/&gt; &lt;el-tree ref=&quot;tree2&quot; :data=&quot;data2&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;list&quot;, data() &#123; return &#123; filterText: &#x27;&#x27;, data2: [&#123; id: 1, label: &#x27;Level one 1&#x27;, children: [&#123; id: 4, label: &#x27;Level two 1-1&#x27;, children: [&#123; id: 9, label: &#x27;Level three 1-1-1&#x27; &#125;, &#123; id: 10, label: &#x27;Level three 1-1-2&#x27; &#125;] &#125;] &#125;, &#123; id: 2, label: &#x27;Level one 2&#x27;, children: [&#123; id: 5, label: &#x27;Level two 2-1&#x27; &#125;, &#123; id: 6, label: &#x27;Level two 2-2&#x27; &#125;] &#125;, &#123; id: 3, label: &#x27;Level one 3&#x27;, children: [&#123; id: 7, label: &#x27;Level two 3-1&#x27; &#125;, &#123; id: 8, label: &#x27;Level two 3-2&#x27; &#125;] &#125;], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;label&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val) &#125; &#125;, methods: &#123; filterNode(value, data) &#123; if (!value) return true return data.label.indexOf(value) !== -1 &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 现在去编写后端接口，封装好对应的模型数据返回，渲染即可，在服务器端建立模型 java 12345678910111213/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/4 11:53 * @description 分类管理列表树形数据类模型 **/@Datapublic class LevelCategory &#123; private String id; private String title; private List&lt;LevelCategory&gt; children = new ArrayList&lt;&gt;();&#125; 创建 Controller 处理请求及业务，Controller 层的内容如下 java 123456789/** * &lt;p&gt; * 获取分类列表树形结构 * &lt;/p&gt; */@GetMapping(&quot;/getTreeCategory&quot;)public ResponseResult getTreeCategory() &#123; return ResponseResult.ok().data(&quot;list&quot;, categoryService.getTreeCategory());&#125; 在实现类当中创建上图中报错的那个方法如下，首先在接口当中添加方法修改 CategoryService.java java 12345678/** * &lt;p&gt; * 获取分类列表树形结构 * &lt;/p&gt; * * @return 树形结构分类Data */List&lt;LevelCategory&gt; getTreeCategory(); 紧接着就是编写实现类 java 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic List&lt;LevelCategory&gt; getTreeCategory() &#123; // 1.读取1级分类 QueryWrapper&lt;Category&gt; oneQueryWrapper = new QueryWrapper&lt;&gt;(); oneQueryWrapper.eq(&quot;parent_id&quot;, 0); List&lt;Category&gt; oneCategories = baseMapper.selectList(oneQueryWrapper); // 2.读取2级分类 QueryWrapper&lt;Category&gt; twoQueryWrapper = new QueryWrapper&lt;&gt;(); twoQueryWrapper.ne(&quot;parent_id&quot;, 0); List&lt;Category&gt; twoCategories = baseMapper.selectList(twoQueryWrapper); // 封装模型数据 List&lt;LevelCategory&gt; resultData = new ArrayList&lt;&gt;(); oneCategories.forEach(oneCategory -&gt; &#123; // 把Category转成LevelCategory LevelCategory oneLevelCategory = new LevelCategory(); // 属性的复制 // 把前一个对象当中的属性值复制到后一个对象当中相同的属性中去 // 如果前一个对象在后一个对象当中没有找到相同的属性,就不复制 BeanUtils.copyProperties(oneCategory, oneLevelCategory); // 获取当前子分类有哪些 // 遍历所有的二级分类 twoCategories.forEach(twoCategory -&gt; &#123; // 二级分类的parent_id=一级分类的id,就是当前一级分类,的子级 if (twoCategory.getParentId().equals(oneCategory.getId())) &#123; LevelCategory twoLevelCategory = new LevelCategory(); BeanUtils.copyProperties(twoCategory, twoLevelCategory); oneLevelCategory.getChildren().add(twoLevelCategory); &#125; &#125;); resultData.add(oneLevelCategory); &#125;); return resultData;&#125; 如果的业务我在代码当中写了注释，大致意思就是把一级二级都查询出来，先遍历一级，转换一级，然后在遍历二级看一下二级的父Id，是否等于一级是的话就是子分类，添加到 Children 当中，重启工程测试接口，效果如下图所示 24-分类管理-前端列表请求展示渲染编写请求接口 javascript 1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 1.获取分类数据 getCategoryData() &#123; return request(&#123; url: `/service_video/category/getTreeCategory`, method: &#x27;get&#x27; &#125;) &#125;&#125; 在列表页，导入请求，然后在调用请求 Api 拿到分类树形结构数据渲染 因为我们后台给的是 title 而且 el-tree 默认的是 lable 需要改下 最终的代码如下，参考自己写也行，复制也可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom:30px;&quot;/&gt; &lt;el-tree ref=&quot;tree&quot; :data=&quot;list&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import category from &#x27;@/api/video/category/category&#x27;;export default &#123; name: &quot;list&quot;, data() &#123; return &#123; filterText: &#x27;&#x27;, list: [], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;title&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree.filter(val) &#125; &#125;, methods: &#123; filterNode(value, data) &#123; if (!value) return true return data.title.indexOf(value) !== -1 &#125;, getTreeCategory() &#123; category.getCategoryData().then(res =&gt; &#123; this.list = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;服务器繁忙！&quot;); &#125;); &#125; &#125;, created() &#123; // 一进入页面就加载分类列表数据 this.getTreeCategory(); &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 25-作品管理-创建数据库表以及表之间的关系作品表123456789101112131415161718192021CREATE TABLE `video_content` ( `id` char(19) NOT NULL COMMENT &#x27;作品ID&#x27;, `author_id` char(19) NOT NULL COMMENT &#x27;作者ID&#x27;, `category_id` char(19) NOT NULL COMMENT &#x27;分类ID&#x27;, `category_parent_id` char(19) NOT NULL COMMENT &#x27;分类父级ID&#x27;, `title` varchar(50) NOT NULL COMMENT &#x27;作品标题&#x27;, `price` decimal(10,2) unsigned NOT NULL DEFAULT &#x27;0.00&#x27; COMMENT &#x27;价格，设置为0则可免费观看&#x27;, `conntent_num` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;作品个数&#x27;, `cover` varchar(255) CHARACTER SET utf8 NOT NULL COMMENT &#x27;作品&#x27;, `buy_count` bigint(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;销售数量&#x27;, `view_count` bigint(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;浏览数量&#x27;, `version` bigint(20) unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;乐观锁&#x27;, `status` varchar(10) NOT NULL DEFAULT &#x27;Draft&#x27; COMMENT &#x27;课程状态 Draft未发布 Normal已发布&#x27;, `is_deleted` tinyint(3) DEFAULT NULL COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_title` (`title`), KEY `idx_category_id` (`category_id`), KEY `idx_author_id` (`author_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT=&#x27;作品表&#x27;; 作品简介表1234567CREATE TABLE `video_content_description` ( `id` char(19) NOT NULL COMMENT &#x27;作品ID&#x27;, `description` text COMMENT &#x27;作品简介&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;作品简介&#x27;; 作品视频表1234567891011121314151617181920CREATE TABLE `video_content_video` ( `id` char(19) NOT NULL COMMENT &#x27;视频ID&#x27;, `course_id` char(19) NOT NULL COMMENT &#x27;作品ID&#x27;, `chapter_id` char(19) NOT NULL COMMENT &#x27;章节ID&#x27;, `title` varchar(50) NOT NULL COMMENT &#x27;节点名称&#x27;, `video_source_id` varchar(100) DEFAULT NULL COMMENT &#x27;云端视频资源&#x27;, `video_original_name` varchar(100) DEFAULT NULL COMMENT &#x27;原始文件名称&#x27;, `sort` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序字段&#x27;, `play_count` bigint(20) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;播放次数&#x27;, `is_free` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;是否可以试听：0收费 1免费&#x27;, `duration` float NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;视频时长（秒）&#x27;, `status` varchar(20) NOT NULL DEFAULT &#x27;Empty&#x27; COMMENT &#x27;Empty未上传 Transcoding转码中 Normal正常&#x27;, `size` bigint(20) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;视频源文件大小（字节）&#x27;, `version` bigint(20) unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;乐观锁&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_course_id` (`course_id`), KEY `idx_chapter_id` (`chapter_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT=&#x27;作品视频&#x27;; 作品章节表12345678910CREATE TABLE `video_chapter` ( `id` char(19) NOT NULL COMMENT &#x27;章节ID&#x27;, `course_id` char(19) NOT NULL COMMENT &#x27;作品ID&#x27;, `title` varchar(50) NOT NULL COMMENT &#x27;章节名称&#x27;, `sort` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;显示排序&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_course_id` (`course_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT=&#x27;作品章节&#x27;; 表之间的关系 26-作品管理-作品信息管理Mp 生成表对应层级代码修改 CodeGeneratorTest.java 复制出一个全新的测试方式，就是用来存储上一个章节中新建的表，如下 java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/** * @author BNTang */public class CodeGeneratorTest &#123; @Test public void generate_video_author() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_video\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成 service 层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_video&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;video_author&quot;); // 数据库表映射到实体的命名策略,驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;video_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125; @Test public void generate_video_category() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_video\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成 service 层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_video&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;video_category&quot;); // 数据库表映射到实体的命名策略,驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;video_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125; @Test public void generate_video_chapter_video_content_video_content_description_video_content_video() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_video\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成 service 层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_video&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;video_chapter&quot;, &quot;video_content&quot;, &quot;video_content_description&quot;, &quot;video_content_video&quot;); // 数据库表映射到实体的命名策略,驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;video_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 直接拷贝我的即可，你也可以自行修改，供参考 编写后端保存基本信息, 接收请求, 在接收之前首先先添加一个 VO 实体，实体代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author BNTang */@Datapublic class ContentVO &#123; private String id; /** * 标题 */ private String title; /** * 二级分类ID */ private String categoryId; /** * 一级分类ID */ private String categoryParentId; /** * 作者id */ private String authorId; /** * 总视频数 */ private Integer contentNum; /** * 简介 */ private String description; /** * 封面 */ private String cover; /** * 价格 */ private BigDecimal price;&#125; 紧接着修改 ContentController 内容如下 12345678910111213141516171819202122/** * &lt;p&gt; * 作品表 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@RestController@RequestMapping(&quot;/service_video/content&quot;)@Api(tags = &quot;作品组&quot;)@CrossOriginpublic class ContentController &#123; @Resource private ContentService contentService; @PostMapping(&quot;/addContentInfo&quot;) public ResponseResult addContentInfo(ContentVO contentVO) &#123; // 调用contentService处理添加作品信息业务 return ResponseResult.ok().data(&quot;contentId&quot;, contentService.saveContentInfo(contentVO)); &#125;&#125; 在对应的接口当中添加对应的方法如下不贴图了，不重要的部分 1234567891011121314151617181920/** * &lt;p&gt; * 作品表 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */public interface ContentService extends IService&lt;Content&gt; &#123; /** * &lt;p&gt; * 保存基本信息 * &lt;/p&gt; * * @param contentVO 基本信息实体VO * @return 添加之后生成的ID */ String saveContentInfo(ContentVO contentVO);&#125; 实现业务方法，分为两步，一，先保存基本信息，获取自增ID后再保存简介设置简介ID为刚刚自增之后得到的ID入库 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * 作品表 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@Servicepublic class ContentServiceImpl extends ServiceImpl&lt;ContentMapper, Content&gt; implements ContentService &#123; /** * 注入简介的业务 保存简介 */ @Resource private ContentDescriptionService contentDescriptionService; @Override public String saveContentInfo(ContentVO contentVO) &#123; // 1.保存基本信息 Content content = new Content(); BeanUtils.copyProperties(contentVO, content); // 1.1.保存到数据当中 baseMapper.insert(content); // 2.保存简介 // 2.1.获取刚保存基本信息的id,之后再设置自己的简介id String id = content.getId(); ContentDescription contentDescription = new ContentDescription(); contentDescription.setId(id); contentDescription.setDescription(contentVO.getDescription()); contentDescriptionService.save(contentDescription); return id; &#125;&#125; 基本信息修改，后端接口，获取一条数据，ContentController 123456789/** * &lt;p&gt; * 根据ID获取一条作品简介信息数据 * &lt;/p&gt; */@GetMapping(&quot;/getContentWithInfoId/&#123;id&#125;&quot;)public ResponseResult getContentWithInfoId(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;contentVO&quot;, contentService.getContentWithInfoId(id));&#125; 修改 ContentService 123456789/** * &lt;p&gt; * 根据ID获取一条作品简介信息数据 * &lt;/p&gt; * * @param id 作品ID * @return 作品简介信息 */ContentVO getContentWithInfoId(String id); 修改 ContentServiceImpl 123456789101112@Overridepublic ContentVO getContentWithInfoId(String id) &#123; ContentVO contentVO = new ContentVO(); // 查询基本信息 Content content = baseMapper.selectById(id); BeanUtils.copyProperties(content, contentVO); // 查询简介信息 ContentDescription description = contentDescriptionService.getById(id); contentVO.setDescription(description.getDescription()); return contentVO;&#125; 添加，修改作品基本信息接口，修改 ContentController 12345678910/** * &lt;p&gt; * 修改作品基本信息 * &lt;/p&gt; */@PostMapping(&quot;updateContentInfo&quot;)public ResponseResult updateContentInfo(@RequestBody ContentVO contentVO) &#123; contentService.updateContentInfo(contentVO); return ResponseResult.ok();&#125; 修改 ContentService 12345678/** * &lt;p&gt; * 修改作品基本信息 * &lt;/p&gt; * * @param contentVO 基本信息VO实体 */void updateContentInfo(ContentVO contentVO); 修改 ContentServiceImpl 12345678910111213@Overridepublic void updateContentInfo(ContentVO contentVO) &#123; // 1.修改基本信息 Content content = new Content(); BeanUtils.copyProperties(contentVO, content); baseMapper.updateById(content); // 2.修改描述信息 ContentDescription contentDescription = new ContentDescription(); contentDescription.setId(content.getId()); contentDescription.setDescription(contentVO.getDescription()); contentDescriptionService.updateById(contentDescription);&#125; 27-作品管理-作品信息管理(前端)基本信息路由配置首先是基础路由 javascript 123456789101112131415161718192021&#123; path: &#x27;/content&#x27;, component: Layout, redirect: &#x27;/content/list&#x27;, name: &#x27;作品管理&#x27;, meta: &#123; title: &#x27;作品管理&#x27;, icon: &#x27;el-icon-s-help&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;作品列表&#x27;, component: () =&gt; import(&#x27;@/views/video/content/list&#x27;), meta: &#123; title: &#x27;作品列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;info&#x27;, name: &#x27;添加作品&#x27;, component: () =&gt; import(&#x27;@/views/video/content/info&#x27;), meta: &#123; title: &#x27;添加作品&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ]&#125;, 添加切换路由 javascript 123456789101112131415161718192021&#123; path: &#x27;info/:id&#x27;, name: &#x27;添加作品&#x27;, component: () =&gt; import(&#x27;@/views/video/content/info&#x27;), meta: &#123;title: &#x27;添加作品&#x27;, icon: &#x27;tree&#x27;&#125;, hidden: true&#125;,&#123; path: &#x27;chapter/:id&#x27;, name: &#x27;章节信息&#x27;, component: () =&gt; import(&#x27;@/views/video/content/chapter&#x27;), meta: &#123;title: &#x27;章节信息&#x27;, icon: &#x27;tree&#x27;&#125;, hidden: true&#125;,&#123; path: &#x27;send/:id&#x27;, name: &#x27;最终发布&#x27;, component: () =&gt; import(&#x27;@/views/video/content/send&#x27;), meta: &#123;title: &#x27;最终发布&#x27;, icon: &#x27;tree&#x27;&#125;, hidden: true&#125; 如上的路由的配置主要是用来进行组件之间切换的时候使用的，自行把对应的组件新建好，如下图 到了这里，可以自行的把前端跑起来看一下 编写添加界面info，基础界面 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;添加作品&lt;/h1&gt; &lt;el-steps :active=&quot;1&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label-width=&quot;作品标题&quot;&gt; &lt;el-input placeholder=&quot;请填写作品标题&quot;/&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;info&quot;, data() &#123; return &#123; active: 0 &#125;; &#125;, methods: &#123; next() &#123; // 路由跳转 this.$router.push(&#123;path: &#x27;/content/chapter/1&#x27;&#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; chapter，基础界面 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;章节信息&lt;/h1&gt; &lt;el-steps :active=&quot;2&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;h1&gt;章节信息&lt;/h1&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;pre&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;chapter&quot;, data() &#123; return &#123; active: 0 &#125;; &#125;, methods: &#123; pre() &#123; this.$router.push(&#123;path: &#x27;/content/info/1&#x27;&#125;) &#125;, next() &#123; this.$router.push(&#123;path: &#x27;/content/send/1&#x27;&#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; send，基础界面 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;最终发布&lt;/h1&gt; &lt;el-steps :active=&quot;3&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;pre&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button style=&quot;margin-top: 12px;&quot;&gt;发布&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;send&quot;, data() &#123; return &#123; active: 0 &#125;; &#125;, methods: &#123; pre() &#123; this.$router.push(&#123;path: &#x27;/content/chapter/1&#x27;&#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 组件之间的跳转基本信息保存下一步，首先来新建一个编写 api 请求的文件如下 javascript 12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 1.作者列表-分页查询 getAuthorList() &#123; return request(&#123; url: `/service_video/author/getAuthorList`, method: &#x27;get&#x27; &#125;) &#125;, // 2.添加作品信息 addContentInfo(contentVO) &#123; return request(&#123; url: `/service_video/content/addContentInfo`, method: &#x27;post&#x27;, data: contentVO &#125;) &#125;,&#125; javascript 123456789101112saveAndNext() &#123; content.addContentInfo(this.contentVO).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); //路由跳转 this.$router.push(&#123;path: &#x27;/content/chapter/&#x27; + res.data.contentId&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&quot;添加失败&quot;); &#125;)&#125; 发布作品界面模型绑定 javascript 123456789101112131415161718192021222324252627282930313233data() &#123; return &#123; active: 0, contentVO: &#123; // 标题 title: &#x27;&#x27;, // 二级分类ID categoryId: &#x27;&#x27;, // 一级分类ID categoryParentId: &#x27;&#x27;, // 作者id authorId: &#x27;&#x27;, // 总视频数 contentNum: &#x27;&#x27;, // 简介 description: &#x27;&#x27;, // 封面 cover: require(&#x27;@/assets/images/cover.jpg&#x27;), price: 0 &#125;, // 作者列表 authorList: [], // 一级分类列表 oneCategoryList: [], // 二级分类列表 twoCategoryList: [], // 请求API地址 BASE_API: process.env.VUE_APP_BASE_API &#125;;&#125;, 你也可以自己使用自己喜欢的素材图片，当然了我这里给出我文章中的素材占位图片下载地址：https://wws.lanzous.com/i5lrvnv53eb 界面绑定模型数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;添加作品&lt;/h1&gt; &lt;el-steps :active=&quot;1&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot; style=&quot;margin-top: 10px&quot;&gt; &lt;!-- 标题 --&gt; &lt;el-form-item label=&quot;作品标题&quot;&gt; &lt;el-input placeholder=&quot;请填写作品标题&quot; v-model=&quot;contentVO.title&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 分类 --&gt; &lt;el-form-item label=&quot;作品分类&quot;&gt; &lt;el-select placeholder=&quot;一级分类&quot; v-model=&quot;contentVO.categoryParentId&quot; @change=&quot;oneCategoryChanged&quot;&gt; &lt;el-option v-for=&quot;oneCategory in oneCategoryList&quot; :key=&quot;oneCategory.id&quot; :label=&quot;oneCategory.title&quot; :value=&quot;oneCategory.id&quot;/&gt; &lt;/el-select&gt; &amp;nbsp; &lt;el-select placeholder=&quot;二级分类&quot; v-model=&quot;contentVO.categoryId&quot;&gt; &lt;el-option v-for=&quot;oneCategory in twoCategoryList&quot; :key=&quot;oneCategory.id&quot; :label=&quot;oneCategory.title&quot; :value=&quot;oneCategory.id&quot;/&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 作者 --&gt; &lt;el-form-item label=&quot;作者&quot;&gt; &lt;el-select placeholder=&quot;选择作者&quot; v-model=&quot;contentVO.authorID&quot;&gt; &lt;el-option v-for=&quot;author in authorList&quot; :key=&quot;author.id&quot; :label=&quot;author.name&quot; :value=&quot;author.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 总视频数 --&gt; &lt;el-form-item label=&quot;总视频数&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;总视频数&quot; v-model=&quot;contentVO.contentNum&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 简介 --&gt; &lt;el-form-item label=&quot;作品简介&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;简介&quot; v-model=&quot;contentVO.description&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 封面 --&gt; &lt;el-form-item label=&quot;作品封面&quot;&gt; &lt;el-upload :show-file-list=&quot;false&quot; :action=&quot;BASE_API+&#x27;/service_upload/file/ossUploadFile&#x27;&quot; :on-success=&quot;uploadSuccess&quot; :limit=&quot;1&quot; name=&quot;file&quot; &gt; &lt;img :src=&quot;contentVO.cover&quot; style=&quot;width: 300px; height: 150px&quot;/&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;!-- 价格 --&gt; &lt;el-form-item label=&quot;价格&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;价格&quot; v-model=&quot;contentVO.price&quot;/&gt; &lt;/el-form-item&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; type=&quot;primary&quot; @click=&quot;saveAndNext&quot;&gt;基本信息保存下一步&lt;/el-button&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt; 在点击按钮之前还需要处理一下后台(等待后续所有的准备都做好了在点击进行测试按照如下步骤走)，作品ID不能让其自动生成 ，要自己手动设置需要设置成 input 紧接着修改一下作品表的实体类，对创建时间和更新时间，逻辑删除字段进行处理如下, 当然如上图中的作品简介的也是同理，后面所有生成的实体类当中都应该设置自动填充属性，至于逻辑删除我在一一强调即可 处理下拉列表数据，首先导入对应需要使用到的 api 文件如下 javascript 12import content from &quot;@/api/video/content/content&quot;;import category from &quot;@/api/video/category/category&quot;; 在这里我说明一个东西，那么就是关于 el-steps 组件的问题，我这里是单独的新建了三个不同的组件进行的是组件之间的跳转，并不是 el-steps 的跳转，所以每个页面的 el-steps 状态值都是固定写死了，例如下图中的状态 作者列表 javascript 12345678// 加载所有的作者下拉列表getAuthorList() &#123; content.getAuthorList().then(res =&gt; &#123; this.authorList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;系统繁忙！&quot;); &#125;);&#125;, javascript 1234created() &#123; // 加载所有的作者下拉列表 this.getAuthorList();&#125; 修改一下后端加载所有创作者列表的接口，返回值不是我们需要的，因为是在写 ResponseResult 之前写的，所以没有改造为这种形式需要改造一下如下图 渲染创作者下拉列表 分类列表 javascript 123456789// 加载所有的分类getCategoryList() &#123; // 1.获取一级分类 category.getCategoryData().then(res =&gt; &#123; this.oneCategoryList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;系统繁忙！&quot;); &#125;);&#125;, 实现当一级分类发生改变时的监听事件 javascript 123456789101112// 当一级分类改变时调用的方法，参数：当前选择的一级分类IDoneCategoryChanged(value) &#123; for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; let category = this.oneCategoryList[i]; if (value === category.id) &#123; this.twoCategoryList = category.children; // 清空已经选择的二级分类列表 this.contentVO.categoryId = &#x27;&#x27;; &#125; &#125;&#125;, 渲染分类数据方式如下 完善上传封面功能，OSS上传接口在之前就已经写好了调用一下即可 1234567891011121314&lt;!--封面--&gt;&lt;el-form-item label=&quot;作品封面&quot;&gt; &lt;el-upload :show-file-list=&quot;false&quot; :action=&quot;BASE_API+&#x27;/service_upload/file/uploadOssFile&#x27;&quot; :on-success=&quot;uploadSuccess&quot; :limit=&quot;1&quot; name=&quot;file&quot; &gt; &lt;img :src=&quot;contentVO.cover&quot; style=&quot;width: 300px; height: 150px&quot;/&gt; &lt;/el-upload&gt;&lt;/el-form-item&gt; javascript 123uploadSuccess(res, file) &#123; this.contentVO.cover = res.data.url;&#125; 到这里添加的准备都已经完成了，还需要修改一下后端的添加接口，因为是 POST 请求，而参数又是一个对象我少加了一个 @RequestBody 注解如下图自行加上之后在测试添加即可，填写对应的信息 可以看到我这里已经成功了 基本信息修改数据回显，首先在 data 中声明一个 contentId 属性如下 然后在 created 处于loading结束后，还做一些初始化，实现函数自执行（data 数据已经初始化，但是 DOM 结构渲染完成，组件没有加载）中做数据回显 javascript 123456789101112131415created() &#123; // 思路为：判断路由当中有没有ID，如果有，就是修改，做数据回显 // 获取路由当中的ID if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.contentId = this.$route.params.id; // 根据ID查询当前的作品，进行信息回显 this.getInfo(); &#125; else &#123; // 加载所有的作者下拉列表 this.getAuthorList(); // 加载所有的分类 this.getCategoryList(); &#125;&#125; 修改一下模型绑定的创作者 ID，将ID 改为 Id 根据ID查询当前的作品，进行信息回显, this.getInfo(); 内容如下 javascript 1234567891011121314151617181920// 根据id获取作品信息getInfo() &#123; content.getContentWithInfoId(this.contentId).then(res =&gt; &#123; this.contentVO = res.data.contentVO; // 1.获取一级分类 category.getCategoryData().then(res =&gt; &#123; this.oneCategoryList = res.data.list; // 遍历每一个一级分类 , 判断当前的contentVO 是属于哪一个一级分类 for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; let oneCategory = this.oneCategoryList[i]; if (oneCategory.id === this.contentVO.categoryParentId) &#123; this.twoCategoryList = oneCategory.children; &#125; &#125; &#125;); //加载作者列表 this.getAuthorList(); &#125;);&#125;, 紧接着修改 saveAndNext 主要就是判断有 ID 就是更新没有就是添加的操作 javascript 123456789101112131415161718192021222324252627saveAndNext() &#123; // 判断当前是添加还是更新 if (this.contentId === &#x27;&#x27;) &#123; content.addContentInfo(this.contentVO).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); //路由跳转 this.$router.push(&#123;path: &#x27;/content/chapter/&#x27; + res.data.contentId&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&quot;添加失败&quot;); &#125;) &#125; else &#123; // 更新操作 content.updateContentInfo(this.contentVO).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); // 路由跳转跳转到章节 this.$router.push(&#123;path: &#x27;/content/chapter/&#x27; + this.contentId&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&quot;更新失败&quot;); &#125;) &#125;&#125;, 最终 info.vue 代码如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;添加作品&lt;/h1&gt; &lt;el-steps :active=&quot;1&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot; style=&quot;margin-top: 10px&quot;&gt; &lt;!-- 标题 --&gt; &lt;el-form-item label=&quot;作品标题&quot;&gt; &lt;el-input placeholder=&quot;请填写作品标题&quot; v-model=&quot;contentVO.title&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 分类 --&gt; &lt;el-form-item label=&quot;作品分类&quot;&gt; &lt;el-select placeholder=&quot;一级分类&quot; v-model=&quot;contentVO.categoryParentId&quot; @change=&quot;oneCategoryChanged&quot;&gt; &lt;el-option v-for=&quot;oneCategory in oneCategoryList&quot; :key=&quot;oneCategory.id&quot; :label=&quot;oneCategory.title&quot; :value=&quot;oneCategory.id&quot;/&gt; &lt;/el-select&gt; &amp;nbsp; &lt;el-select placeholder=&quot;二级分类&quot; v-model=&quot;contentVO.categoryId&quot;&gt; &lt;el-option v-for=&quot;oneCategory in twoCategoryList&quot; :key=&quot;oneCategory.id&quot; :label=&quot;oneCategory.title&quot; :value=&quot;oneCategory.id&quot;/&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 作者 --&gt; &lt;el-form-item label=&quot;作者&quot;&gt; &lt;el-select placeholder=&quot;选择作者&quot; v-model=&quot;contentVO.authorId&quot;&gt; &lt;el-option v-for=&quot;author in authorList&quot; :key=&quot;author.id&quot; :label=&quot;author.name&quot; :value=&quot;author.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 总视频数 --&gt; &lt;el-form-item label=&quot;总视频数&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;总视频数&quot; v-model=&quot;contentVO.contentNum&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 简介 --&gt; &lt;el-form-item label=&quot;作品简介&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;简介&quot; v-model=&quot;contentVO.description&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 封面 --&gt; &lt;el-form-item label=&quot;作品封面&quot;&gt; &lt;el-upload :show-file-list=&quot;false&quot; :action=&quot;BASE_API+&#x27;/service_upload/file/uploadOssFile&#x27;&quot; :on-success=&quot;uploadSuccess&quot; :limit=&quot;1&quot; name=&quot;file&quot; &gt; &lt;img :src=&quot;contentVO.cover&quot; style=&quot;width: 300px; height: 150px&quot;/&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;!-- 价格 --&gt; &lt;el-form-item label=&quot;价格&quot;&gt; &lt;el-input :min=&quot;0&quot; placeholder=&quot;价格&quot; v-model=&quot;contentVO.price&quot;/&gt; &lt;/el-form-item&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; type=&quot;primary&quot; @click=&quot;saveAndNext&quot;&gt;基本信息保存下一步&lt;/el-button&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import content from &quot;@/api/video/content/content&quot;;import category from &quot;@/api/video/category/category&quot;;export default &#123; name: &quot;info&quot;, data() &#123; return &#123; contentVO: &#123; // 标题 title: &#x27;&#x27;, // 二级分类ID categoryId: &#x27;&#x27;, // 一级分类ID categoryParentId: &#x27;&#x27;, // 作者id authorId: &#x27;&#x27;, // 总视频数 contentNum: &#x27;&#x27;, // 简介 description: &#x27;&#x27;, // 封面 cover: require(&#x27;@/assets/images/cover.jpg&#x27;), price: 0 &#125;, // 作品的ID contentId: &#x27;&#x27;, // 作者列表 authorList: [], // 一级分类列表 oneCategoryList: [], // 二级分类列表 twoCategoryList: [], // 请求API地址 BASE_API: process.env.VUE_APP_BASE_API &#125;; &#125;, methods: &#123; saveAndNext() &#123; // 判断当前是添加还是更新 if (this.contentId === &#x27;&#x27;) &#123; content.addContentInfo(this.contentVO).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); //路由跳转 this.$router.push(&#123;path: &#x27;/content/chapter/&#x27; + res.data.contentId&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&quot;添加失败&quot;); &#125;) &#125; else &#123; // 更新操作 content.updateContentInfo(this.contentVO).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); // 路由跳转跳转到章节 this.$router.push(&#123;path: &#x27;/content/chapter/&#x27; + this.contentId&#125;) &#125;).catch(error =&gt; &#123; this.$message.error(&quot;更新失败&quot;); &#125;) &#125; &#125;, // 加载所有的作者下拉列表 getAuthorList() &#123; content.getAuthorList().then(res =&gt; &#123; this.authorList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;系统繁忙！&quot;); &#125;); &#125;, // 加载所有的分类 getCategoryList() &#123; // 1.获取一级分类 category.getCategoryData().then(res =&gt; &#123; this.oneCategoryList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;系统繁忙！&quot;); &#125;); &#125;, // 当一级分类改变时调用的方法，参数：当前选择的一级分类ID oneCategoryChanged(value) &#123; for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; let category = this.oneCategoryList[i]; if (value === category.id) &#123; this.twoCategoryList = category.children; // 清空已经选择的二级分类列表 this.contentVO.categoryId = &#x27;&#x27;; &#125; &#125; &#125;, uploadSuccess(res, file) &#123; this.contentVO.cover = res.data.url; &#125;, // 根据id获取作品信息 getInfo() &#123; content.getContentWithInfoId(this.contentId).then(res =&gt; &#123; this.contentVO = res.data.contentVO; // 1.获取一级分类 category.getCategoryData().then(res =&gt; &#123; this.oneCategoryList = res.data.list; // 遍历每一个一级分类 , 判断当前的contentVO 是属于哪一个一级分类 for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; let oneCategory = this.oneCategoryList[i]; if (oneCategory.id === this.contentVO.categoryParentId) &#123; this.twoCategoryList = oneCategory.children; &#125; &#125; &#125;); //加载作者列表 this.getAuthorList(); &#125;); &#125;, &#125;, created() &#123; // 思路为：判断路由当中有没有ID，如果有，就是修改，做数据回显 // 获取路由当中的ID if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.contentId = this.$route.params.id; // 根据ID查询当前的作品，进行信息回显 this.getInfo(); &#125; else &#123; // 加载所有的作者下拉列表 this.getAuthorList(); // 加载所有的分类 this.getCategoryList(); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 紧接着就是修改 content.js 把对应的 api 请求方法加上 javascript 123456789101112131415// 3.根据id获取作品信息getContentWithInfoId(id) &#123; return request(&#123; url: `/service_video/content/getContentWithInfoId/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;);&#125;,// 4.更新操作updateContentInfo(contentVO) &#123; return request(&#123; url: `/service_video/content/updateContentInfo`, method: &#x27;post&#x27;, data: contentVO &#125;);&#125;, 紧接着后端还需要完善一些信息，内容分别如下，首先是配置逻辑删除的自动填充配置如下，修改 common_base 模块中的 MyMetaObjectHandler 如下所示 在添加逻辑删除，添加数据的时候自动填充注解如下 紧接着就是把数据库里面的字段修正，单词打错了，执行如下 ALTER 语句即可修正，修改完成之后自行测试即可 12ALTER TABLE `video_db`.`video_content` CHANGE COLUMN `conntent_num` `content_num` int UNSIGNED NOT NULL DEFAULT 0 COMMENT &#x27;作品个数&#x27; AFTER `price`; 28-作品管理-作品章节管理页面 章节列表后端数据库模拟数据 自己去你自己的 video_content 表中找一个 id 然后替换一下我下方的SQL脚本中的ID，然后执行即可 sql 12INSERT INTO `video_db`.`video_chapter` (`id`, `course_id`, `title`, `sort`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1&#x27;, &#x27;1380737860695597058&#x27;, &#x27;第一章节&#x27;, 0, &#x27;2021-04-10 14:31:58&#x27;, &#x27;2021-04-10 14:32:01&#x27;);INSERT INTO `video_db`.`video_chapter` (`id`, `course_id`, `title`, `sort`, `gmt_create`, `gmt_modified`) VALUES (&#x27;2&#x27;, &#x27;1380737860695597058&#x27;, &#x27;第二章节&#x27;, 0, &#x27;2021-04-10 14:31:58&#x27;, &#x27;2021-04-10 14:32:01&#x27;); sql 123INSERT INTO `video_db`.`video_content_video` (`id`, `course_id`, `chapter_id`, `title`, `video_source_id`, `video_original_name`, `sort`, `play_count`, `is_free`, `duration`, `status`, `size`, `version`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1&#x27;, &#x27;1380737860695597058&#x27;, &#x27;1&#x27;, &#x27;第1小节&#x27;, NULL, NULL, 0, 0, 0, 0, &#x27;Empty&#x27;, 0, 1, &#x27;2021-04-10 14:33:03&#x27;, &#x27;2021-04-10 14:33:05&#x27;);INSERT INTO `video_db`.`video_content_video` (`id`, `course_id`, `chapter_id`, `title`, `video_source_id`, `video_original_name`, `sort`, `play_count`, `is_free`, `duration`, `status`, `size`, `version`, `gmt_create`, `gmt_modified`) VALUES (&#x27;2&#x27;, &#x27;1380737860695597058&#x27;, &#x27;1&#x27;, &#x27;第2小节&#x27;, NULL, NULL, 0, 0, 0, 0, &#x27;Empty&#x27;, 0, 1, &#x27;2021-04-10 14:33:03&#x27;, &#x27;2021-04-10 14:33:05&#x27;);INSERT INTO `video_db`.`video_content_video` (`id`, `course_id`, `chapter_id`, `title`, `video_source_id`, `video_original_name`, `sort`, `play_count`, `is_free`, `duration`, `status`, `size`, `version`, `gmt_create`, `gmt_modified`) VALUES (&#x27;3&#x27;, &#x27;1380737860695597058&#x27;, &#x27;2&#x27;, &#x27;第1小节&#x27;, NULL, NULL, 0, 0, 0, 0, &#x27;Empty&#x27;, 0, 1, &#x27;2021-04-10 14:33:03&#x27;, &#x27;2021-04-10 14:33:05&#x27;); 定义对应的 VO 实体 ContentVideoVO java 123456789101112131415161718192021222324/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/10 14:37 * @description 小节信息VO **/@Datapublic class ContentVideoVO implements Serializable &#123; /** * id */ private String id; /** * 小节标题 */ private String title; /** * 小节是否免费 */ private Boolean free;&#125; ChapterVO java 1234567891011121314151617/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/10 14:36 * @description 作品章节VO，作品章节信息 **/@Datapublic class ChapterVO &#123; private String id; private String title; /** * 章节下的小节信息 */ private List&lt;ContentVideoVO&gt; children;&#125; 定义查询嵌套章节与小节信息的数据结构接口 java 123456789/** * &lt;b&gt; * 获取章节嵌套形式的数据结构列表 * &lt;/b&gt; * * @param contentId 作品ID * @return 章节小节嵌套形式的数据结构 */List&lt;ChapterVO&gt; getChapterSection(String contentId); 完善嵌套章节与小节信息数据结构业务 java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;p&gt; * 作品章节 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@Servicepublic class ChapterServiceImpl extends ServiceImpl&lt;ChapterMapper, Chapter&gt; implements ChapterService &#123; @Resource private ContentVideoService contentVideoService; @Override public List&lt;ChapterVO&gt; getChapterSection(String contentId) &#123; // 1.根据课程id查询课程里面所有的章节(章节) QueryWrapper&lt;Chapter&gt; chapterQueryWrapper = new QueryWrapper&lt;&gt;(); chapterQueryWrapper.eq(&quot;content_id&quot;, contentId); List&lt;Chapter&gt; chapterList = baseMapper.selectList(chapterQueryWrapper); // 2.根据课程id查询课程里面所有的小节(小节) QueryWrapper&lt;ContentVideo&gt; videoQueryWrapper = new QueryWrapper&lt;&gt;(); videoQueryWrapper.eq(&quot;content_id&quot;, contentId); List&lt;ContentVideo&gt; contentVideoList = contentVideoService.list(videoQueryWrapper); return chapterList.stream().map(m -&gt; &#123; ChapterVO chapterVO = new ChapterVO(); // chapter对象值复制到ChapterVo里面 ChapterVO chapterVo = new ChapterVO(); BeanUtils.copyProperties(m, chapterVo); // 创建集合，用于封装章节的小节 List&lt;ContentVideoVO&gt; subsectionList = new ArrayList&lt;&gt;(); // 4.遍历查询小节list集合，进行封装 contentVideoList.forEach(a1 -&gt; &#123; // 判断：小节里面chapterId和章节里面id是否一样 if (a1.getChapterId().equals(m.getId())) &#123; // 进行封装 ContentVideoVO videoVo = new ContentVideoVO(); BeanUtils.copyProperties(a1, videoVo); // 放到小节封装集合 subsectionList.add(videoVo); &#125; &#125;); // 把封装之后小节list集合，放到章节对象里面 chapterVo.setChildren(subsectionList); return chapterVO; &#125;).collect(Collectors.toList()); &#125;&#125; Controller 层代码如下 java 12345678910111213141516171819202122232425262728/** * &lt;p&gt; * 作品章节 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@RestController@CrossOrigin@RequestMapping(&quot;/service_video/chapter&quot;)@Api(tags = &quot;作品章节组&quot;)public class ChapterController &#123; @Resource private ChapterService chapterService; /** * &lt;b&gt; * 获取章节嵌套形式的数据结构列表 * &lt;/b&gt; */ @ApiOperation(value = &quot;获取章节嵌套形式的数据结构列表&quot;) @GetMapping(&quot;getChapterContentVideo/&#123;contentId&#125;&quot;) public ResponseResult getChapterSection(@PathVariable String contentId) &#123; return ResponseResult.ok().data(&quot;items&quot;, chapterService.getChapterSection(contentId)); &#125;&#125; 前端在 api 当中创建 chapter.js 123456789101112import request from &#x27;@/utils/request&#x27;const apiName = &#x27;/service_video/chapter&#x27;export default &#123; getNestedTreeList(contentId) &#123; return request(&#123; url: `$&#123;apiName&#125;/getChapterContentVideo/$&#123;contentId&#125;`, method: &#x27;get&#x27; &#125;) &#125;&#125; 在 chapter.vue 页面当中加载章节小节列表信息 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt;import chapter from &#x27;@/api/video/content/chapter&#x27;;export default &#123; data() &#123; return &#123; active: 0, // 作品ID contentId: &#x27;&#x27;, // 章节嵌套小节列表 chapterNestedList: [] &#125;; &#125;, created() &#123; // 获取路由当中的id if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 获取当前作品id this.contentId = this.$route.params.id; // 请求嵌套数据 this.getNestedTreeList(); &#125; &#125;, methods: &#123; getNestedTreeList() &#123; chapter.getNestedTreeList(this.contentId).then(response =&gt; &#123; this.chapterNestedList = response.data.items; &#125;) &#125;, pre() &#123; this.$router.push(&#123;path: &#x27;/content/info/&#x27; + this.contentId&#125;) &#125;, next() &#123; this.$router.push(&#123;path: &#x27;/content/send/&#x27; + this.contentId&#125;) &#125; &#125;&#125;&lt;/script&gt; 页面结构如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;章节信息&lt;/h1&gt; &lt;el-steps :active=&quot;2&quot; finish-status=&quot;success&quot;&gt; &lt;el-step title=&quot;填写作品基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;添加章节视频&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;完成&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-button type=&quot;text&quot;&gt;添加章节&lt;/el-button&gt; &lt;!-- 章节 --&gt; &lt;ul class=&quot;chapterList&quot;&gt; &lt;li v-for=&quot;chapter in chapterList&quot; :key=&quot;chapter.id&quot;&gt; &lt;p&gt; &#123;&#123; chapter.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button type=&quot;text&quot;&gt;添加小节&lt;/el-button&gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;text&quot;&gt;删除&lt;/el-button&gt; &lt;/span&gt; &lt;/p&gt; &lt;!-- 视频 --&gt; &lt;ul class=&quot;chapterListList sectionList&quot;&gt; &lt;li v-for=&quot;section in chapter.children&quot; :key=&quot;section.id&quot;&gt; &lt;p&gt; &#123;&#123; section.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button type=&quot;text&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;text&quot;&gt;删除&lt;/el-button&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;pre&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button style=&quot;margin-top: 12px;&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; 样式代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;style scoped&gt;ul &#123; list-style: none;&#125;.chapterList &#123; position: relative; list-style: none; margin: 0; padding: 0;&#125;.chapterList li &#123; position: relative;&#125;.chapterList p &#123; float: left; font-size: 20px; margin: 10px 0; padding: 10px; height: 70px; line-height: 50px; width: 100%; border: 1px solid #DDD;&#125;.chapterList .acts &#123; float: right; font-size: 14px;&#125;.sectionList &#123; padding-left: 50px;&#125;.sectionList p &#123; float: left; font-size: 14px; margin: 10px 0; padding: 10px; height: 50px; line-height: 30px; width: 100%; border: 1px dashed #DDD;&#125;&lt;/style&gt; 章节管理后端在 common_base 工程当中添加自定义异常 123456789101112131415161718192021/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/10 17:27 * @description 自定义异常 **/@EqualsAndHashCode(callSuper = true)@Data@AllArgsConstructorpublic class BnTangException extends RuntimeException &#123; /** * 状态码 */ private Integer code; /** * 异常信息 */ private String msg;&#125; 然后在全局异常处理器当中处理我们自己抛出的自定义异常 1234567891011/** * &lt;b&gt; * 自定义异常 * &lt;/b&gt; */@ExceptionHandler(BnTangException.class)@ResponseBodypublic ResponseResult error(BnTangException e) &#123; e.printStackTrace(); return ResponseResult.error().code(e.getCode()).message(e.getMsg());&#125; 接下来就都是修改 ChapterController 了如下 新增章节 12345678910/** * &lt;b&gt; * 新增章节 * &lt;/b&gt; */@PostMapping(&quot;/addChapter&quot;)public ResponseResult addChapter(@RequestBody Chapter chapter) &#123; chapterService.save(chapter); return ResponseResult.ok();&#125; 根据 ID 查询章节123456789101112/** * &lt;b&gt; * 根据 ID 查询章节 * &lt;/b&gt; */@GetMapping(&quot;/getChapterById/&#123;id&#125;&quot;)@ApiOperation(value = &quot;根据 ID 查询章节&quot;)public ResponseResult getChapterById(@ApiParam(name = &quot;id&quot;, value = &quot;章节ID&quot;, required = true) @PathVariable String id) &#123; Chapter chapter = chapterService.getById(id); return ResponseResult.ok().data(&quot;item&quot;, chapter);&#125; 根据 ID 修改章节123456789101112/** * &lt;b&gt; * 根据ID修改章节 * &lt;/b&gt; */@ApiOperation(value = &quot;根据ID修改章节&quot;)@PutMapping(&quot;updateChapterById/&#123;id&#125;&quot;)public ResponseResult updateChapterById(@PathVariable String id, @RequestBody Chapter chapter) &#123; chapter.setId(id); chapterService.updateById(chapter); return ResponseResult.ok();&#125; 根据 ID 删除章节1234567891011/** * &lt;b&gt; * 根据ID删除章节 * &lt;/b&gt; */@ApiOperation(value = &quot;根据ID删除章节&quot;)@DeleteMapping(&quot;deleteChapterById/&#123;id&#125;&quot;)public ResponseResult deleteChapterById(@PathVariable String id) &#123; chapterService.deleteChapterById(id); return ResponseResult.ok();&#125; 业务类的实现和接口方法的定义都没有写的，先来看看最终 ChapterController 的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * &lt;p&gt; * 作品章节 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@RestController@CrossOrigin@RequestMapping(&quot;/service_video/chapter&quot;)@Api(tags = &quot;作品章节组&quot;)public class ChapterController &#123; @Resource private ChapterService chapterService; /** * &lt;b&gt; * 获取章节嵌套形式的数据结构列表 * &lt;/b&gt; */ @ApiOperation(value = &quot;获取章节嵌套形式的数据结构列表&quot;) @GetMapping(&quot;getChapterContentVideo/&#123;contentId&#125;&quot;) public ResponseResult getChapterSection(@PathVariable String contentId) &#123; return ResponseResult.ok().data(&quot;items&quot;, chapterService.getChapterSection(contentId)); &#125; /** * &lt;b&gt; * 新增章节 * &lt;/b&gt; */ @PostMapping(&quot;/addChapter&quot;) @ApiOperation(value = &quot;新增章节&quot;) public ResponseResult addChapter(@RequestBody Chapter chapter) &#123; chapterService.save(chapter); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 根据 ID 查询章节 * &lt;/b&gt; */ @GetMapping(&quot;/getChapterById/&#123;id&#125;&quot;) @ApiOperation(value = &quot;根据 ID 查询章节&quot;) public ResponseResult getChapterById(@ApiParam(name = &quot;id&quot;, value = &quot;章节ID&quot;, required = true) @PathVariable String id) &#123; Chapter chapter = chapterService.getById(id); return ResponseResult.ok().data(&quot;item&quot;, chapter); &#125; /** * &lt;b&gt; * 根据ID修改章节 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据ID修改章节&quot;) @PutMapping(&quot;updateChapterById/&#123;id&#125;&quot;) public ResponseResult updateChapterById(@PathVariable String id, @RequestBody Chapter chapter) &#123; chapter.setId(id); chapterService.updateById(chapter); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 根据ID删除章节 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据ID删除章节&quot;) @DeleteMapping(&quot;deleteChapterById/&#123;id&#125;&quot;) public ResponseResult deleteChapterById(@PathVariable String id) &#123; chapterService.deleteChapterById(id); return ResponseResult.ok(); &#125;&#125; 紧接着就是来添加接口方法和完成实现类如下，在 ChapterService 中添加如下方法 12345678/** * &lt;b&gt; * 根据ID删除章节 * &lt;/b&gt; * * @param id 章节ID */void deleteChapterById(String id); 实现类代码如下 12345678@Overridepublic void deleteChapterById(String id) &#123; // 根据 id 查询是否存在小节，如果有则提示用户，有子节点 if (contentVideoService.isExistContentVideoWithChapterId(id)) &#123; throw new BnTangException(20001, &quot;该分章节下存在小节，请先删除小节!&quot;); &#125; baseMapper.deleteById(id);&#125; 紧接着在 contentVideoService 接口当中添加一个查询章节下是否存在小节的方法如下 java 1234567/** * 根据章节ID查询是否存在小节 * * @param id 章节ID * @return 是否存在小节 */boolean isExistContentVideoWithChapterId(String id); 实现类如下，后端完毕开始前端 java 123456789101112131415161718/** * &lt;p&gt; * 作品视频 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@Servicepublic class ContentVideoServiceImpl extends ServiceImpl&lt;ContentVideoMapper, ContentVideo&gt; implements ContentVideoService &#123; @Override public boolean isExistContentVideoWithChapterId(String id) &#123; QueryWrapper&lt;ContentVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;chapter_id&quot;, id); Integer count = baseMapper.selectCount(queryWrapper); return null != count &amp;&amp; count &gt; 0; &#125;&#125; 章节管理前端新增章节在 api 的 chapter.js 当中编写前端调用请求 12345678// 2.新增章节saveChapter(chapter) &#123; return request(&#123; url: `$&#123;apiName&#125;/saveChapter`, method: &#x27;post&#x27;, data: chapter &#125;)&#125;, 定义 data 数据 javascript 1234567// 是否显示章节表单dialogChapterFormVisible: false,// 章节对象chapter: &#123; title: &#x27;&#x27;, sort: 0&#125;, 章节表单 dialog 1234567891011121314151617&lt;!-- 添加和修改章节表单 --&gt;&lt;el-dialog :visible.sync=&quot;dialogChapterFormVisible&quot; title=&quot;添加章节&quot;&gt; &lt;el-form :model=&quot;chapter&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;章节标题&quot;&gt; &lt;el-input v-model=&quot;chapter.title&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;章节排序&quot;&gt; &lt;el-input-number v-model=&quot;chapter.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot;/&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogChapterFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt; 定义表单提交方法 javascript 12345678// 添加或者更新saveOrUpdate() &#123; if (!this.chapter.id) &#123; this.saveData(); &#125; else &#123; this.updateData(); &#125;&#125;, javascript 1234567891011121314saveData() &#123; this.chapter.contentId = this.contentId; chapter.save(this.chapter).then(response =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) &#125;).catch((response) =&gt; &#123; this.$message(&#123; type: &#x27;error&#x27;, message: response.message &#125;) &#125;);&#125;, 在测试添加功能之前先来修复一个 BUG，章节列表展示的问题，首先是前端 BUG解决，然后继续修改前端当点击 添加章节 的时候把表单对话框给显示出来如下 当然我这里是添加了一个方法，你可以直接把绑定的 data 值变为 true 即可显示, showDialog 方法内容如下 javascript 123showDialog() &#123; this.dialogChapterFormVisible = true;&#125; 修改一下 api 请求地址之前写错了 处理添加之后的数据操作，如下 123this.dialogChapterFormVisible = false;// 请求嵌套数据this.getNestedTreeList(); 更新章节添加注册事件 定义编辑方法 javascript 12345678editChapter(chapterId) &#123; this.dialogChapterFormVisible = true; chapter.getChapterById(chapterId).then(res =&gt; &#123; this.chapter = res.data.item; &#125;).catch(error =&gt; &#123; this.$message.error(&quot;系统繁忙!&quot;); &#125;);&#125; 修改 chapter.js 添加对应的 api 方法 javascript 1234567// 3.根据 ID 查询章节getChapterById(chapterId) &#123; return request(&#123; url: `$&#123;apiName&#125;/getChapterById/$&#123;chapterId&#125;`, method: &#x27;get&#x27;, &#125;);&#125; 更新按钮点击方法实现 javascript 12345678// 添加或者更新saveOrUpdate() &#123; if (!this.chapter.id) &#123; this.saveData(); &#125; else &#123; this.updateData(); &#125;&#125;, 修改 chapter.js 添加对应的 api 12345678// 4.根据 ID 查询章节updateChapter(chapter) &#123; return request(&#123; url: `$&#123;apiName&#125;/updateChapterById`, method: &#x27;put&#x27;, data: chapter &#125;);&#125; 12345678910// 更新章节updateData() &#123; chapter.updateChapter(this.chapter).then(res =&gt; &#123; this.$message.success(res.message); this.dialogChapterFormVisible = false; this.getNestedTreeList(); &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;)&#125; 删除章节定义删除方法 12345678910111213141516171819202122// 删除章节deleteChapter(id) &#123; //提示 this.$confirm(&#x27;真的要删除嘛?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27; &#125;).then(() =&gt; &#123; // 发送删除的请求 return chapter.deleteChapter(id); &#125;).then(() =&gt; &#123; // 重新加载数据 this.getNestedTreeList(); &#125;).catch((error =&gt; &#123; // 取消 if (error === &#x27;cancel&#x27;) &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;取消删除&#x27; &#125;); &#125; &#125;));&#125;, 编写对应的请求 api 1234567// 5.删除章节deleteChapter(id) &#123; return request(&#123; url: `$&#123;apiName&#125;/deleteChapterById/$&#123;id&#125;`, method: &#x27;delete&#x27; &#125;);&#125; 29-作品管理-作品小节管理后端定义接收前端参数 ContentVideoInfoVO java 12345678910111213141516171819202122232425262728293031/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/10 22:03 * @description 作品小节接收前端参数VO **/@Datapublic class ContentVideoInfoVO &#123; @ApiModelProperty(value = &quot;视频ID&quot;) private String id; @ApiModelProperty(value = &quot;小节名称&quot;) private String title; @ApiModelProperty(value = &quot;作品ID&quot;) private String contentId; @ApiModelProperty(value = &quot;章节ID&quot;) private String chapterId; @ApiModelProperty(value = &quot;视频资源&quot;) private String videoSourceId; @ApiModelProperty(value = &quot;显示排序&quot;) private Integer sort; @ApiModelProperty(value = &quot;是否可以试听：0默认 1免费&quot;) private Integer isFree;&#125; ContentVideoController如下是 ContentVideoController 中所有的代码，比较简单主要是在 service 层代码我会额外进行解释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * &lt;p&gt; * 作品视频 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@RestController@CrossOrigin@Api(tags = &quot;作品视频组&quot;)@RequestMapping(&quot;/service_video/content_video&quot;)public class ContentVideoController &#123; @Resource private ContentVideoService contentVideoService; /** * &lt;b&gt; * 新增小节 * &lt;/b&gt; */ @ApiOperation(value = &quot;新增小节&quot;) @PostMapping(&quot;/saveVideoInfo&quot;) public ResponseResult save(@RequestBody ContentVideoInfoVO videoInfoForm) &#123; contentVideoService.saveVideoInfo(videoInfoForm); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 根据ID查询小节 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据ID查询小节&quot;) @GetMapping(&quot;/getVideoInfo/&#123;id&#125;&quot;) public ResponseResult getVideInfoById(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;item&quot;, contentVideoService.getContentVideoInfoById(id)); &#125; /** * &lt;b&gt; * 更新小节 * &lt;/b&gt; */ @ApiOperation(value = &quot;更新小节&quot;) @PostMapping(&quot;/updateVideoInfo&quot;) public ResponseResult updateCourseInfoById(@RequestBody ContentVideoInfoVO videoInfoForm) &#123; contentVideoService.updateVideoInfo(videoInfoForm); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 根据ID删除小节 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据ID删除小节&quot;) @PostMapping(&quot;/deleteVideoInfo/&#123;id&#125;&quot;) public ResponseResult removeById(@PathVariable String id) &#123; if (contentVideoService.deleteVideoById(id)) &#123; return ResponseResult.ok(); &#125; else &#123; return ResponseResult.error().message(&quot;删除失败&quot;); &#125; &#125;&#125; ContentVideoService 接口内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * &lt;p&gt; * 作品视频 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */public interface ContentVideoService extends IService&lt;ContentVideo&gt; &#123; /** * &lt;b&gt; * 根据章节ID查询是否存在小节 * &lt;/b&gt; * * @param id 章节ID * @return 是否存在小节 */ boolean isExistContentVideoWithChapterId(String id); /** * &lt;b&gt; * 新增小节 * &lt;/b&gt; * * @param contentVideoInfoVO 小节信息VO */ void saveVideoInfo(ContentVideoInfoVO contentVideoInfoVO); /** * &lt;b&gt; * 根据ID查询小节 * &lt;/b&gt; * * @param id 小节ID * @return 小节信息 */ ContentVideoInfoVO getContentVideoInfoById(String id); /** * &lt;b&gt; * 更新小节 * &lt;/b&gt; * * @param contentVideoInfoVO 小节信息VO */ void updateVideoInfo(ContentVideoInfoVO contentVideoInfoVO); /** * &lt;b&gt; * 根据ID删除小节 * &lt;/b&gt; * * @param id 小节ID * @return 是否删除成功(true ： 删除成功 ， false ： 删除失败) */ boolean deleteVideoById(String id);&#125; 对应的 ContentVideoServiceImpl 实现类代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;p&gt; * 作品视频 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-08 */@Servicepublic class ContentVideoServiceImpl extends ServiceImpl&lt;ContentVideoMapper, ContentVideo&gt; implements ContentVideoService &#123; @Override public boolean isExistContentVideoWithChapterId(String id) &#123; QueryWrapper&lt;ContentVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;chapter_id&quot;, id); Integer count = baseMapper.selectCount(queryWrapper); return null != count &amp;&amp; count &gt; 0; &#125; @Override public void saveVideoInfo(ContentVideoInfoVO contentVideoInfoVO) &#123; ContentVideo contentVideo = new ContentVideo(); BeanUtils.copyProperties(contentVideoInfoVO, contentVideo); this.save(contentVideo); &#125; @Override public ContentVideoInfoVO getContentVideoInfoById(String id) &#123; // 从video表中取数据 ContentVideo contentVideo = this.getById(id); if (Objects.isNull(contentVideo)) &#123; throw new BnTangException(20001, &quot;数据不存在&quot;); &#125; // 创建videoInfoForm对象 ContentVideoInfoVO contentVideoInfoVO = new ContentVideoInfoVO(); BeanUtils.copyProperties(contentVideo, contentVideoInfoVO); return contentVideoInfoVO; &#125; @Override public void updateVideoInfo(ContentVideoInfoVO contentVideoInfoVO) &#123; ContentVideo contentVideo = new ContentVideo(); BeanUtils.copyProperties(contentVideoInfoVO, contentVideo); this.updateById(contentVideo); &#125; @Override public boolean deleteVideoById(String id) &#123; // TODO 删除视频资源 int result = baseMapper.deleteById(id); return result &gt; 0; &#125;&#125; 前端在 api 当中定义 content_video 前端接口 javascript 123456789101112131415161718192021222324252627282930313233343536import request from &#x27;@/utils/request&#x27;const api_name = &#x27;/service_video/content_video&#x27;export default &#123; // 新增小节 saveVideoInfo(videoInfo) &#123; return request(&#123; url: `$&#123;api_name&#125;/saveVideoInfo`, method: &#x27;post&#x27;, data: videoInfo &#125;); &#125;, // 根据ID查询小节 getVideoInfoById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/getVideoInfo/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 更新小节 updateVideoInfo(videoInfo) &#123; return request(&#123; url: `$&#123;api_name&#125;/updateVideoInfo`, method: &#x27;post&#x27;, data: videoInfo &#125;); &#125;, // 根据ID删除小节 deleteVideoById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/deleteVideoInfo/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;); &#125;&#125; 新增小节定义 data 数据 1234567891011// 是否显示课时表单dialogVideoFormVisible: false,// 课时所在的章节idchapterId: &#x27;&#x27;,// 课时对象contentVideo: &#123; title: &#x27;&#x27;, sort: 0, isFree: 0, videoSourceId: &#x27;&#x27;&#125;, 添加小节按钮点击事件 12&lt;el-button type=&quot;text&quot; @click=&quot;dialogVideoFormVisible=true;chapterId = chapter.id&quot;&gt;添加小节&lt;/el-button&gt; 小节表单 1234567891011121314151617181920212223242526&lt;!-- 添加和修改小节表单--&gt;&lt;el-dialog :visible.sync=&quot;dialogVideoFormVisible&quot; title=&quot;添加小节&quot;&gt; &lt;el-form :model=&quot;contentVideo&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;小节标题&quot;&gt; &lt;el-input v-model=&quot;contentVideo.title&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课时排序&quot;&gt; &lt;el-input-number v-model=&quot;contentVideo.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否免费&quot;&gt; &lt;el-radio-group v-model=&quot;contentVideo.isFree&quot;&gt; &lt;el-radio :label=&quot;true&quot;&gt;免费&lt;/el-radio&gt; &lt;el-radio :label=&quot;false&quot;&gt;默认&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;上传视频&quot;&gt; &lt;!-- 上传视频 --&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVideoFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;saveOrUpdateVideo&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt; 实现添加小节按钮点击事件 1234567// 小节按钮点击saveOrUpdateVideo() &#123; if (!this.contentVideo.id) &#123; this.saveDataVideo() &#125; else &#123; &#125;&#125;, 12345678910111213// 保存小节数据信息saveDataVideo() &#123; this.contentVideo.contentId = this.contentId; this.contentVideo.chapterId = this.chapterId; contentVideo.saveVideoInfo(this.contentVideo).then(res =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); // 保存后, 更新相关数据 this.helpSaveVideo() &#125;)&#125;, 保存后, 更新相关数据 1234567891011// 保存后, 更新相关数据helpSaveVideo() &#123; this.dialogVideoFormVisible = false; this.getNestedTreeList(); this.contentVideo = &#123; title: &#x27;&#x27;, sort: 0, isFree: 0, videoSourceId: &#x27;&#x27; &#125;&#125;, 编辑小节添加编辑小节按钮点击事件 12&lt;el-button type=&quot;text&quot; @click=&quot;editContentVideo(section.id)&quot;&gt;编辑&lt;/el-button&gt;&lt;el-button type=&quot;text&quot; @click=&quot;deleteContentVideo(section.id)&quot;&gt;删除&lt;/el-button&gt; 实现数据回显 javascript 123456789// 编辑小节按钮editContentVideo(videoId) &#123; this.dialogVideoFormVisible = true; contentVideo.getVideoInfoById(videoId).then(response =&gt; &#123; this.contentVideo = response.data.item; &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125;, 编辑保存方法实现 12345678910111213//更新小节信息updateDataVideo() &#123; contentVideo.updateVideoInfo(this.contentVideo).then(response =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); // 更新相关数据 this.helpSaveVideo(); &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125;, 删除小节1234567891011121314151617181920212223deleteContentVideo(videoId) &#123; this.$confirm(&#x27;永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; return contentVideo.deleteVideoById(videoId); &#125;).then((res) =&gt; &#123; // 刷新列表 this.getNestedTreeList(); this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); &#125;).catch((response) =&gt; &#123; if (response === &#x27;cancel&#x27;) &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125; &#125;);&#125;, 30-作品管理-发布作品后端定义预览数据模型 VO, ContentPreviewVO 123456789101112131415161718192021/** * @author BNTang * @version S2.3.2Dev * @program video_parent * @date Created in 2021/4/11 12:50 * @description 预览数据模型 VO **/@Datapublic class ContentPreviewVO &#123; private String title; private String cover; private Integer contentNum; private String oneCategory; private String twoCategory; private String author; /** * 价格只用于显示所以为String */ private String price;&#125; 在 ContentController 当中定义接口方法 12345678910/** * &lt;b&gt; * 获取作品的预览信息 * &lt;/b&gt; */@ApiOperation(value = &quot;获取作品的预览信息&quot;)@GetMapping(&quot;/getContentPreView/&#123;id&#125;&quot;)public ResponseResult getContentPreView(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;item&quot;, contentService.getContentPreView(id));&#125; 修改 ContentService 添加对应的方法 123456789/** * &lt;b&gt; * 获取作品的预览信息 * &lt;/b&gt; * * @param id 作品ID * @return 预览信息 */ContentPreviewVO getContentPreView(String id); 修改 ContentServiceImpl 1234@Overridepublic ContentPreviewVO getContentPreView(String id) &#123; return baseMapper.getContentPreviewVoById(id);&#125; 修改 ContentMapper 123456789/** * &lt;b&gt; * 获取作品的预览信息 * &lt;/b&gt; * * @param id 作品ID * @return 预览信息 */ContentPreviewVO getContentPreviewVoById(String id); 由于是多表之间的查询，所以不能用 MP 实现，需要自己手写SQL，修改 ContentMapper.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.it6666.service_video.mapper.ContentMapper&quot;&gt; &lt;select id=&quot;getContentPreviewVoById&quot; resultType=&quot;top.it6666.service_video.entity.vo.ContentPreviewVO&quot;&gt; SELECT c.title, c.cover, c.content_num AS contentNum, CONVERT(c.price, DECIMAL(8, 2)) AS price, c1.title AS oneCategory, c2.title AS twoCategory, a.name AS author FROM video_content c LEFT JOIN video_author a ON c.author_id = a.id LEFT JOIN video_category c1 ON c.category_parent_id = c1.id LEFT JOIN video_category c2 ON c.category_id = c2.id WHERE c.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 修改 service_video 微服务的配置文件，配置 mapper.xml 文件地址如下 1mapper-locations: top/it6666/service_video/mapper/xml/*.xml 而且还要配置一步，配置 maven 打包时不拦截 xml 文件，xml 也需要打包，注意是修改最外层的父工程的 pom.xml 123456789&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 发布作品 1234567891011/** * &lt;b&gt; * 发布作品 * &lt;/b&gt; */@ApiOperation(value = &quot;发布作品&quot;)@PostMapping(&quot;/sendContent/&#123;id&#125;&quot;)public ResponseResult sendContent(@PathVariable String id) &#123; contentService.sendContentWithId(id); return ResponseResult.ok();&#125; 修改 ContentService 12345678/** * &lt;b&gt; * 发布作品 * &lt;/b&gt; * * @param id 作品ID */void sendContentWithId(String id); 修改 ContentServiceImpl 1234567@Overridepublic void sendContentWithId(String id) &#123; Content content = new Content(); content.setId(id); content.setStatus(&quot;Normal&quot;); baseMapper.updateById(content);&#125; 前端前端界面 在 conent.js 当中定义 api 请求接口 1234567891011121314// 获取课程预览信息getContentPreview(id) &#123; return request(&#123; url: `/service_video/content/getContentPreView/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;);&#125;,// 发布作品sendContent(id) &#123; return request(&#123; url: `/service_video/content/sendContent/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;);&#125; 在 send.vue 当中定义数据模型 12345678data() &#123; return &#123; // 所属作品 contentId: &#x27;&#x27;, // 预览信息实体 contentSendObj: &#123;&#125; &#125;;&#125;, 导入 api 1import content from &quot;@/api/video/content/content&quot;; 接收路由参数 1234567created() &#123; if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.contentId = this.$route.params.id; // 根据id获取作品基本信息 this.getPreviewInfo(); &#125;&#125; 12345678// 根据id获取作品基本信息getPreviewInfo() &#123; content.getContentPreview(this.contentId).then(res =&gt; &#123; this.contentSendObj = res.data.item; &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125; 定义界面，结构 12345678910&lt;div class=&quot;contentInfo&quot;&gt; &lt;img :src=&quot;contentSendObj.cover&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2&gt;&#123;&#123; contentSendObj.title &#125;&#125;&lt;/h2&gt; &lt;p class=&quot;gray&quot;&gt;&lt;span&gt;共&#123;&#123; contentSendObj.contentNum &#125;&#125;总数&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;所属分类：&#123;&#123; contentSendObj.oneCategory &#125;&#125; — &#123;&#123; contentSendObj.twoCategory &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;作者：&#123;&#123; contentSendObj.author &#125;&#125;&lt;/p&gt; &lt;h3 class=&quot;red&quot;&gt;￥&#123;&#123; contentSendObj.price &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt; 样式如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style scoped&gt;.contentInfo &#123; background: #f5f5f5; padding: 20px; overflow: hidden; border: 1px dashed #DDD; margin-bottom: 40px; position: relative;&#125;.contentInfo img &#123; background: #d6d6d6; width: 500px; height: 278px; display: block; float: left; border: none;&#125;.contentInfo .main &#123; margin-left: 520px;&#125;.contentInfo .main h2 &#123; font-size: 28px; margin-bottom: 30px; line-height: 1; font-weight: normal;&#125;.contentInfo .main p &#123; margin-bottom: 10px; word-wrap: break-word; line-height: 24px; max-height: 48px; overflow: hidden;&#125;.contentInfo .main p &#123; margin-bottom: 10px; word-wrap: break-word; line-height: 24px; max-height: 48px; overflow: hidden;&#125;.contentInfo .main h3 &#123; left: 540px; bottom: 20px; line-height: 1; font-size: 28px; color: #d32f24; font-weight: normal; position: absolute;&#125;&lt;/style&gt; 发布按钮点击 12345678send() &#123; content.sendContent(this.contentId).then(response =&gt; &#123; // 跳转到列表页 this.$router.push(&#123;path: &#x27;/content/list&#x27;&#125;); &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125;, 31-作品管理-集成富文本编辑器插件安装tinymce 官方提供了一个 vue 的组件 tinymce-vue 安装指令如下 sh 1npm install @tinymce/tinymce-vue -S --no-fund sh 1npm install tinymce -S --no-fund 在 public 文件夹中导入语言包，语言包下载地址为：https://www.tiny.cloud/get-tiny/language-packages/ 在 node_modules 里面找到 tinymce, 将 skins 目录复制到 public&#x2F;tinymce 里面 语言包也要放进去 然后在 components 文件夹下新一个 Tinymce.vue 的组件内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div class=&quot;tinymce-box&quot;&gt; &lt;editor v-model=&quot;myValue&quot; :init=&quot;init&quot; :disabled=&quot;disabled&quot; @onClick=&quot;onClick&quot;&gt; &lt;/editor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import tinymce from &#x27;tinymce/tinymce&#x27; //tinymce默认hidden，不引入不显示import Editor from &#x27;@tinymce/tinymce-vue&#x27;import &#x27;tinymce/themes/silver&#x27;// 编辑器插件plugins// 更多插件参考：https://www.tiny.cloud/docs/plugins/import &#x27;tinymce/icons/default/icons.min.js&#x27;import &#x27;tinymce/plugins/image&#x27;// 插入上传图片插件import &#x27;tinymce/plugins/media&#x27;// 插入视频插件import &#x27;tinymce/plugins/table&#x27;// 插入表格插件import &#x27;tinymce/plugins/lists&#x27;// 列表插件import &#x27;tinymce/plugins/wordcount&#x27;// 字数统计插件import &#x27;tinymce/plugins/code&#x27;import &#x27;tinymce/plugins/link&#x27;import &#x27;tinymce/plugins/contextmenu&#x27;import &#x27;tinymce/themes/silver/theme&#x27;import &#x27;tinymce/plugins/colorpicker&#x27;import &#x27;tinymce/plugins/textcolor&#x27;export default &#123; components: &#123; Editor &#125;, name: &#x27;tinymce&#x27;, props: &#123; value: &#123; type: String, default: &#x27;&#x27; &#125;, disabled: &#123; type: Boolean, default: false &#125;, plugins: &#123; type: [String, Array], default: &#x27;link lists image code table colorpicker textcolor wordcount contextmenu&#x27; &#125;, toolbar: &#123; type: [String, Array], default: &#x27;bold italic underline strikethrough | fontsizeselect | forecolor backcolor | alignleft aligncenter alignright alignjustify | bullist numlist | outdent indent blockquote | undo redo | link unlink image code | removeformat&#x27; &#125; &#125;, data() &#123; return &#123; init: &#123; language_url: &#x27;/tinymce/langs/zh_CN.js&#x27;, language: &#x27;zh_CN&#x27;, skin_url: &#x27;/tinymce/skins/ui/oxide&#x27;, // skin_url: &#x27;tinymce/skins/ui/oxide-dark&#x27;,//暗色系 height: 400, plugins: this.plugins, toolbar: this.toolbar, branding: false, menubar: true, // 此处为图片上传处理函数，这个直接用了base64的图片形式上传图片， // 如需ajax上传可参考https://www.tiny.cloud/docs/configure/file-image-upload/#images_upload_handler images_upload_handler: (blobInfo, success, failure) =&gt; &#123; const img = &#x27;data:image/jpeg;base64,&#x27; + blobInfo.base64() success(img) &#125; &#125;, myValue: this.value &#125; &#125;, mounted() &#123; tinymce.init(&#123;&#125;) &#125;, methods: &#123; // 添加相关的事件，可用的事件参照文档=&gt; https://github.com/tinymce/tinymce-vue =&gt; All available events // 需要什么事件可以自己增加 onClick(e) &#123; this.$emit(&#x27;onClick&#x27;, e, tinymce) &#125;, // 可以添加一些自己的自定义事件，如清空内容 clear() &#123; this.myValue = &#x27;&#x27; &#125; &#125;, watch: &#123; value(newValue) &#123; this.myValue = newValue &#125;, myValue(newValue) &#123; this.$emit(&#x27;input&#x27;, newValue) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后在添加作品的时候，引用组件如下 1&lt;tinymce ref=&quot;editor&quot; v-model=&quot;contentVO.description&quot;/&gt; 本博主在使用的时候已发现问题，高版本存在问题，你可以按照我如下的版本号进行锁定，你也可以试着高版本我的版本号如下图 如果修改了版本号需要重新执行一下 npm install 重新安装对应的依赖包 32-作品管理-作品列表前端页面 后端定义列表分页查询的方法 123456789101112/** * &lt;b&gt; * 分页查询作品列表方法 * &lt;/b&gt; */@ApiOperation(value = &quot;分页查询作品列表方法&quot;)@GetMapping(&quot;/getContentPageQuery/&#123;page&#125;/&#123;limit&#125;&quot;)public ResponseResult contentPageQuery(@PathVariable Long page, @PathVariable Long limit, ContentVO contentVO) &#123; Page&lt;Content&gt; pageParam = new Page&lt;&gt;(page, limit); contentService.contentPageQuery(pageParam, contentVO); return ResponseResult.ok().data(&quot;total&quot;, pageParam.getTotal()).data(&quot;rows&quot;, pageParam.getRecords());&#125; 修改 ContentService 123456789/** * &lt;b&gt; * 分页查询作品列表方法 * &lt;/b&gt; * * @param pageParam 分页信息 * @param contentVO 过滤条件信息实体 */void contentPageQuery(Page&lt;Content&gt; pageParam, ContentVO contentVO); 修改 ContentServiceImpl 实现对应的业务 123456789101112131415161718192021222324252627@Overridepublic void contentPageQuery(Page&lt;Content&gt; pageParam, ContentVO contentVO) &#123; QueryWrapper&lt;Content&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByDesc(&quot;gmt_create&quot;); if (contentVO == null) &#123; baseMapper.selectPage(pageParam, queryWrapper); return; &#125; if (!StringUtils.isEmpty(contentVO.getTitle())) &#123; queryWrapper.like(&quot;title&quot;, contentVO.getTitle()); &#125; if (!StringUtils.isEmpty(contentVO.getAuthorId())) &#123; queryWrapper.eq(&quot;author_id&quot;, contentVO.getAuthorId()); &#125; if (!StringUtils.isEmpty(contentVO.getCategoryParentId())) &#123; queryWrapper.eq(&quot;category_parent_id&quot;, contentVO.getCategoryParentId()); &#125; if (!StringUtils.isEmpty(contentVO.getCategoryId())) &#123; queryWrapper.eq(&quot;category_id&quot;, contentVO.getCategoryId()); &#125; baseMapper.selectPage(pageParam, queryWrapper);&#125; 前端在 content.js 当中定义请求接口 12345678// 作品列表getContentPageList(page, limit, searchObj) &#123; return request(&#123; url: `/service_video/content/getContentPageQuery/$&#123;page&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, params: searchObj &#125;);&#125; 在 list.vue 当中引入相关组件与定义数据模型导入对应的 api 方法如下 javascript 12import content from &quot;@/api/video/content/content&quot;;import category from &quot;@/api/video/category/category&quot;; javascript 123456789101112131415161718192021222324252627data() &#123; return &#123; // 是否显示loading信息 listLoading: true, // 数据列表 list: null, // 总记录数 total: 0, // 页码 page: 1, // 每页记录数 limit: 10, // 查询条件 searchObj: &#123; categoryParentId: &#x27;&#x27;, categoryId: &#x27;&#x27;, title: &#x27;&#x27;, authorId: &#x27;&#x27; &#125;, // 作者列表 authorList: [], // 一级分类列表 oneCategoryList: [], // 二级分类列表 twoCategoryList: [] &#125;&#125;, 初始化查询下拉列表数据 javascript 12345678created() &#123; // 当页面加载时获取数据 this.getData(); // 初始化分类列表 this.getCategoryList(); // 获取讲师列表 this.initAuthorList();&#125; javascript 1234567initAuthorList() &#123; content.getAuthorList().then(res =&gt; &#123; this.authorList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125;, javascript 123456789101112131415161718192021// 加载所有的分类getCategoryList() &#123; // 1.获取一级分类 category.getCategoryData().then(res =&gt; &#123; this.oneCategoryList = res.data.list; &#125;).catch(error =&gt; &#123; this.$message.error(error.message); &#125;);&#125;,// 当一级分类改变时调用的 方法 参数:当前一级分类选择的idoneCategoryChanged(value) &#123; for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; let category = this.oneCategoryList[i]; if (value === category.id) &#123; this.twoCategoryList = category.children; // 清空已经选择的二级分类 this.searchObj.categoryId = &#x27;&#x27;; &#125; &#125;&#125;, javascript 123456789101112131415161718// 调用api层获取数据库中的数据getData(page = 1) &#123; // 当点击分页组件的切换按钮的时候，会传输一个当前页码的参数page // 解决分页无效问题 this.page = page; this.listLoading = true; content.getContentPageList(this.page, this.limit, this.searchObj).then(response =&gt; &#123; // debugger 设置断点调试 if (response.success === true) &#123; this.list = response.data.rows; this.total = response.data.total; &#125; this.listLoading = false; &#125;).catch(error =&gt; &#123; this.$message.error(error.message); this.listLoading = false; &#125;);&#125;, 搜索查询页面添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!--查询表单--&gt;&lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;!-- 所属分类：级联下拉列表 --&gt; &lt;!-- 一级分类 --&gt; &lt;el-form-item label=&quot;分类&quot;&gt; &lt;el-select v-model=&quot;searchObj.categoryParentId&quot; placeholder=&quot;请选择&quot; @change=&quot;oneCategoryChanged&quot;&gt; &lt;el-option v-for=&quot;category in oneCategoryList&quot; :key=&quot;category.id&quot; :label=&quot;category.title&quot; :value=&quot;category.id&quot;/&gt; &lt;/el-select&gt; &amp;nbsp; &lt;!-- 二级分类 --&gt; &lt;el-select placeholder=&quot;请选择&quot; v-model=&quot;searchObj.categoryId&quot;&gt; &lt;el-option v-for=&quot;twoCategory in twoCategoryList&quot; :key=&quot;twoCategory.id&quot; :label=&quot;twoCategory.title&quot; :value=&quot;twoCategory.id&quot;/&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 标题 --&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;searchObj.title&quot; placeholder=&quot;作品标题&quot;/&gt; &lt;/el-form-item&gt; &lt;!-- 作者 --&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;searchObj.authorId&quot; placeholder=&quot;请选择作者&quot;&gt; &lt;el-option v-for=&quot;author in authorList&quot; :key=&quot;author.id&quot; :label=&quot;author.name&quot; :value=&quot;author.id&quot;/&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getData()&quot;&gt;查询&lt;/el-button&gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt;&lt;/el-form&gt; 清空方法实现 javascript 123456resetData() &#123; this.searchObj = &#123;&#125;; // 二级分类列表 this.twoCategoryList = []; this.getData();&#125;, 列表页面添加 12345678910111213141516171819&lt;el-row :gutter=&quot;15&quot;&gt; &lt;el-col :span=&quot;5&quot; v-for=&quot;item in list&quot;&gt; &lt;div class=&quot;grid-content bg-purple&quot;&gt; &lt;img :src=&quot;item.cover&quot; alt=&quot;scope.row.title&quot; width=&quot;100%&quot; height=&quot;150px&quot;&gt; &lt;a href=&quot;#&quot; style=&quot;font-size: 14px; color: #333&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/a&gt; &lt;p style=&quot;margin-top: 0&quot;&gt; &lt;router-link :to=&quot;&#x27;/content/info/&#x27;+item.id&quot;&gt; &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot;&gt;编辑作品信息&lt;/el-button&gt; &lt;/router-link&gt; &lt;el-button style=&quot;margin-left: 100px&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;deleteContentById(item.id)&quot; icon=&quot;el-icon-delete&quot;&gt;删除 &lt;/el-button&gt; &lt;/p&gt; &lt;p style=&quot;font-size: 14px; color: red; margin-top: -15px;&quot;&gt; 价格: &#123;&#123; Number(item.price) === 0 ? &#x27;免费&#x27; : &#x27;¥&#x27; + item.price.toFixed(2) &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/el-col&gt;&lt;/el-row&gt; 123456789&lt;!-- 分页 --&gt;&lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center;&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getData&quot;/&gt; 注意点：需要在最外层套一个 div 如下图，不然使用不了 element-ui 页面样式 css 12345678910111213141516171819202122&lt;style scoped&gt;.app-container &#123; width: 1260px;&#125;.el-col &#123; margin-top: 10px; border-radius: 4px;&#125;.grid-content &#123; border-radius: 4px; min-height: 36px; height: 250px;&#125;.row-bg &#123; padding: 10px 0; background-color: #f9fafc;&#125;&lt;/style&gt; 33-作品管理-删除作品后端在 ContentController 当中定义接口 1234567891011/** * &lt;b&gt; * 根据作品id删除对应视频信息 * &lt;/b&gt; */@ApiOperation(value = &quot;根据作品id删除对应视频信息&quot;)@PostMapping(&quot;/deleteContent/&#123;id&#125;&quot;)public ResponseResult deleteContent(@PathVariable String id) &#123; contentService.deleteContentWithId(id); return ResponseResult.ok();&#125; 修改 ContentService 添加方法 12345678/** * &lt;b&gt; * 根据作品id删除对应视频信息 * &lt;/b&gt; * * @param id 作品ID */void deleteContentWithId(String id); 修改 ContentServiceImpl 实现方法 123456789101112@Overridepublic void deleteContentWithId(String id) &#123; // 根据作品的id删除作品 // 1.作品章节 chapterService.deleteChapterWithContentId(id); // 2.作品小节视频 contentVideoService.deleteContentVideoByContentId(id); // 3.删除信息 baseMapper.deleteById(id);&#125; 修改 ChapterService 12345678/** * &lt;b&gt; * 根据作品id删除作品关联的所有章节 * &lt;/b&gt; * * @param id 作品ID */void deleteChapterWithContentId(String id); 修改 ChapterServiceImpl 123456@Overridepublic void deleteChapterWithContentId(String id) &#123; QueryWrapper&lt;Chapter&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;content_id&quot;, id); baseMapper.delete(queryWrapper);&#125; 修改 ContentVideoService 12345678/** * &lt;b&gt; * 根据作品id删除对应的小节视频 * &lt;/b&gt; * * @param id 作品id */void deleteContentVideoByContentId(String id); 修改 ContentVideoServiceImpl 123456@Overridepublic void deleteContentVideoByContentId(String id) &#123; QueryWrapper&lt;ContentVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;content_id&quot;, id); baseMapper.delete(queryWrapper);&#125; 前端调用在 content.js 当中定义删除请求 javascript 1234567// 删除作品deleteContentById(id) &#123; return request(&#123; url: `/service_video/content/deleteContent/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;);&#125; 删除按钮事件注册 实现删除事件方法 javascript 123456789101112131415161718192021222324deleteContentById(id) &#123; // debugger this.$confirm(&#x27;真的的要删除该作品?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; return content.deleteContentById(id) &#125;).then((res) =&gt; &#123; this.getData() this.$message(&#123; type: &#x27;success&#x27;, message: res.message &#125;); // 失败 &#125;).catch((response) =&gt; &#123; if (response === &#x27;cancel&#x27;) &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125; &#125;)&#125;, 34-视频处理-阿里云视频点播技术简介视频点播（ApsaraVideo for VoD）是集音视频采集、编辑、上传、自动化转码处理、媒体资源管理、分发加速于一体的一站式音视频点播解决方案 功能 特点接入简单 几行代码就可快速接入 大大节省了自行开发的人力物力 私有加密 基于视频内容的加密, 可防止视频泄露, 有效保障视频的安全 每个媒体拥有独立的加密钥匙 提供了完善的管理机制子账号 + 播放凭证 视频 + AI 加速内容处理 视频内容智能审核 视频智能封面, 视频标签预测 窄带高清技术节省流量 不牺牲用户体验的前提下, 有效的节省了流量, 节约了预算 价格优惠 根据不同的需求选择不同的套餐包 开通地址阿里云 - 产品 → 视频点播 开通地址：https://vod.console.aliyun.com/?spm=5176.12818093.products-grouped.dvod.49bb16d0T1n0SG#/guide 整体流程图 整体步骤如下 用户获取上传授权 VoD 下发, 上传地址和凭证及 VideoId 用户上传视频保存视频 ID(VideoId) 用户服务端获取播放凭证 VoD 下发带时效的播放凭证 用户服务端将播放凭证下发给客户端完成视频播放 35-视频处理-视频点播工程创建创建视频点播微服务工程创建工程，注意父工程为 service 引入依赖修改总父工程依赖 xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.10.2&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.13&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt;&lt;/properties&gt;&lt;!--锁定依赖的版本--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加本地依赖，添加方式如下 sh 1mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.13 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.13.jar service_vod 模块依赖如下 xml 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20170516&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在 resources 当中创建配置文件 applicaiton.yml yaml 12345678910111213141516171819202122# application-dev.ymlserver: port: 8003logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-vod profiles: active: dev servlet: multipart: max-file-size: 1024MB max-request-size: 1024MB# 定义oss相关属性aliyun: keyid: LTAI4GH19ep2P8caxW2E2N6A keysecret: NAmWiBmKXofw7hs4JRcx7SLhF1MN6P 如上配置文件当中的 keyid 和 keysecret 是我们之前做 OSS 配置文件当中的自行拷贝自己的即可如下图 在 service_vod 工程当中创建 top.it6666.service_vod 包在该包下创建启动类 java 12345678910/** * @author BNTang */@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;)public class VodApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(VodApplication.class, args); &#125;&#125; 创建微服务点播工具类，在 utils 包中创建配置文件读取常量工具类 VodConstant java 12345678910111213141516171819202122232425/** * @author BNTang * @version 1.0 * @project video_parent * @description 配置文件读取常量工具类 * @since Created in 2021/4/17 22:01 **/@Componentpublic class VodConstant implements InitializingBean &#123; @Value(&quot;$&#123;aliyun.keyid&#125;&quot;) private String keyId; @Value(&quot;$&#123;aliyun.keysecret&#125;&quot;) private String keySecret; public static String ACCESS_KEY_ID; public static String ACCESS_KEY_SECRET; @Override public void afterPropertiesSet() &#123; ACCESS_KEY_ID = keyId; ACCESS_KEY_SECRET = keySecret; &#125;&#125; 在 utils 包中创建阿里云点播初始化工具类 java 123456789101112131415161718/** * @author BNTang * @version 1.0 * @project video_parent * @description 阿里云点播初始化工具类 * @since Created in 2021/4/17 22:03 **/public class ALiYunVodSdkUtils &#123; public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123; // 点播服务接入区域 不能修改 String regionId = &quot;cn-shanghai&quot;; DefaultProfile profile = DefaultProfile.getProfile( regionId, accessKeyId, accessKeySecret); return new DefaultAcsClient(profile); &#125;&#125; 请求接口与业务在 Controller 包下创建 VodController 123456789101112131415161718192021222324252627282930313233343536373839/** * @author BNTang * @version 1.0 * @project video_parent * @description 视频点播与上传请求接口与业务 * @since Created in 2021/4/17 22:06 **/@RestController@RequestMapping(&quot;/service_vod/vod&quot;)@CrossOrigin@Api(tags = &quot;视频组&quot;)public class VodController &#123; @Resource private VodService vodService; /** * &lt;b&gt; * 视频上传 * &lt;/b&gt; */ @ApiOperation(value = &quot;视频上传&quot;) @PostMapping(&quot;/upload&quot;) public ResponseResult uploadVideo(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; String videoId = vodService.uploadVideo(file); return ResponseResult.ok().message(&quot;视频上传成功!&quot;).data(&quot;videoId&quot;, videoId); &#125; /** * &lt;b&gt; * 删除视频 * &lt;/b&gt; */ @ApiOperation(value = &quot;删除视频&quot;) @PostMapping(&quot;/delete-vod/&#123;videoId&#125;&quot;) public ResponseResult removeVideo(@PathVariable String videoId) &#123; vodService.deleteVideo(videoId); return ResponseResult.ok().message(&quot;视频删除成功!&quot;); &#125;&#125; 上传业务与删除业务，在 service 包下创建 VodService java 12345678910111213141516171819202122232425262728/** * @author BNTang * @version 1.0 * @project video_parent * @description 视频组业务 * @since Created in 2021/4/17 22:10 **/public interface VodService &#123; /** * &lt;p&gt; * 上传视频 * &lt;/p&gt; * * @param file 视频文件 * @return 上传结果 */ String uploadVideo(MultipartFile file); /** * &lt;p&gt; * 根据 videoId 删除对应的视频 * &lt;/p&gt; * * @param videoId 删除结果 */ void deleteVideo(String videoId);&#125; 紧接着在 service 包当中创建 impl 包在创建对应的 VodServiceImpl 实现类如下 java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author BNTang * @version 1.0 * @project video_parent * @description 视频组业务实现类 * @since Created in 2021/4/17 22:13 **/@Servicepublic class VodServiceImpl implements VodService &#123; @Override public String uploadVideo(MultipartFile file) &#123; try &#123; // 获取文件输入流 InputStream inputStream = file.getInputStream(); // 获取文件名 String originalFilename = Optional.ofNullable(file.getOriginalFilename()).orElse(&quot;&quot;); //截取标题 String title = originalFilename.substring(0, originalFilename.lastIndexOf(&quot;.&quot;)); // 获取上传请求 UploadStreamRequest request = new UploadStreamRequest( VodConstant.ACCESS_KEY_ID, VodConstant.ACCESS_KEY_SECRET, title, originalFilename, inputStream); // 开始上传 UploadVideoImpl uploader = new UploadVideoImpl(); // 上传完毕后,服务器给于响应 UploadStreamResponse response = uploader.uploadStream(request); // 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。 // 其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 String videoId = response.getVideoId(); if (!response.isSuccess()) &#123; String errorMessage = &quot;阿里云上传错误：&quot; + &quot;code：&quot; + response.getCode() + &quot;, message：&quot; + response.getMessage(); if (StringUtils.isEmpty(videoId)) &#123; throw new BnTangException(20001, errorMessage); &#125; &#125; return videoId; &#125; catch (IOException e) &#123; throw new BnTangException(20001, &quot;vod 服务上传失败&quot;); &#125; &#125; @Override public void deleteVideo(String videoId) &#123; try &#123; // 获取客户端请求 DefaultAcsClient client = ALiYunVodSdkUtils.initVodClient( VodConstant.ACCESS_KEY_ID, VodConstant.ACCESS_KEY_SECRET); // 创建删除请求 DeleteVideoRequest request = new DeleteVideoRequest(); // 设置要删除的视频ID request.setVideoIds(videoId); // 删除请求后服务器给予的响应 client.getAcsResponse(request); &#125; catch (ClientException e) &#123; throw new BnTangException(20001, &quot;视频删除失败&quot;); &#125; &#125;&#125; 36-视频处理-小节视频上传前端在 nginx 当中配置上传地址与最大上传容量 text 1client_max_body_size 1024m; text 123location ~ /service_vod &#123; proxy_pass http://localhost:8003;&#125; 在 api 当中创建 vod.js 前端请求文件 javascript 123456789101112import request from &#x27;@/utils/request&#x27;const API_NAME = &#x27;/service_vod/vod&#x27;export default &#123; deleteVodById(id) &#123; return request(&#123; url: `$&#123;API_NAME&#125;/delete_vod/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;); &#125;&#125; 修改后端首先是接口路径名称如下，然后紧接着就是修改 ContentVideoInfoVO 添加一个新的字段 在 chapte.vue 当中定义相关属性 javascript 12// 小节视频标题videoOriginalName: &#x27;&#x27; javascript 123// 上传文件列表fileList: [],BASE_API: process.env.VUE_APP_BASE_API 导入 vod 请求文件 javascript 1import vod from &quot;@/api/video/vod/vod&quot;; 添加上传组件 1234567891011121314151617181920212223&lt;el-form-item label=&quot;上传视频&quot;&gt; &lt;!-- 上传视频 --&gt; &lt;el-upload :on-success=&quot;handleVodUploadSuccess&quot; :on-remove=&quot;handleVodRemove&quot; :before-remove=&quot;beforeVodRemove&quot; :on-exceed=&quot;handleUploadExceed&quot; :file-list=&quot;fileList&quot; :action=&quot;BASE_API+&#x27;/service_vod/vod/upload&#x27;&quot; :limit=&quot;1&quot; class=&quot;upload-demo&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;上传视频&lt;/el-button&gt; &lt;el-tooltip placement=&quot;right-end&quot;&gt; &lt;div slot=&quot;content&quot;&gt;最大支持1G，&lt;br&gt; 支持3GP、ASF、AVI、DAT、DV、FLV、F4V、&lt;br&gt; GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、&lt;br&gt; MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、&lt;br&gt; SWF、TS、VOB、WMV、WEBM 等视频格式上传 &lt;/div&gt; &lt;i class=&quot;el-icon-question&quot;/&gt; &lt;/el-tooltip&gt; &lt;/el-upload&gt;&lt;/el-form-item&gt; 定义组件方法 1234567891011//自动上传成功回调handleVodUploadSuccess(response, file, fileList) &#123; // 获取当前上传视频的ID this.contentVideo.videoSourceId = response.data.videoId; // 获取当前上传视频标题 this.contentVideo.videoOriginalName = file.name; // 设置文件名回显 this.fileList = [&#123;&#x27;name&#x27;: this.contentVideo.videoOriginalName&#125;];&#125;, 1234// 已经超过了指定数量时,调用此方法handleUploadExceed(files, fileList) &#123; this.$message.warning(&#x27;请先删除已上传的视频!&#x27;);&#125;, 1234//删除之前提示信息beforeVodRemove(file, fileList) &#123; return this.$confirm(`确定删除 $&#123;file.name&#125;？`);&#125;, 123456789101112131415//删除小节视频handleVodRemove(file, fileList) &#123; vod.deleteVodById(this.contentVideo.videoSourceId).then(response =&gt; &#123; // 清空当前小节视频id this.contentVideo.videoSourceId = &#x27;&#x27;; // 清空当前小节视频标题 this.contentVideo.videoOriginalName = &#x27;&#x27;; this.fileList = []; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); &#125;);&#125;, 更改之前的小节编辑回显代码如下 123456789101112editorContentVideo(id) &#123; this.dialogVideoFormVisible = true; contentVideo.getVideoInfoById(id).then(res =&gt; &#123; this.contentVideo = res.data.item; // 如果有视频, 显示视频标题 if (this.contentVideo.videoOriginalName !== &#x27;&#x27;) &#123; this.fileList = [&#123;&#x27;name&#x27;: this.contentVideo.videoOriginalName&#125;]; &#125; &#125;);&#125;, 可能还有一个小问题后面在解决 37-视频处理-集成Nacos在本地搭建一个 nacos 搭建教程请参考：https://www.cnblogs.com/TangXiaoHuiHui/protected/articles/12467387.html 密码为：303158131 为啥要集成 nacos 了呢，原因就是我们在删除小节的时候需要把对应的视频也一起进行删除这里就设计到了微服务之间的调用问题了，这个时候把 nacos 搭建起来里面包含了注册中心服务治理等等，在 service_video 当中调用 service_vod 服务当中的方法，首先处理 service_video 服务模块当中的配置，再次更换全局依赖，也就是最外层的那个 pom.xml 里面的依赖内容如下 xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.10.2&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.13&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;2.1.1.RELEASE&lt;/cloud-alibaba.version&gt;&lt;/properties&gt;&lt;!--锁定依赖的版本--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在 service 当中添加依赖 xml 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt; 添加配置在 service_video 配置文件当中添加 nacos 配置，我这里的 nacos 没有搭建集群不然可以直接配置的是 nginx 的配置我这里直接配置的 nacos 真实地址如下 yaml 1234567cloud: nacos: discovery: server-addr: 192.168.31.45:8848 sentinel: transport: dashboard: localhost:8088 当然这里也添加了 sentinel 相关的配置内容，搭建sentinel也在之前的文章当中有不在介绍多了，自行参考文章搭建即可然后对应的地址放入即可 在 service_video 启动类当中添加如下注解 12@EnableDiscoveryClient@EnableFeignClients Feign 客户端调用在 service_video 模块当中创建 client 包, 编写 Feign 调用客户端 java 123456789101112131415161718/** * @author BNTang */@FeignClient(name = &quot;service-vod&quot;, fallback = VodFeignClientFallBack.class)@Componentpublic interface VodClient &#123; /** * &lt;b&gt; * 根据 videoId 删除视频 * &lt;/b&gt; * * @param videoId 视频ID * @return 删除结果 */ @PostMapping(value = &quot;/service_vod/vod/delete_vod/&#123;videoId&#125;&quot;) ResponseResult deleteAliyunVideo(@PathVariable(&quot;videoId&quot;) String videoId);&#125; 降级处理方法 12345678910/** * @author BNTang */@Componentpublic class VodFeignClientFallBack implements VodClient &#123; @Override public ResponseResult deleteAliYunVideo(String videoId) &#123; return ResponseResult.error().message(&quot;熔断处理-调用超时！&quot;); &#125;&#125; 业务调用修改 ContentVideoController 中的 removeById 的实现类如下 java 12@Resourceprivate VodClient vodClient; java 1234567891011121314151617181920@Overridepublic boolean deleteVideoById(String id) &#123; // 删除小节对应的视频 ContentVideo contentVideo = baseMapper.selectById(id); // 获取小节对应的视频 String videoSourceId = contentVideo.getVideoSourceId(); // 判断是否有小节视频 if (!StringUtils.isEmpty(videoSourceId)) &#123; // 删除视频 // 服务之间调用 Nacos ResponseResult result = vodClient.deleteAliYunVideo(videoSourceId); if (!result.getSuccess()) &#123; throw new BnTangException(20001, result.getMessage()); &#125; &#125; int result = baseMapper.deleteById(id); return result &gt; 0;&#125; 添加 Feign 与 Sentinel 的支持修改service_video模块的 application.yml yaml 123feign: sentinel: enabled: true 移动 nacos 和 Sentinel 配置内容的位置如下图 service_vod 模块配置文件内容如下 yaml 12345cloud: nacos: discovery: # nacos服务的地址，不要加http server-addr: localhost:8848 service_upload 模块配置文件内容同上添加一样的内容进去 修复问题添加章节成功之后再次点击添加章节上一次添加的数据没有清空效果如下图 编辑小节视频名称回显BUG，我就不复现了自行去修改 修改后端添加一个方法，用来清空已经删除的视频的信息如下，修改 ContentVideoController 修改 ContentVideoService java 12345678/** * &lt;b&gt; * 根据视频ID删除小节视频 * &lt;/b&gt; * * @param id 视频ID */void deleteContentVideoById(String id); 实现类如下 java 1234567891011@Overridepublic void deleteContentVideoById(String id) &#123; QueryWrapper&lt;ContentVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;video_source_id&quot;, id); ContentVideo contentVideo = new ContentVideo(); contentVideo.setVideoSourceId(&quot;&quot;); contentVideo.setVideoOriginalName(&quot;&quot;); baseMapper.update(contentVideo, queryWrapper);&#125; 修改前端的 contentVideo.js 文件添加请求 api 方法如下 javascript 1234567// 删除小节视频deleteContentVideoById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/deleteContentVideoById/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;);&#125;, 修改 chapter.vue 改造删除小节视频方法如下 javascript 1234567891011121314151617// 删除小节视频handleVodRemove(file, fileList) &#123; vod.deleteVodById(this.contentVideo.videoSourceId).then(response =&gt; &#123; // 清空当前小节视频id this.contentVideo.videoSourceId = &#x27;&#x27;; // 清空当前小节视频标题 this.contentVideo.videoOriginalName = &#x27;&#x27;; this.fileList = []; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); &#125;); contentVideo.deleteContentVideoById(this.contentVideo.videoSourceId).then(res =&gt; &#123; &#125;);&#125;, 修改 service 下的子模块的服务名称如下在中间加一个横杠如下图 38-视频处理-添加网关gateway创建网关微服务 添加依赖修改 gateway 服务的 pom.xml xml 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.it6666&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 gateway 启动类 java 12345678910/** * @author BNTang */@SpringBootApplication@EnableDiscoveryClientpublic class GateWayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayApplication.class, args); &#125;&#125; 在 resources 当中创建配置文件 application.yml yaml 1234567891011121314151617181920212223242526272829303132logging: pattern: console: &quot;%d&#123;HH:mm:ss.SSS&#125; %clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;server: port: 9000spring: application: # 此实例注册到服务端的name name: gateway cloud: nacos: discovery: server-addr: localhost:8848 gateway: discovery: locator: enabled: true routes: - id: service-video uri: lb://service-video predicates: - Path=/service_video/** - id: service-vod uri: lb://service-vod predicates: - Path=/service_vod/** - id: service-upload uri: lb://service-upload predicates: - Path=/service_upload/** 在 gateway 当中添加跨域配置处理如下, 创建 config 包, 在该包下创建跨域处理配置 java 123456789101112131415161718/** * @author BNTang */@Configurationpublic class CorsConfig &#123; @Bean public CorsWebFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(&quot;*&quot;); config.addAllowedOrigin(&quot;*&quot;); config.addAllowedHeader(&quot;*&quot;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsWebFilter(source); &#125;&#125; 取消控制器上的跨域注解, 把前端请求地址改成网关请求地址如下图，Controller 跨域注解全部去除 修改前端为 gateway 请求地址 39-权限控制-权限工程搭建创建权限工程 添加对应的启动类 AuthApplication 代码如下所示 java 1234567891011/** * @author BNTang */@SpringBootApplication()@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;)@MapperScan(&quot;top.it6666.service_auth.mapper&quot;)public class AuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AuthApplication.class, args); &#125;&#125; 然后在添加对应的配置文件 application.yml 内容如下，其中 redis 的配置我移除了后面在加上即可我会贴出来的 yaml 123456789101112131415161718192021222324252627282930313233343536373839404142# application-dev.ymlserver: port: 8004logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-auth profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: HikariPool jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: nacos: discovery: server-addr: localhost:8848mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: top/it6666/service_auth/mapper/xml/*.xmlfeign: sentinel: enabled: true 创建对应的数据库表用户表 auth_user sql 12345678910111213CREATE TABLE `auth_user` ( `id` char(19) NOT NULL COMMENT &#x27;会员id&#x27;, `open_id` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信openid&#x27;, `password` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `nick_name` varchar(50) DEFAULT NULL COMMENT &#x27;昵称&#x27;, `salt` varchar(255) DEFAULT NULL COMMENT &#x27;用户头像&#x27;, `token` varchar(100) DEFAULT NULL COMMENT &#x27;用户签名&#x27;, `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_username` (`open_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;用户表&#x27;; 角色表 auth_role sql 12345678910CREATE TABLE `auth_role` ( `id` char(19) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;角色id&#x27;, `role_name` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;角色名称&#x27;, `role_code` varchar(20) DEFAULT NULL COMMENT &#x27;角色编码&#x27;, `remark` varchar(255) DEFAULT NULL COMMENT &#x27;备注&#x27;, `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;角色&#x27;; 菜单权限表 auth_menu sql 12345678910111213141516CREATE TABLE `auth_menu` ( `id` char(19) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;编号&#x27;, `pid` char(19) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所属上级&#x27;, `name` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `type` tinyint(3) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;类型(1:菜单,2:按钮)&#x27;, `permission_value` varchar(50) DEFAULT NULL COMMENT &#x27;权限值&#x27;, `path` varchar(100) DEFAULT NULL COMMENT &#x27;访问路径&#x27;, `component` varchar(100) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `icon` varchar(50) DEFAULT NULL COMMENT &#x27;图标&#x27;, `status` tinyint(4) DEFAULT NULL COMMENT &#x27;状态(0:禁止,1:正常)&#x27;, `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_pid` (`pid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;菜单权限&#x27;; 用户与角色关系表 auth_user_role sql 1234567891011CREATE TABLE `auth_user_role` ( `id` char(19) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;主键id&#x27;, `role_id` char(19) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, `user_id` char(19) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;用户id&#x27;, `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_role_id` (`role_id`), KEY `idx_user_id` (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;用户角色&#x27;; 角色与菜单的关系表 auth_role_menu sql 1234567891011CREATE TABLE `auth_role_menu` ( `id` char(19) NOT NULL DEFAULT &#x27;&#x27;, `role_id` char(19) NOT NULL DEFAULT &#x27;&#x27;, `permission_id` char(19) NOT NULL DEFAULT &#x27;&#x27;, `is_deleted` tinyint(1) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), KEY `idx_role_id` (`role_id`), KEY `idx_permission_id` (`permission_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;角色菜单&#x27;; rbac 表对应的代码生成器代码如下放入 test 运行即可生成对应层级的代码 java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @author BNTang */public class CodeGeneratorTestCase &#123; @Test public void rbacGenerator() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // 配置输出路径 gc.setOutputDir(&quot;D:\\\\Java\\\\VIDEO_Parent\\\\service\\\\service_auth\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成service层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_auth&quot;); // top.it6666.模块名称.功能 → top.it6666.service_auth.controller pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;auth_menu&quot;, &quot;auth_role&quot;, &quot;auth_role_menu&quot;, &quot;auth_user&quot;, &quot;auth_user_role&quot;); // 数据库表映射到实体的命名策略 驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;auth_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 40-权限控制-用户管理后端修改 UserController 添加对应的 CRUD 以及分批角色，删除用户要把对应的角色与用户的关系表数据也紧接着删除掉，代码如下 ，如下编写的业务就是 RBAC 了，我就快速的贴代码了，重点是在后面的 Jwt + Security + OAuth2 的知识点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * &lt;p&gt; * 用户表 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@RestController@RequestMapping(&quot;/service_auth/admin/user&quot;)@Api(tags = &quot;用户组&quot;)public class UserController &#123; @Resource private UserService userService; @Resource private RoleService roleService; /** * &lt;b&gt; * 获取管理用户，分页列表 * &lt;/b&gt; */ @ApiOperation(value = &quot;获取管理用户，分页列表&quot;) @GetMapping(&quot;/getUserList/&#123;page&#125;/&#123;limit&#125;&quot;) public ResponseResult index(@PathVariable Long page, @PathVariable Long limit, User userQueryVo) &#123; IPage&lt;User&gt; pageParam = new Page&lt;&gt;(page, limit); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); if (!StringUtils.isEmpty(userQueryVo.getOpenId())) &#123; queryWrapper.like(&quot;open_id&quot;, userQueryVo.getOpenId()); &#125; IPage&lt;User&gt; pageModel = userService.page(pageParam, queryWrapper); return ResponseResult.ok() .data(&quot;items&quot;, pageModel.getRecords()) .data(&quot;total&quot;, pageModel.getTotal()); &#125; /** * &lt;b&gt; * 新增管理用户 * &lt;/b&gt; */ @ApiOperation(value = &quot;新增管理用户&quot;) @PostMapping(&quot;/saveUser&quot;) public ResponseResult save(@RequestBody User user) &#123; user.setPassword(Md5.encrypt(user.getPassword())); userService.save(user); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 修改管理用户 * &lt;/b&gt; */ @ApiOperation(value = &quot;修改管理用户&quot;) @PostMapping(&quot;/updateUser&quot;) public ResponseResult updateById(@RequestBody User user) &#123; user.setPassword(Md5.encrypt(user.getPassword())); userService.updateById(user); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 删除管理用户 * &lt;/b&gt; */ @ApiOperation(value = &quot;删除管理用户&quot;) @PostMapping(&quot;/removeUser/&#123;id&#125;&quot;) public ResponseResult remove(@PathVariable String id) &#123; userService.removeById(id); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 批量删除用户 * &lt;/b&gt; */ @ApiOperation(value = &quot;批量删除用户&quot;) @PostMapping(&quot;/batchRemoveUser&quot;) public ResponseResult batchRemove(@RequestBody List&lt;String&gt; idList) &#123; userService.removeByIds(idList); return ResponseResult.ok(); &#125; /** * &lt;b&gt; * 根据用户id查询用户 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据用户id查询用户&quot;) @GetMapping(&quot;/getUserById/&#123;id&#125;&quot;) public ResponseResult getUser(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;user&quot;, userService.getById(id)); &#125; /** * &lt;b&gt; * 根据用户ID获取角色数据 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据用户ID获取角色数据&quot;) @GetMapping(&quot;/getUserRoleData/&#123;userId&#125;&quot;) public ResponseResult toAssign(@PathVariable String userId) &#123; return ResponseResult.ok().data(roleService.findRoleByUserId(userId)); &#125; /** * &lt;b&gt; * 根据用户ID分配用户角色 * &lt;/b&gt; */ @ApiOperation(value = &quot;根据用户ID分配用户角色&quot;) @PostMapping(&quot;/doAssignRole&quot;) public ResponseResult doAssign(@RequestParam String userId, @RequestParam String[] roleId) &#123; roleService.saveUserRoleRelationShip(userId, roleId); return ResponseResult.ok(); &#125;&#125; 紧接着修改 RoleService 接口，添加如下方法 java 123456789101112131415161718192021222324252627282930/** * &lt;p&gt; * 角色 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */public interface RoleService extends IService&lt;Role&gt; &#123; /** * &lt;b&gt; * 根据用户ID获取角色数据 * &lt;/b&gt; * * @param userId 用户ID * @return 角色数据 */ Map&lt;String, Object&gt; findRoleByUserId(String userId); /** * &lt;b&gt; * 根据用户ID分配用户角色 * &lt;/b&gt; * * @param userId 用户ID * @param roleId 角色ID */ void saveUserRoleRelationShip(String userId, String[] roleId);&#125; 修改 RoleServiceImpl java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &lt;p&gt; * 角色 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@Servicepublic class RoleServiceImpl extends ServiceImpl&lt;RoleMapper, Role&gt; implements RoleService &#123; @Resource private UserRoleService userRoleService; /** * &lt;b&gt; * 根据用户ID获取角色数据 * &lt;/b&gt; */ @Override public Map&lt;String, Object&gt; findRoleByUserId(String userId) &#123; // 1.查询出所有的角色 List&lt;Role&gt; allRoles = baseMapper.selectList(null); // 2.当前用户选中的角色有哪些 QueryWrapper&lt;UserRole&gt; queryWrapper = new QueryWrapper&lt;UserRole&gt;() .eq(&quot;user_id&quot;, userId) .select(&quot;role_id&quot;); // 获取到当前用户所在的角色关系 List&lt;UserRole&gt; userRoleList = userRoleService.list(queryWrapper); // 取出所有的roleId 放到一个集合当中 List&lt;String&gt; roleIds = userRoleList.stream().map(UserRole::getRoleId).collect(Collectors.toList()); // 根据角色id,取出所有的角色对象 List&lt;Role&gt; userRoles = new ArrayList&lt;&gt;(); allRoles.forEach(role -&gt; &#123; if (roleIds.contains(role.getId())) &#123; userRoles.add(role); &#125; &#125;); Map&lt;String, Object&gt; roleMap = new HashMap&lt;&gt;(2); // 用户的角色 roleMap.put(&quot;assignRoles&quot;, userRoles); // 所有的角色 roleMap.put(&quot;allRolesList&quot;, allRoles); return roleMap; &#125; /** * &lt;b&gt; * 根据用户ID分配用户角色 * &lt;/b&gt; */ @Override public void saveUserRoleRelationShip(String userId, String[] roleId) &#123; // 1.删除原来角色与用户之间的关系 userRoleService.remove(new QueryWrapper&lt;UserRole&gt;().eq(&quot;user_id&quot;, userId)); // 2.重新建立关系 List&lt;UserRole&gt; userRoleArrayList = Stream.of(roleId).map(role -&gt; &#123; UserRole userRole = new UserRole(); userRole.setUserId(userId); userRole.setRoleId(role); return userRole; &#125;).collect(Collectors.toList()); // 3.批量保存关系 userRoleService.saveBatch(userRoleArrayList); &#125;&#125; 移动之前 server_video 微服务当中的 AppConfig，目的为了就是其它微服务如果也需要用到分页的配置和逻辑删除就不用再继续写冗余的配置文件内容了，我们的 server_auth 模块中有分页查询用户逻辑删除用户等等，但是 video 微服务当中也需要这样大家都是 server 的子服务就都会有对应的配置内容了 修改 gateway 配置 server_auth 的网关服务转发规则，修改 gateway 的 application.yml yaml 1234- id: service-auth uri: lb://service-auth predicates: - Path=/service_auth/** 配置逻辑删除和属性的自动填充如下，每个实体类都自己加一下，不然你也可以按照报错自行排查问题 前端修改路由文件 index.js 在路由当中添加路由 内容如下 javascript 123456789101112131415161718192021222324252627282930313233343536&#123; path: &#x27;/auth&#x27;, component: Layout, redirect: &#x27;/auth/user/list&#x27;, name: &#x27;权限管理&#x27;, meta: &#123;title: &#x27;权限管理&#x27;, icon: &#x27;tree&#x27;&#125;, children: [ &#123; path: &#x27;user/list&#x27;, name: &#x27;用户管理&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/user/list&#x27;), meta: &#123;title: &#x27;用户管理&#x27;&#125; &#125;, &#123; path: &#x27;user/add&#x27;, name: &#x27;用户添加&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/user/form&#x27;), meta: &#123;title: &#x27;用户添加&#x27;&#125;, hidden: true &#125;, &#123; path: &#x27;user/update/:id&#x27;, name: &#x27;用户修改&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/user/form&#x27;), meta: &#123;title: &#x27;用户修改&#x27;&#125;, hidden: true &#125;, &#123; path: &#x27;user/role/:id&#x27;, name: &#x27;用户角色&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/user/roleForm&#x27;), meta: &#123;title: &#x27;用户角色&#x27;&#125;, hidden: true &#125; ]&#125;, 在 api 包中添加 user.js 编写请求方法内容如下 javascript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import request from &#x27;@/utils/request&#x27;;const api_name = &#x27;/service_auth/admin/user&#x27;;export default &#123; // 获取用户分页数据 getPageList(page, limit, searchObj) &#123; return request(&#123; url: `$&#123;api_name&#125;/getUserList/$&#123;page&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, // url查询字符串或表单键值对 params: searchObj &#125;); &#125;, // 根据用户id查询用户 getUserById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/getUserById/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 保存用户 save(user) &#123; return request(&#123; url: `$&#123;api_name&#125;/saveUser`, method: &#x27;post&#x27;, data: user &#125;); &#125;, // 更新用户 updateById(user) &#123; return request(&#123; url: `$&#123;api_name&#125;/updateUser`, method: &#x27;post&#x27;, data: user &#125;); &#125;, // 根据用户id查询用户下角色信息 getAssign(userId) &#123; return request(&#123; url: `$&#123;api_name&#125;/getUserRoleData/$&#123;userId&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 保存用户角色信息 saveAssign(userId, roleId) &#123; return request(&#123; url: `$&#123;api_name&#125;/doAssignRole`, method: &#x27;post&#x27;, params: &#123;userId, roleId&#125; &#125;); &#125;, // 删除用户 removeById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/removeUser/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;); &#125;, // 批量删除用户 removeRows(idList) &#123; return request(&#123; url: `$&#123;api_name&#125;/batchRemoveUser`, method: &#x27;post&#x27;, data: idList &#125;); &#125;&#125; 都是之前写过的，我直接贴代码如下，如下是 list.vue 的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;searchObj.username&quot; placeholder=&quot;用户名&quot;/&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;fetchData()&quot;&gt;查询&lt;/el-button&gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt; &lt;!-- 工具条 --&gt; &lt;div&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;addUser()&quot;&gt;添加&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;removeRows()&quot;&gt;批量删除&lt;/el-button&gt; &lt;/div&gt; &lt;!--用户列表 --&gt; &lt;el-table v-loading=&quot;listLoading&quot; :data=&quot;list&quot; stripe style=&quot;width: 100%&quot; @selection-change=&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot;/&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;openId&quot; label=&quot;用户名&quot; align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;nickName&quot; label=&quot;用户昵称&quot; align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/auth/user/role/&#x27;+scope.row.id&quot;&gt; &lt;el-button type=&quot;success&quot; size=&quot;mini&quot;&gt;绑定角色&lt;/el-button&gt; &lt;/router-link&gt; &amp;nbsp; &lt;router-link :to=&quot;&#x27;/auth/user/update/&#x27;+scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot;&gt;修改&lt;/el-button&gt; &lt;/router-link&gt; &amp;nbsp; &lt;el-button type=&quot;danger&quot; @click=&quot;removeDataById(scope.row.id)&quot; size=&quot;mini&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页组件 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :total=&quot;total&quot; :page-size=&quot;limit&quot; :page-sizes=&quot;[5, 10, 20, 30, 40, 50, 100]&quot; style=&quot;padding: 30px 0; text-align: center;&quot; layout=&quot;sizes, prev, pager, next, jumper, -&gt;, total, slot&quot; @current-change=&quot;fetchData&quot; @size-change=&quot;changeSize&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import user from &#x27;@/api/video/auth/user&#x27;;export default &#123; name: &quot;list&quot;, data() &#123; return &#123; // 数据是否正在加载 listLoading: true, // 用户列表 list: null, // 数据库中的总记录数 total: 0, // 默认页码 page: 1, // 每页记录数 limit: 10, // 查询条件的表单对象 searchObj: &#123;&#125;, // 批量选择中选择的记录列表 multipleSelection: [] &#125; &#125;, created() &#123; // 加载页面数据 this.fetchData(); &#125;, methods: &#123; // 当页码发生改变的时候 changeSize(size) &#123; this.limit = size; this.fetchData(1); &#125;, addUser() &#123; // 添加用户,跳转到添加路由 this.$router.push(&#123;path: &#x27;/auth/user/add&#x27;&#125;); &#125;, // 加载用户数据 fetchData(page = 1) &#123; this.page = page; user.getPageList(this.page, this.limit, this.searchObj).then( response =&gt; &#123; this.list = response.data.items; this.total = response.data.total; // 数据加载并绑定成功 this.listLoading = false; &#125; ); &#125;, // 重置查询表单 resetData() &#123; this.searchObj = &#123;&#125;; this.fetchData(); &#125;, // 根据id删除数据 removeDataById(id) &#123; this.$confirm(&#x27;此操作将永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 点击确定，远程调用ajax return user.removeById(id); &#125;).then((response) =&gt; &#123; // 重新加载列表 this.fetchData(this.page); if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) &#125; &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;) &#125;, // 当表格复选框选项发生变化的时候触发 handleSelectionChange(selection) &#123; this.multipleSelection = selection; &#125;, // 批量删除 removeRows() &#123; if (this.multipleSelection.length === 0) &#123; this.$message(&#123; type: &#x27;warning&#x27;, message: &#x27;请选择要删除的记录!&#x27; &#125;) return; &#125; this.$confirm(&#x27;此操作将永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; let idList = []; this.multipleSelection.forEach(item =&gt; &#123; idList.push(item.id); &#125;); // 调用api return user.removeRows(idList); &#125;).then((response) =&gt; &#123; this.fetchData(this.page) if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) &#125; &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 添加与更新页面，form.vue 内容如下 javascript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form ref=&quot;user&quot; :model=&quot;user&quot; :rules=&quot;validateRules&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;user.openId&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;用户昵称&quot;&gt; &lt;el-input v-model=&quot;user.nickName&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item v-if=&quot;!user.id&quot; label=&quot;用户密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;user.password&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot;&gt;保存&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import userApi from &#x27;@/api/video/auth/user&#x27;;const defaultForm = &#123; openId: &#x27;&#x27;, nickName: &#x27;&#x27;, password: &#x27;&#x27;&#125;const validatePass = (rule, value, callback) =&gt; &#123; if (value.length &lt; 6) &#123; callback(new Error(&#x27;密码不能小于6位&#x27;)); &#125; else &#123; callback(); &#125;&#125;export default &#123; name: &quot;form&quot;, data() &#123; return &#123; user: defaultForm, // 保存按钮是否禁用, saveBtnDisabled: false, validateRules: &#123; openId: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;用户名必须输入&#x27;&#125;], password: [&#123;required: true, trigger: &#x27;blur&#x27;, validator: validatePass&#125;] &#125; &#125; &#125;, // 监听器 watch: &#123; // 路由变化 $route(to, from) &#123; this.init(); &#125; &#125;, // 生命周期方法（在路由切换，组件不变的情况下不会被调用） created() &#123; this.init(); &#125;, methods: &#123; // 表单初始化 init() &#123; if (this.$route.params &amp;&amp; this.$route.params.id) &#123; const id = this.$route.params.id; this.fetchDataById(id); &#125; else &#123; // 对象拓展运算符：拷贝对象，而不是赋值对象的引用 this.user = &#123;...defaultForm&#125;; &#125; &#125;, saveOrUpdate() &#123; this.$refs.user.validate(valid =&gt; &#123; if (valid) &#123; // 防止表单重复提交 this.saveBtnDisabled = true; if (!this.user.id) &#123; this.saveData(); &#125; else &#123; this.updateData(); &#125; &#125; &#125;); &#125;, // 新增用户 saveData() &#123; userApi.save(this.user).then(response =&gt; &#123; // debugger if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) this.$router.push(&#123;path: &#x27;/auth/user/list&#x27;&#125;); &#125; &#125;); &#125;, // 根据id更新记录 updateData() &#123; // teacher数据的获取 userApi.updateById(this.user).then(response =&gt; &#123; if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;); this.$router.push(&#123;path: &#x27;/auth/user/list&#x27;&#125;); &#125; &#125;); &#125;, // 根据id查询记录 fetchDataById(id) &#123; userApi.getUserById(id).then(response =&gt; &#123; this.user = response.data.user; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 绑定角色的选择页面，roleForm.vue 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot; v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot;&gt;全选 &lt;/el-checkbox&gt; &lt;div style=&quot;margin: 15px 0;&quot;&gt;&lt;/div&gt; &lt;el-checkbox-group v-model=&quot;checkedRoles&quot; @change=&quot;handlecheckedRolesChange&quot;&gt; &lt;el-checkbox v-for=&quot;role in roles&quot; :label=&quot;role.id&quot; :key=&quot;role.id&quot;&gt; &#123;&#123; role.roleName &#125;&#125; &lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;br&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;update&quot;&gt;保存&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import userApi from &#x27;@/api/video/auth/user&#x27;;export default &#123; name: &quot;roleForm&quot;, data() &#123; return &#123; // 是否全部选中 checkAll: false, // 已选中列表 checkedRoles: [], // 所有的角色 roles: [], isIndeterminate: true, userId: &#x27;&#x27;, // 保存按钮是否禁用 saveBtnDisabled: false &#125;; &#125;, created() &#123; this.init(); &#125;, methods: &#123; init() &#123; if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 获取用户id this.userId = this.$route.params.id; // 查询用户 this.getById(this.userId); &#125; &#125;, getById(userId) &#123; userApi.getAssign(userId).then(response =&gt; &#123; // 获取用户角色 let jsonObj = response.data.assignRoles; // 设置角色选中状态 this.checkedRoles = this.getJsonToList(jsonObj, &quot;id&quot;); this.roles = response.data.allRolesList; &#125;) &#125;, // 把 json 数据转成 string 再转成对象，根据 Key 获取value数据 getJsonToList(json, key) &#123; // 把JSON字符串转成对象 let list = JSON.parse(JSON.stringify(json)); let strText = []; // 遍历这个集合对象，获取key的值 for (let i = 0; i &lt; list.length; i++) &#123; strText.push(list[i][key]); &#125; return strText; &#125;, // 全选 handleCheckAllChange(val) &#123; this.checkedRoles = val ? this.roles : []; this.isIndeterminate = false; &#125;, // 切换角色 handlecheckedRolesChange(value) &#123; let checkedCount = value.length; this.checkAll = checkedCount === this.roles.length; this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.roles.length; &#125;, // 更新提交 update() &#123; // 防止表单重复提交 this.saveBtnDisabled = true; let ids = this.checkedRoles.join(&quot;,&quot;); //修改权限 userApi.saveAssign(this.userId, ids).then(response =&gt; &#123; if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;保存成功&#x27; &#125;); this.$router.push(&#123;path: &#x27;/auth/user/list&#x27;&#125;); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 自行启动项目进行测试我自己已经测试过了 41-权限控制-角色管理修改 auth_user 表的，open_id 字段，因为这个表是给工作人员使用的，也就是内部自己使用的系统，后面我会编写一套专门提供给用户使用的那个会使用到微信登录所以字段取值为 open_id，把当前这个表的 open_id 改为 username SQL 如下 12ALTER TABLE `video_db`.`auth_user` CHANGE COLUMN `open_id` `username` VARCHAR ( 20 ) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27; AFTER `id`; 修改 UserController 的分页查询中的过滤条件如下图 修改前端 list.vue 修改内容如下图 还需要修改 form.vue 修改内容如下 后端去除 RoleMenu 与 UserRole 类当中的逻辑删除分别如下 修改 RoleController java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * &lt;p&gt; * 角色 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@Api(tags = &quot;角色组&quot;)@RestController@RequestMapping(&quot;/service_auth/admin/role&quot;)public class RoleController &#123; @Resource private RoleService roleService; @ApiOperation(value = &quot;获取角色分页列表&quot;) @GetMapping(&quot;/getRolePageList/&#123;page&#125;/&#123;limit&#125;&quot;) public ResponseResult index(@ApiParam(name = &quot;page&quot;, value = &quot;当前页码&quot;, required = true) @PathVariable Long page, @ApiParam(name = &quot;limit&quot;, value = &quot;每页记录数&quot;, required = true) @PathVariable Long limit, Role role) &#123; // 开启分页 Page&lt;Role&gt; pageParam = new Page&lt;&gt;(page, limit); // 构建查询条件 QueryWrapper&lt;Role&gt; wrapper = new QueryWrapper&lt;&gt;(); if (!StringUtils.isEmpty(role.getRoleName())) &#123; wrapper.like(&quot;role_name&quot;, role.getRoleName()); &#125; // 根据查询条件进行分页 roleService.page(pageParam, wrapper); // 返回结果 return ResponseResult.ok() .data(&quot;items&quot;, pageParam.getRecords()) .data(&quot;total&quot;, pageParam.getTotal()); &#125; @ApiOperation(value = &quot;获取角色&quot;) @GetMapping(&quot;/getRoleById/&#123;id&#125;&quot;) public ResponseResult get(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;item&quot;, roleService.getById(id)); &#125; @ApiOperation(value = &quot;新增角色&quot;) @PostMapping(&quot;/saveRole&quot;) public ResponseResult save(@RequestBody Role role) &#123; roleService.save(role); return ResponseResult.ok(); &#125; @ApiOperation(value = &quot;修改角色&quot;) @PostMapping(&quot;/updateRole&quot;) public ResponseResult updateById(@RequestBody Role role) &#123; roleService.updateById(role); return ResponseResult.ok(); &#125; @ApiOperation(value = &quot;删除角色&quot;) @PostMapping(&quot;/removeRole/&#123;id&#125;&quot;) public ResponseResult remove(@PathVariable String id) &#123; roleService.removeById(id); return ResponseResult.ok(); &#125; @ApiOperation(value = &quot;根据id列表删除角色(批量删除)&quot;) @PostMapping(&quot;/batchRemoveRole&quot;) public ResponseResult batchRemove(@RequestBody List&lt;String&gt; idList) &#123; roleService.removeByIds(idList); return ResponseResult.ok(); &#125;&#125; 修改 RoleService java 123456789101112131415161718192021222324252627282930/** * &lt;p&gt; * 角色 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */public interface RoleService extends IService&lt;Role&gt; &#123; /** * &lt;b&gt; * 根据用户ID获取角色数据 * &lt;/b&gt; * * @param userId 用户ID * @return 角色数据 */ Map&lt;String, Object&gt; findRoleByUserId(String userId); /** * &lt;b&gt; * 根据用户ID分配用户角色 * &lt;/b&gt; * * @param userId 用户ID * @param roleId 角色ID */ void saveUserRoleRelationShip(String userId, String[] roleId);&#125; 修改 RoleServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &lt;p&gt; * 角色 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@Servicepublic class RoleServiceImpl extends ServiceImpl&lt;RoleMapper, Role&gt; implements RoleService &#123; @Resource private UserRoleService userRoleService; /** * &lt;b&gt; * 根据用户ID获取角色数据 * &lt;/b&gt; */ @Override public Map&lt;String, Object&gt; findRoleByUserId(String userId) &#123; // 1.查询出所有的角色 List&lt;Role&gt; allRoles = baseMapper.selectList(null); // 2.当前用户选中的角色有哪些 QueryWrapper&lt;UserRole&gt; queryWrapper = new QueryWrapper&lt;UserRole&gt;() .eq(&quot;user_id&quot;, userId) .select(&quot;role_id&quot;); // 获取到当前用户所在的角色关系 List&lt;UserRole&gt; userRoleList = userRoleService.list(queryWrapper); // 取出所有的roleId 放到一个集合当中 List&lt;String&gt; roleIds = userRoleList.stream().map(UserRole::getRoleId).collect(Collectors.toList()); // 根据角色id,取出所有的角色对象 List&lt;Role&gt; userRoles = new ArrayList&lt;&gt;(); allRoles.forEach(role -&gt; &#123; if (roleIds.contains(role.getId())) &#123; userRoles.add(role); &#125; &#125;); Map&lt;String, Object&gt; roleMap = new HashMap&lt;&gt;(2); // 用户的角色 roleMap.put(&quot;assignRoles&quot;, userRoles); // 所有的角色 roleMap.put(&quot;allRolesList&quot;, allRoles); return roleMap; &#125; /** * &lt;b&gt; * 根据用户ID分配用户角色 * &lt;/b&gt; */ @Override public void saveUserRoleRelationShip(String userId, String[] roleId) &#123; // 1.删除原来角色与用户之间的关系 userRoleService.remove(new QueryWrapper&lt;UserRole&gt;().eq(&quot;user_id&quot;, userId)); // 2.重新建立关系 List&lt;UserRole&gt; userRoleArrayList = Stream.of(roleId).map(role -&gt; &#123; UserRole userRole = new UserRole(); userRole.setUserId(userId); userRole.setRoleId(role); return userRole; &#125;).collect(Collectors.toList()); // 3.批量保存关系 userRoleService.saveBatch(userRoleArrayList); &#125;&#125; 前端新增 api 文件 role.js javascript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import request from &#x27;@/utils/request&#x27;;const api_name = &#x27;/service_auth/admin/role&#x27;;export default &#123; // 获取分页列表数据 getPageList(page, limit, searchObj) &#123; return request(&#123; url: `$&#123;api_name&#125;/getRolePageList/$&#123;page&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, // url查询字符串或表单键值对 params: searchObj &#125;); &#125;, // 根据ID获取角色 getById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/getRoleById/$&#123;id&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 保存角色 save(role) &#123; return request(&#123; url: `$&#123;api_name&#125;/saveRole`, method: &#x27;post&#x27;, data: role &#125;); &#125;, // 更新角色 updateById(role) &#123; return request(&#123; url: `$&#123;api_name&#125;/updateRole`, method: &#x27;post&#x27;, data: role &#125;); &#125;, // 删除角色 removeById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/removeRole/$&#123;id&#125;`, method: &#x27;post&#x27; &#125;); &#125;, // 批量删除 removeRows(idList) &#123; return request(&#123; url: `$&#123;api_name&#125;/batchRemoveRole`, method: &#x27;post&#x27;, data: idList &#125;); &#125;&#125; 修改路由文件 index.js javascript 123456789101112131415161718192021222324252627&#123; path: &#x27;role/list&#x27;, name: &#x27;角色管理&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/role/list&#x27;), meta: &#123;title: &#x27;角色管理&#x27;&#125;&#125;,&#123; path: &#x27;role/form&#x27;, name: &#x27;添加角色&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/role/form&#x27;), meta: &#123;title: &#x27;添加角色&#x27;&#125;, hidden: true&#125;,&#123; path: &#x27;role/update/:id&#x27;, name: &#x27;修改角色&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/role/form&#x27;), meta: &#123;title: &#x27;修改角色&#x27;&#125;, hidden: true&#125;,&#123; path: &#x27;role/distribution/:id&#x27;, name: &#x27;角色权限&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/role/roleForm&#x27;), meta: &#123;title: &#x27;角色权限&#x27;&#125;, hidden: true&#125;, 新增对应的 vue 页面如下, form.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form ref=&quot;role&quot; :model=&quot;role&quot; :rules=&quot;validateRules&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;角色名称&quot; prop=&quot;roleName&quot;&gt; &lt;el-input v-model=&quot;role.roleName&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot;&gt;保存&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import roleApi from &#x27;@/api/video/auth/role&#x27;;const defaultForm = &#123; roleName: &#x27;&#x27;&#125;export default &#123; name: &quot;form&quot;, data() &#123; return &#123; role: defaultForm, // 保存按钮是否禁用 saveBtnDisabled: false, validateRules: &#123; roleName: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;角色名必须输入&#x27;&#125;] &#125; &#125; &#125;, // 监听器 watch: &#123; $route(to, from) &#123; this.init(); &#125; &#125;, // 生命周期方法（在路由切换，组件不变的情况下不会被调用） created() &#123; this.init() &#125;, methods: &#123; // 表单初始化 init() &#123; if (this.$route.params &amp;&amp; this.$route.params.id) &#123; const id = this.$route.params.id; this.fetchDataById(id); &#125; else &#123; // 对象拓展运算符：拷贝对象，而不是赋值对象的引用 this.role = &#123;...defaultForm&#125;; &#125; &#125;, saveOrUpdate() &#123; this.$refs.role.validate(valid =&gt; &#123; if (valid) &#123; // 防止表单重复提交 this.saveBtnDisabled = true; if (!this.role.id) &#123; this.saveData(); &#125; else &#123; this.updateData(); &#125; &#125; &#125;); &#125;, // 新增讲师 saveData() &#123; roleApi.save(this.role).then(response =&gt; &#123; // debugger if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) this.$router.push(&#123;path: &#x27;/auth/role/list&#x27;&#125;); &#125; &#125;); &#125;, // 根据id更新记录 updateData() &#123; // teacher数据的获取 roleApi.updateById(this.role).then(response =&gt; &#123; if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: response.message &#125;) this.$router.push(&#123;path: &#x27;/auth/role/list&#x27;&#125;); &#125; &#125;); &#125;, // 根据id查询记录 fetchDataById(id) &#123; roleApi.getById(id).then(response =&gt; &#123; this.role = response.data.item; &#125;); &#125; &#125;&#125;&lt;/script&gt; list.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;searchObj.roleName&quot; placeholder=&quot;角色名称&quot;/&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;fetchData()&quot;&gt;查询&lt;/el-button&gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt; &lt;!-- 工具条 --&gt; &lt;div&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;addUser()&quot;&gt;添加&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;removeRows()&quot;&gt;批量删除&lt;/el-button&gt; &lt;/div&gt; &lt;!-- 角色列表 --&gt; &lt;el-table v-loading=&quot;listLoading&quot; :data=&quot;list&quot; stripe style=&quot;width: 100%&quot; @selection-change=&quot;handleSelectionChange&quot;&gt; &lt;el-table-column type=&quot;selection&quot;/&gt; &lt;el-table-column label=&quot;序号&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=&quot;center&quot; prop=&quot;roleName&quot; label=&quot;角色名称&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/auth/role/distribution/&#x27;+scope.row.id&quot;&gt; 分配权限 &lt;/router-link&gt; &lt;router-link :to=&quot;&#x27;/auth/role/update/&#x27;+scope.row.id&quot;&gt; 编辑 &lt;/router-link&gt; &lt;a @click=&quot;removeDataById(scope.row.id)&quot;&gt;删除&lt;/a&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页组件 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :total=&quot;total&quot; :page-size=&quot;limit&quot; :page-sizes=&quot;[5, 10, 20, 30, 40, 50, 100]&quot; style=&quot;padding: 30px 0; text-align: center;&quot; layout=&quot;sizes, prev, pager, next, jumper, -&gt;, total, slot&quot; @current-change=&quot;fetchData&quot; @size-change=&quot;changeSize&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import roleApi from &#x27;@/api/video/auth/role&#x27;;export default &#123; name: &quot;list&quot;, data() &#123; return &#123; // 数据是否正在加载 listLoading: true, // 讲师列表 list: null, // 数据库中的总记录数 total: 0, // 默认页码 page: 1, // 每页记录数 limit: 10, // 查询表单对象 searchObj: &#123;&#125;, // 批量选择中选择的记录列表 multipleSelection: [] &#125; &#125;, // 生命周期函数：内存准备完毕，页面尚未渲染 created() &#123; this.fetchData() &#125;, methods: &#123; // 当页码发生改变的时候 changeSize(size) &#123; this.limit = size; this.fetchData(1); &#125;, addUser() &#123; this.$router.push(&#123;path: &#x27;/auth/role/form&#x27;&#125;); &#125;, // 加载讲师列表数据 fetchData(page = 1) &#123; this.listLoading = true; // 异步获取远程数据（ajax） this.page = page; roleApi.getPageList(this.page, this.limit, this.searchObj).then(response =&gt; &#123; this.list = response.data.items; this.total = response.data.total; // 数据加载并绑定成功 this.listLoading = false; &#125; ); &#125;, // 重置查询表单 resetData() &#123; this.searchObj = &#123;&#125;; this.fetchData(); &#125;, // 根据id删除数据 removeDataById(id) &#123; this.$confirm(&#x27;此操作将永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 点击确定，远程调用ajax return roleApi.removeById(id); &#125;).then((response) =&gt; &#123; this.fetchData(this.page); if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;); &#125; &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;); &#125;, // 当表格复选框选项发生变化的时候触发 handleSelectionChange(selection) &#123; this.multipleSelection = selection; &#125;, // 批量删除 removeRows() &#123; if (this.multipleSelection.length === 0) &#123; this.$message(&#123; type: &#x27;warning&#x27;, message: &#x27;请选择要删除的记录!&#x27; &#125;); return; &#125; this.$confirm(&#x27;此操作将永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 点击确定，远程调用ajax // 遍历selection，将id取出放入id列表 let idList = []; this.multipleSelection.forEach(item =&gt; &#123; idList.push(item.id); &#125;); // 调用api return roleApi.removeRows(idList); &#125;).then((response) =&gt; &#123; this.fetchData(this.page); if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;); &#125; &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;); &#125; &#125;&#125;&lt;/script&gt; roleForm.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;template&gt; &lt;div style=&quot;margin: 20px 20px&quot;&gt; &lt;el-tree :data=&quot;data&quot; show-checkbox default-expand-all node-key=&quot;id&quot; ref=&quot;tree&quot; highlight-current :props=&quot;defaultProps&quot;&gt; &lt;/el-tree&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;save&quot;&gt;保存&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import menu from &#x27;@/api/video/auth/menu&#x27;;export default &#123; name: &quot;roleForm&quot;, data() &#123; return &#123; saveBtnDisabled: false, data: [], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;name&#x27; &#125;, roleId: &#x27;&#x27; &#125;; &#125;, // 监听器 watch: &#123; $route(to, from) &#123; this.init(); &#125; &#125;, created() &#123; this.init(); &#125;, methods: &#123; init() &#123; if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.roleId = this.$route.params.id; this.fetchDataById(this.roleId); &#125; &#125;, fetchDataById(roleId) &#123; menu.getMenuWithRoleId(roleId).then(response =&gt; &#123; this.data = response.data.children; let jsonList = JSON.parse(JSON.stringify(this.data)); let list = []; this.getJsonToList(list, jsonList[0][&#x27;children&#x27;]); this.setCheckedKeys(list); &#125;) &#125;, // 把json数据转成string再转成对象，根据Key获取value数据 getJsonToList(list, jsonList) &#123; // 遍历这个集合对象，获取key的值 for (let i = 0; i &lt; jsonList.length; i++) &#123; if (jsonList[i][&#x27;select&#x27;] === true &amp;&amp; jsonList[i][&#x27;level&#x27;] === 4) &#123; list.push(jsonList[i][&#x27;id&#x27;]); &#125; if (jsonList[i][&#x27;children&#x27;] != null) &#123; this.getJsonToList(list, jsonList[i][&#x27;children&#x27;]); &#125; &#125; &#125;, getCheckedKeys() &#123; console.log(this.$refs.tree.getCheckedKeys()); &#125;, setCheckedKeys(list) &#123; this.$refs.tree.setCheckedKeys(list); &#125;, save() &#123; this.saveBtnDisabled = true; let ids = this.$refs.tree.getCheckedKeys().join(&quot;,&quot;); console.log(ids); menu.doAssignRoleAuth(this.roleId, ids).then(response =&gt; &#123; if (response.success) &#123; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;保存成功&#x27; &#125;) this.$router.push(&#123;path: &#x27;/auth/role/list&#x27;&#125;); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 修改 vue elementUI tree 树形控件使得能够获取父节点ID的实例，不修改源码之前是获取不到的，也就是说点击了一个子节点获取不到父节点的 ID 如下图 修改 node_modules\\element-ui\\lib\\element-ui.common.js 中的第 25382 行如下图 123if ((child.checked || child.indeterminate) &amp;&amp; (!leafOnly || leafOnly &amp;&amp; child.isLeaf)) &#123; checkedNodes.push(child.data);&#125; 42-权限控制-菜单管理后端修改 entity 包下的 Menu，新增如下内容 1234567891011121314151617181920/** * 层级 */@ApiModelProperty(value = &quot;层级&quot;)@TableField(exist = false)private Integer level;/** * 子菜单 */@ApiModelProperty(value = &quot;子菜单&quot;)@TableField(exist = false)private List&lt;Menu&gt; children = new ArrayList&lt;&gt;();/** * 是否为选中状态 */@ApiModelProperty(value = &quot;是否为选中状态&quot;)@TableField(exist = false)private boolean isSelect; 紧接着修改 MenuController 内容如下粘贴即可，业务比较简单，在完善 RBAC 的过程当中我会直接贴代码不在做过多的讲解了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * &lt;p&gt; * 菜单权限 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@Api(tags = &quot;菜单组&quot;)@RestController@RequestMapping(&quot;/service_auth/admin/menu&quot;)public class MenuController &#123; @Resource private MenuService menuService; /** * 查询所有菜单 */ @ApiOperation(value = &quot;查询所有菜单&quot;) @GetMapping(&quot;/getAllMenu&quot;) public ResponseResult indexAllMenu() &#123; return ResponseResult.ok().data(&quot;children&quot;, menuService.queryAllMenu()); &#125; /** * 递归删除菜单 */ @ApiOperation(value = &quot;递归删除菜单&quot;) @PostMapping(&quot;removeMenu/&#123;id&#125;&quot;) public ResponseResult remove(@PathVariable String id) &#123; // 删除当前菜单以及子菜单 menuService.removeChildById(id); return ResponseResult.ok(); &#125; /** * 根据角色获取菜单 */ @ApiOperation(value = &quot;根据角色获取菜单&quot;) @GetMapping(&quot;/getMenuWithRoleId/&#123;roleId&#125;&quot;) public ResponseResult toAssign(@PathVariable String roleId) &#123; return ResponseResult.ok().data(&quot;children&quot;, menuService.selectAllRoleMenu(roleId)); &#125; /** * 给角色分配权限 */ @ApiOperation(value = &quot;给角色分配权限&quot;) @PostMapping(&quot;/doAssignRoleAuth&quot;) public ResponseResult doAssign(@RequestParam String roleId, @RequestParam String[] menus) &#123; menuService.saveRoleMenuRelationShip(roleId, menus); return ResponseResult.ok(); &#125; /** * 新增菜单 */ @ApiOperation(value = &quot;新增菜单&quot;) @PostMapping(&quot;/saveMenu&quot;) public ResponseResult save(@RequestBody Menu permission) &#123; menuService.save(permission); return ResponseResult.ok(); &#125; /** * 修改菜单 */ @ApiOperation(value = &quot;修改菜单&quot;) @PostMapping(&quot;/updateMenu&quot;) public ResponseResult updateById(@RequestBody Menu menu) &#123; menuService.updateById(menu); return ResponseResult.ok(); &#125;&#125; 修改 MenuService 12345678910111213141516171819202122232425262728293031323334353637383940/** * &lt;p&gt; * 菜单权限 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */public interface MenuService extends IService&lt;Menu&gt; &#123; /** * 查询所有菜单 * * @return 菜单信息 */ List&lt;Menu&gt; queryAllMenu(); /** * 递归删除菜单 * * @param id 菜单ID */ void removeChildById(String id); /** * 根据角色获取菜单 * * @param roleId 角色ID * @return 菜单信息 */ List&lt;Menu&gt; selectAllRoleMenu(String roleId); /** * 给角色分配权限 * * @param roleId 角色ID * @param menus 分配的权限 */ void saveRoleMenuRelationShip(String roleId, String[] menus);&#125; 修改 MenuServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * &lt;p&gt; * 菜单权限 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */@Servicepublic class MenuServiceImpl extends ServiceImpl&lt;MenuMapper, Menu&gt; implements MenuService &#123; @Resource private RoleMenuService roleMenuService; @Override public List&lt;Menu&gt; queryAllMenu() &#123; // 1.查询所有的菜单 List&lt;Menu&gt; menuList = baseMapper.selectList(null); // 2.构建树级菜单 return buildTreeMenu(menuList); &#125; @Override public void removeChildById(String id) &#123; // 最终要删除的idList List&lt;String&gt; idList = new ArrayList&lt;&gt;(); idList.add(id); // 递归查找出所有的子菜单的id selectChildMenu(id, idList); // 批量删除 baseMapper.deleteBatchIds(idList); &#125; @Override public List&lt;Menu&gt; selectAllRoleMenu(String roleId) &#123; // 1.查询所有的菜单(利用CAST函数把ID转换为了整数: SIGNED，在排序) QueryWrapper&lt;Menu&gt; qw = new QueryWrapper&lt;Menu&gt;().orderByAsc(&quot;CAST(id AS SIGNED)&quot;); List&lt;Menu&gt; menuList = baseMapper.selectList(qw); // 2.根据角色,查询角色对象的菜单权限 QueryWrapper&lt;RoleMenu&gt; queryWrapper = new QueryWrapper&lt;RoleMenu&gt;().eq(&quot;role_id&quot;, roleId); List&lt;RoleMenu&gt; roleMenuList = roleMenuService.list(queryWrapper); // 3.确定哪些菜单成为选中状态 menuList.forEach(menu -&gt; roleMenuList.forEach(roleMenu -&gt; &#123; if (menu.getId().equals(roleMenu.getPermissionId())) &#123; menu.setSelect(true); &#125; &#125;)); // 4.构建树级菜单 return buildTreeMenu(menuList); &#125; @Override public void saveRoleMenuRelationShip(String roleId, String[] menus) &#123; // 1.删除原来的角色权限 roleMenuService.remove(new QueryWrapper&lt;RoleMenu&gt;().eq(&quot;role_id&quot;, roleId)); // 2.重新构建角色权限 List&lt;RoleMenu&gt; roleMenuArrayList = Stream.of(menus).map(menu -&gt; &#123; RoleMenu roleMenu = new RoleMenu(); roleMenu.setRoleId(roleId); roleMenu.setPermissionId(menu); return roleMenu; &#125;).collect(Collectors.toList()); // 3.批量保存 roleMenuService.saveBatch(roleMenuArrayList); &#125; /** * 构建树形菜单 */ private List&lt;Menu&gt; buildTreeMenu(List&lt;Menu&gt; menuList) &#123; // 最终返回的树级菜单 List&lt;Menu&gt; menus = new ArrayList&lt;&gt;(); menuList.forEach(menu -&gt; &#123; // 查找最顶级的菜单 if (&quot;0&quot;.equals(menu.getPid())) &#123; // 设置顶级菜单的级别 menu.setLevel(1); // 构造子菜单 buildChildrenMenu(menu, menuList); menus.add(menu); &#125; &#125;); return menus; &#125; /** * 构建子菜单 */ private void buildChildrenMenu(Menu menu, List&lt;Menu&gt; menuList) &#123; // 从menuList当中查找当前的子菜单 menuList.forEach(m -&gt; &#123; // 判断是不是自己的子菜单 if (menu.getId().equals(m.getPid())) &#123; // 是子菜单 int level = menu.getLevel() + 1; // 设置级别 m.setLevel(level); // 递归设置子菜单 menu.getChildren().add(m); buildChildrenMenu(m, menuList); &#125; &#125;); &#125; /** * 查询子菜单 */ private void selectChildMenu(String id, List&lt;String&gt; idList) &#123; // 查询出当前id子菜单的条件 QueryWrapper&lt;Menu&gt; queryWrapper = new QueryWrapper&lt;Menu&gt;().eq(&quot;pid&quot;, id).select(&quot;id&quot;); // 开始查询 List&lt;Menu&gt; childMenuList = baseMapper.selectList(queryWrapper); if (childMenuList.size() &gt; 0) &#123; // 取出子菜单id放到集合当中 childMenuList.forEach(menu -&gt; &#123; idList.add(menu.getId()); this.selectChildMenu(menu.getId(), idList); &#125;); &#125; &#125;&#125; 前端新增 api 文件 menu.js javascript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import request from &#x27;@/utils/request&#x27;;const api_name = &#x27;/service_auth/admin/menu&#x27;;export default &#123; // 获取所有菜单 getNestedTreeList() &#123; return request(&#123; url: `$&#123;api_name&#125;/getAllMenu`, method: &#x27;get&#x27; &#125;); &#125;, // 删除菜单 removeById(id) &#123; return request(&#123; url: `$&#123;api_name&#125;/removeMenu/$&#123;id&#125;`, method: &quot;post&quot; &#125;); &#125;, // 保存菜单 saveMenu(menu) &#123; return request(&#123; url: `$&#123;api_name&#125;/saveMenu`, method: &quot;post&quot;, data: menu &#125;); &#125;, // 更新菜单 update(menu) &#123; return request(&#123; url: `$&#123;api_name&#125;/updateMenu`, method: &quot;post&quot;, data: menu &#125;); &#125;, // 根据角色获取菜单 getMenuWithRoleId(roleId) &#123; return request(&#123; url: `$&#123;api_name&#125;/getMenuWithRoleId/$&#123;roleId&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 根据角色分配权限 doAssignRoleAuth(roleId, menus) &#123; return request(&#123; url: `$&#123;api_name&#125;/doAssignRoleAuth`, method: &quot;post&quot;, params: &#123;roleId, menus&#125; &#125;); &#125;&#125; 新增菜单管理的路由修改 router\\index.js javascript 123456&#123; path: &#x27;menu/list&#x27;, name: &#x27;菜单管理&#x27;, component: () =&gt; import(&#x27;@/views/video/auth/menu/list&#x27;), meta: &#123;title: &#x27;菜单管理&#x27;&#125;&#125;, 新增 list.vue 新增位置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- row-key,数据当中,哪一个字段能够唯一的标识一行 :expand-row-keys 要求传入的是一个数组 --&gt; &lt;el-table :data=&quot;menuList&quot; style=&quot;width: 100%;margin-bottom: 20px;&quot; :expand-row-keys=&quot;expands&quot; row-key=&quot;id&quot; ref=&quot;refTable&quot; @row-click=&quot;clickTable&quot; border :tree-props=&quot;&#123;children: &#x27;children&#x27;, hasChildren: &#x27;hasChildren&#x27;&#125;&quot;&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; sortable align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;path&quot; label=&quot;访问路径&quot; sortable align=&quot;center&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;component&quot; label=&quot;组件路径&quot; sortable align=&quot;center&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;permissionValue&quot; label=&quot;权限值&quot; align=&quot;center&quot;/&gt; &lt;!--CRUD操作--&gt; &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click.native.stop=&quot;() =&gt; &#123;dialogFormVisible = true,menu.pid = scope.row.id&#125;&quot;&gt;添加菜单 &lt;/el-button&gt; &lt;el-button type=&quot;success&quot; size=&quot;mini&quot; @click.native.stop=&quot;() =&gt; getById(scope.row)&quot;&gt;修改菜单 &lt;/el-button&gt; &lt;el-button type=&quot;success&quot; size=&quot;mini&quot; @click.native.stop=&quot;() =&gt; &#123;dialogPermissionVisible = true, permission.pid = scope.row.id&#125;&quot;&gt;添加权限 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click.native.stop=&quot;() =&gt; updateFunction(scope.row)&quot;&gt;修改权限 &lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click.native.stop=&quot;() =&gt; remove(scope.row)&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 添加菜单的窗口 --&gt; &lt;el-dialog :visible.sync=&quot;dialogFormVisible&quot; :title=&quot;dialogFormValue&quot;&gt; &lt;el-form ref=&quot;menu&quot; :model=&quot;menu&quot; :rules=&quot;menuValidateRules&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;菜单名称&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;menu.name&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;访问路径&quot; prop=&quot;path&quot;&gt; &lt;el-input v-model=&quot;menu.path&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;组件路径&quot; prop=&quot;component&quot;&gt; &lt;el-input v-model=&quot;menu.component&quot;/&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetData()&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addMenuClick()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 添加权限的窗口 --&gt; &lt;el-dialog :visible.sync=&quot;dialogPermissionVisible&quot; title=&quot;添加功能权限&quot;&gt; &lt;el-form ref=&quot;permission&quot; :model=&quot;permission&quot; :rules=&quot;permissionValidateRules&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;功能名称&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;permission.name&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;访问路径&quot;&gt; &lt;el-input v-model=&quot;permission.path&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;组件路径&quot;&gt; &lt;el-input v-model=&quot;permission.component&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;功能权限值&quot; prop=&quot;permissionValue&quot;&gt; &lt;el-input v-model=&quot;permission.permissionValue&quot;/&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;resetData()&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;appendPermission()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import menu from &#x27;@/api/video/auth/menu&#x27;;// 菜单实体const menuForm = &#123; name: &#x27;&#x27;, pid: 0, path: &#x27;&#x27;, component: &#x27;&#x27;, type: 1&#125;// 权限实体const perForm = &#123; permissionValue: &#x27;&#x27;, name: &#x27;&#x27;, path: &#x27;&#x27;, component: &#x27;&#x27;, pid: 0, type: 2&#125;export default &#123; name: &quot;list&quot;, // 初始化相关属性 data() &#123; return &#123; menuList: [], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;name&#x27; &#125;, dialogFormValue: &#x27;添加菜单&#x27;, dialogFormVisible: false, dialogPermissionVisible: false, menu: &#123;...menuForm&#125;, permission: &#123;...perForm&#125;, menuValidateRules: &#123; name: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;菜单名必须输入&#x27;&#125;], path: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;菜单路径必须输入&#x27;&#125;], component: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;组件名称必须输入&#x27;&#125;] &#125;, permissionValidateRules: &#123; name: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;功能名称必须输入&#x27;&#125;], permissionValue: [&#123;required: true, trigger: &#x27;blur&#x27;, message: &#x27;功能权限值必须输入&#x27;&#125;] &#125;, // 要展开的行，数值的元素是row的key值 expands: [] &#125; &#125;, created() &#123; // 获取列表数据 this.fetchNodeList(); &#125;, methods: &#123; // table的方法,展开/折叠 行 clickTable(row, index, e) &#123; // 调用,table的方法,展开/折叠 行 this.$refs.refTable.toggleRowExpansion(row); &#125;, // 获取列表数据 fetchNodeList() &#123; menu.getNestedTreeList().then(res =&gt; &#123; if (res.success === true) &#123; this.menuList = res.data.children; this.expands.push(this.menuList[0].id); this.resetData(); &#125; &#125;); &#125;, // 删除菜单 remove(data) &#123; this.$confirm(&#x27;此操作将永久删除该记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; return menu.removeById(data.id); &#125;).then(() =&gt; &#123; // 刷新列表 this.fetchNodeList(); this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;); // 失败 &#125;).catch((res) =&gt; &#123; if (res === &#x27;cancel&#x27;) &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125; else &#123; this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;删除失败&#x27; &#125;); &#125; &#125;); &#125;, // 添加功能权限 appendPermission() &#123; this.$refs.permission.validate(valid =&gt; &#123; if (valid) &#123; if (this.permission.id) &#123; this.update(this.permission); &#125; else &#123; menu.saveMenu(this.permission).then(res =&gt; &#123; this.dialogPermissionVisible = false; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加权限成功&#x27; &#125;); // 刷新数据，展开菜单 menu.getNestedTreeList().then(res =&gt; &#123; if (res.success === true) &#123; this.menuList = res.data.children; this.expands.push(this.permission.pid); this.resetData(); &#125; &#125;); &#125;); &#125; &#125; &#125;); &#125;, // 添加菜单点击 addMenuClick() &#123; this.$refs.menu.validate(valid =&gt; &#123; if (valid) &#123; // 添加 if (!this.menu.id) &#123; this.addMenu(); &#125; else &#123; // 修改 this.update(this.menu); &#125; &#125; &#125;) &#125;, // 添加菜单 addMenu() &#123; menu.saveMenu(this.menu).then(res =&gt; &#123; this.dialogFormVisible = false this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加菜单成功&#x27; &#125;) // 刷新数据，展开菜单 menu.getNestedTreeList().then(response =&gt; &#123; if (response.success === true) &#123; this.menuList = response.data.children; // 展开刚添加菜单的父级 this.expands.push(this.menu.pid); this.resetData(); &#125; &#125;); &#125;).catch(error =&gt; &#123; this.dialogFormVisible = false; this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;添加菜单失败&#x27; &#125;); &#125;); &#125;, // 修改菜单 update(obj) &#123; menu.update(obj).then(res =&gt; &#123; this.dialogFormVisible = false; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改成功&#x27; &#125;); // 刷新页面 this.fetchNodeList(); this.resetData(); &#125;) &#125;, // 获取菜单信息 getById(data) &#123; this.dialogFormVisible = true; this.menu = data; &#125;, // 修改权限点击 updateFunction(data) &#123; this.dialogPermissionVisible = true; this.permission = data; &#125;, // 重置数据 resetData() &#123; this.dialogPermissionVisible = false; this.dialogFormVisible = false; this.menu = &#123;...menuForm&#125;; this.permission = &#123;...perForm&#125;; &#125; &#125;&#125;&lt;/script&gt; 菜单相关数据插入 SQL 123456789101112131415161718192021222324252627282930313233343536373839INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1&#x27;, &#x27;0&#x27;, &#x27;全部数据&#x27;, 0, NULL, NULL, NULL, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195268474480156673&#x27;, &#x27;1&#x27;, &#x27;权限管理&#x27;, 1, NULL, &#x27;/authority&#x27;, &#x27;Layout&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195268616021139457&#x27;, &#x27;1195268474480156673&#x27;, &#x27;用户管理&#x27;, 1, NULL, &#x27;user/list&#x27;, &#x27;authority/user/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195268788138598401&#x27;, &#x27;1195268474480156673&#x27;, &#x27;角色管理&#x27;, 1, NULL, &#x27;role/list&#x27;, &#x27;authority/role/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195268893830864898&#x27;, &#x27;1195268474480156673&#x27;, &#x27;菜单管理&#x27;, 1, NULL, &#x27;menu/list&#x27;, &#x27;authority/menu/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269143060602882&#x27;, &#x27;1195268616021139457&#x27;, &#x27;查看&#x27;, 2, &#x27;user.list&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269295926206466&#x27;, &#x27;1195268616021139457&#x27;, &#x27;添加&#x27;, 2, &#x27;user.add&#x27;, &#x27;user/add&#x27;, &#x27;authority/user/form&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269473479483394&#x27;, &#x27;1195268616021139457&#x27;, &#x27;修改&#x27;, 2, &#x27;user.update&#x27;, &#x27;user/update/:id&#x27;, &#x27;authority/user/form&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269547269873666&#x27;, &#x27;1195268616021139457&#x27;, &#x27;删除&#x27;, 2, &#x27;user.remove&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269821262782465&#x27;, &#x27;1195268788138598401&#x27;, &#x27;修改&#x27;, 2, &#x27;role.update&#x27;, &#x27;role/update/:id&#x27;, &#x27;authority/role/form&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195269903542444034&#x27;, &#x27;1195268788138598401&#x27;, &#x27;查看&#x27;, 2, &#x27;role.list&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270037005197313&#x27;, &#x27;1195268788138598401&#x27;, &#x27;添加&#x27;, 2, &#x27;role.add&#x27;, &#x27;role/form&#x27;, &#x27;authority/role/form&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270442602782721&#x27;, &#x27;1195268788138598401&#x27;, &#x27;删除&#x27;, 2, &#x27;role.remove&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270621548568578&#x27;, &#x27;1195268788138598401&#x27;, &#x27;角色权限&#x27;, 2, &#x27;role.acl&#x27;, &#x27;role/distribution/:id&#x27;, &#x27;authority/role/roleForm&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270744097742849&#x27;, &#x27;1195268893830864898&#x27;, &#x27;查看&#x27;, 2, &#x27;menu.list&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270810560684034&#x27;, &#x27;1195268893830864898&#x27;, &#x27;添加&#x27;, 2, &#x27;menu.add&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270862100291586&#x27;, &#x27;1195268893830864898&#x27;, &#x27;修改&#x27;, 2, &#x27;menu.update&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195270887933009922&#x27;, &#x27;1195268893830864898&#x27;, &#x27;删除&#x27;, 2, &#x27;menu.remove&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195349439240048642&#x27;, &#x27;1&#x27;, &#x27;创作者管理&#x27;, 1, NULL, &#x27;/author&#x27;, &#x27;Layout&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195349699995734017&#x27;, &#x27;1195349439240048642&#x27;, &#x27;创作者列表&#x27;, 1, NULL, &#x27;table&#x27;, &#x27;video/author/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195349810561781761&#x27;, &#x27;1195349439240048642&#x27;, &#x27;添加创作者&#x27;, 1, NULL, &#x27;save&#x27;, &#x27;video/author/save&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195349876252971010&#x27;, &#x27;1195349810561781761&#x27;, &#x27;添加&#x27;, 2, &#x27;author.add&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195349979797753857&#x27;, &#x27;1195349699995734017&#x27;, &#x27;查看&#x27;, 2, &#x27;author.list&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350117270261762&#x27;, &#x27;1195349699995734017&#x27;, &#x27;修改&#x27;, 2, &#x27;author.update&#x27;, &#x27;edit/:id&#x27;, &#x27;video/author/save&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350188359520258&#x27;, &#x27;1195349699995734017&#x27;, &#x27;删除&#x27;, 2, &#x27;author.remove&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350299365969922&#x27;, &#x27;1&#x27;, &#x27;作品分类&#x27;, 1, NULL, &#x27;/video/category&#x27;, &#x27;Layout&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350397751758850&#x27;, &#x27;1195350299365969922&#x27;, &#x27;作品分类列表&#x27;, 1, NULL, &#x27;list&#x27;, &#x27;video/category/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350500512206850&#x27;, &#x27;1195350299365969922&#x27;, &#x27;上传作品分类&#x27;, 1, NULL, &#x27;import&#x27;, &#x27;video/category/save&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350612172967938&#x27;, &#x27;1195350397751758850&#x27;, &#x27;查看&#x27;, 2, &#x27;category.list&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350687590748161&#x27;, &#x27;1195350500512206850&#x27;, &#x27;导入&#x27;, 2, &#x27;category.import&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350831744782337&#x27;, &#x27;1&#x27;, &#x27;作品管理&#x27;, 1, NULL, &#x27;/video/content&#x27;, &#x27;Layout&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195350919074385921&#x27;, &#x27;1195350831744782337&#x27;, &#x27;作品列表&#x27;, 1, NULL, &#x27;list&#x27;, &#x27;video/content/list&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195351020463296513&#x27;, &#x27;1195350831744782337&#x27;, &#x27;添加作品&#x27;, 1, NULL, &#x27;info&#x27;, &#x27;video/content/info&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195351159672246274&#x27;, &#x27;1195350919074385921&#x27;, &#x27;发布作品&#x27;, 2, &#x27;content.publish&#x27;, &#x27;send/:id&#x27;, &#x27;video/content/send&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195351326706208770&#x27;, &#x27;1195350919074385921&#x27;, &#x27;编辑课程&#x27;, 2, &#x27;content.update&#x27;, &#x27;info/:id&#x27;, &#x27;video/content/info&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1195351566221938690&#x27;, &#x27;1195350919074385921&#x27;, &#x27;章节信息&#x27;, 2, &#x27;chapter.update&#x27;, &#x27;chapter/:id&#x27;, &#x27;video/content/chapter&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1196301740985311234&#x27;, &#x27;1195268616021139457&#x27;, &#x27;分配角色&#x27;, 2, &#x27;user.assgin&#x27;, &#x27;user/role/:id&#x27;, &#x27;authority/user/roleForm&#x27;, NULL, NULL, 0, &#x27;2021-05-05 19:17:09&#x27;, &#x27;2021-05-05 19:17:09&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1388495490356727810&#x27;, &#x27;1195349699995734017&#x27;, &#x27;测试&#x27;, 2, &#x27;test&#x27;, &#x27;&#x27;, &#x27;&#x27;, NULL, NULL, 1, &#x27;2021-05-01 22:08:17&#x27;, &#x27;2021-05-01 22:08:17&#x27;);INSERT INTO `video_db`.`auth_menu` (`id`, `pid`, `name`, `type`, `permission_value`, `path`, `component`, `icon`, `status`, `is_deleted`, `gmt_create`, `gmt_modified`) VALUES (&#x27;1388495557524312066&#x27;, &#x27;1195349699995734017&#x27;, &#x27;test2&#x27;, 2, &#x27;test2&#x27;, &#x27;2&#x27;, &#x27;2&#x27;, NULL, NULL, 1, &#x27;2021-05-01 22:08:33&#x27;, &#x27;2021-05-01 22:08:45&#x27;); 43-权限控制-security权限控制 添加依赖12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.it6666&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Security依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; common_security 包分别如下 configTokenWebSecurityConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @author BNTang * @version 1.0 * @project video_parent * @description Security配置 * @since Created in 2021/5/2 002 12:02 **/@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class TokenWebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 自定义查询数据库类 */ private UserDetailsService userDetailsService; /** * Token管理器 */ private TokenManager tokenManager; /** * 密码加密方式 */ private DefaultPasswordEncoder defaultPasswordEncoder; /** * redis操作 */ private RedisTemplate redisTemplate; /** * 自定义查询数据库 */ @Autowired public TokenWebSecurityConfig(UserDetailsService userDetailsService, DefaultPasswordEncoder defaultPasswordEncoder, TokenManager tokenManager, RedisTemplate redisTemplate) &#123; this.userDetailsService = userDetailsService; this.defaultPasswordEncoder = defaultPasswordEncoder; this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; &#125; /** * 配置设置 */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.exceptionHandling() .authenticationEntryPoint(new UnauthorizedEntryPoint()) .and().csrf().disable() .authorizeRequests() .anyRequest().authenticated() .and().logout().logoutUrl(&quot;/service_auth/admin/index/logout&quot;) .addLogoutHandler(new TokenLogoutHandler(tokenManager, redisTemplate)).and() .addFilter(new TokenLoginFilter(authenticationManager(), tokenManager, redisTemplate)) .addFilter(new TokenAuthenticationFilter(authenticationManager(), tokenManager, redisTemplate)).httpBasic(); &#125; /** * 密码处理 */ @Override public void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(defaultPasswordEncoder); &#125; /** * 配置哪些请求不拦截 */ @Override public void configure(WebSecurity web) &#123; web.ignoring().antMatchers( &quot;/api/**&quot;, &quot;/swagger-resources/**&quot;, &quot;/webjars/**&quot;, &quot;/v2/**&quot;, &quot;/swagger-ui.html/**&quot;); &#125;&#125; entitySecurityUser 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author BNTang * @version 1.0 * @project video_parent * @description 安全认证用户详情信息 * @since Created in 2021/5/2 002 12:07 **/@Data@Slf4jpublic class SecurityUser implements UserDetails &#123; /** * 当前登录用户 */ private transient User currentUserInfo; /** * 当前权限 */ private List&lt;String&gt; permissionValueList; public SecurityUser(User user) &#123; if (user != null) &#123; this.currentUserInfo = user; &#125; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); permissionValueList.forEach(permissionValue -&gt; &#123; if (StringUtils.isEmpty(permissionValue)) &#123; return; &#125; SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue); authorities.add(authority); &#125;); return authorities; &#125; @Override public String getPassword() &#123; return currentUserInfo.getPassword(); &#125; @Override public String getUsername() &#123; return currentUserInfo.getUsername(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; User 1234567891011121314151617181920212223242526272829/** * @author BNTang * @version 1.0 * @project video_parent * @description 用户实体类 * @since Created in 2021/5/2 002 12:10 **/@Data@ApiModel(description = &quot;用户实体类&quot;)public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;用户名&quot;) private String username; @ApiModelProperty(value = &quot;密码&quot;) private String password; @ApiModelProperty(value = &quot;昵称&quot;) private String nickName; @ApiModelProperty(value = &quot;用户头像&quot;) private String salt; @ApiModelProperty(value = &quot;用户签名&quot;) private String token;&#125; filterTokenAuthenticationFilter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/5/2 002 12:11 **/public class TokenAuthenticationFilter extends BasicAuthenticationFilter &#123; private final TokenManager tokenManager; private final RedisTemplate redisTemplate; public TokenAuthenticationFilter(AuthenticationManager authManager, TokenManager tokenManager, RedisTemplate redisTemplate) &#123; super(authManager); this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; &#125; @Override protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException &#123; logger.info(&quot;RequestURI = &quot; + req.getRequestURI()); if (!req.getRequestURI().contains(&quot;admin&quot;)) &#123; chain.doFilter(req, res); return; &#125; UsernamePasswordAuthenticationToken authentication = null; try &#123; authentication = getAuthentication(req); &#125; catch (Exception e) &#123; ResponseUtil.out(res, ResponseResult.error()); &#125; if (authentication != null) &#123; SecurityContextHolder.getContext().setAuthentication(authentication); &#125; else &#123; ResponseUtil.out(res, ResponseResult.error()); &#125; chain.doFilter(req, res); &#125; private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) &#123; // token置于header里 String token = request.getHeader(&quot;X-Token&quot;); if (null != token &amp;&amp; !&quot;&quot;.equals(token.trim())) &#123; String userName = tokenManager.getUserFromToken(token); List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(userName); Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); if (!CollectionUtils.isEmpty(permissionValueList)) &#123; authorities = permissionValueList.stream().map(permissionValue -&gt; &#123; if (StringUtils.isEmpty(permissionValue)) &#123; return null; &#125; return new SimpleGrantedAuthority(permissionValue); &#125;).collect(Collectors.toList()); &#125; if (!StringUtils.isEmpty(userName)) &#123; return new UsernamePasswordAuthenticationToken(userName, token, authorities); &#125; return null; &#125; return null; &#125;&#125; TokenLoginFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author BNTang * @version 1.0 * @project video_parent * @description 登录过滤器，继承UsernamePasswordAuthenticationFilter，对用户名密码进行登录校验 * @since Created in 2021/5/2 002 12:12 **/public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123; private final AuthenticationManager authenticationManager; private final TokenManager tokenManager; private final RedisTemplate&lt;String, java.util.List&lt;String&gt;&gt; redisTemplate; public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate&lt;String, java.util.List&lt;String&gt;&gt; redisTemplate) &#123; this.authenticationManager = authenticationManager; this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; this.setPostOnly(false); this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher( &quot;/service_auth/admin/index/login&quot;, &quot;POST&quot;)); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res) throws AuthenticationException &#123; try &#123; User user = new ObjectMapper().readValue(req.getInputStream(), User.class); return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;())); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 登录成功 */ @Override protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain, Authentication auth) &#123; SecurityUser user = (SecurityUser) auth.getPrincipal(); String token = tokenManager.createToken(user.getCurrentUserInfo().getUsername()); redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList()); ResponseUtil.out(res, ResponseResult.ok().data(&quot;token&quot;, token)); &#125; /** * 登录失败 */ @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) &#123; ResponseUtil.out(response, ResponseResult.error()); &#125;&#125; security DefaultPasswordEncoder 12345678910111213141516171819202122232425262728/** * @author BNTang * @version 1.0 * @project video_parent * @description 密码的处理方法类型 * @since Created in 2021/5/2 002 12:13 **/@Componentpublic class DefaultPasswordEncoder implements PasswordEncoder &#123; public DefaultPasswordEncoder() &#123; this(-1); &#125; public DefaultPasswordEncoder(int strength) &#123; &#125; @Override public String encode(CharSequence rawPassword) &#123; return Md5.encrypt(rawPassword.toString()); &#125; @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; return encodedPassword.equals(Md5.encrypt(rawPassword.toString())); &#125;&#125; TokenLogoutHandler 12345678910111213141516171819202122232425262728/** * @author BNTang * @version 1.0 * @project video_parent * @description 登出业务逻辑类 * @since Created in 2021/5/2 002 12:13 **/public class TokenLogoutHandler implements LogoutHandler &#123; private TokenManager tokenManager; private RedisTemplate redisTemplate; public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) &#123; this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; &#125; @Override public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123; String token = request.getHeader(&quot;X-Token&quot;); if (token != null) &#123; // 清空当前用户缓存中的权限数据 String userName = tokenManager.getUserFromToken(token); redisTemplate.delete(userName); &#125; ResponseUtil.out(response, ResponseResult.ok()); &#125;&#125; TokenManager 12345678910111213141516171819202122232425262728/** * @author BNTang * @version 1.0 * @project video_parent * @description token管理 * @since Created in 2021/5/2 002 12:14 **/@Componentpublic class TokenManager &#123; private final String TOKEN_SIGNKEY = &quot;BNTang&quot;; public String createToken(String username) &#123; // token 过期时间 long tokenExpiration = 24 * 60 * 60 * 1000; return Jwts.builder().setSubject(username) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration)) .signWith(SignatureAlgorithm.HS512, TOKEN_SIGNKEY).compressWith(CompressionCodecs.GZIP).compact(); &#125; public String getUserFromToken(String token) &#123; return Jwts.parser() .setSigningKey(TOKEN_SIGNKEY) .parseClaimsJws(token) .getBody() .getSubject(); &#125;&#125; UnauthorizedEntryPoint 123456789101112131415/** * @author BNTang * @version 1.0 * @project video_parent * @description 未授权的统一处理方式 * @since Created in 2021/5/2 002 12:14 **/public class UnauthorizedEntryPoint implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) &#123; ResponseUtil.out(response, ResponseResult.error()); &#125;&#125; common_utils 模块utilsResponseUtil java 1234567891011121314151617181920/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/5/2 002 13:06 **/public class ResponseUtil &#123; public static void out(HttpServletResponse response, ResponseResult r) &#123; ObjectMapper mapper = new ObjectMapper(); response.setStatus(HttpStatus.OK.value()); response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); try &#123; mapper.writeValue(response.getWriter(), r); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 44-权限控制-Token与JWT登录模型单一服务器模式单一服务器，用户认证，用户信息存储到 session 当中 SSO(single sign on) 模式单点登录(Single Sign On，SSO)就是通过用户的一次性鉴别登录 当用户在身份认证服务器上登录一次以后，即可获得访问单点登录系统中其他关联系统和应用软件的权限，同时这种实现是不需要管理员对用户的登录状态或其他信息进行修改的，这意味着在多个应用系统中，用户只需一次登录就可以访问所有相互信任的应用系统 优点，用户身份信息独立管理，更好的分布式管理，可以自己扩展安全策略 缺点，认证服务器访问压力较大 Token 模式Token 是一种无状态、跨服务器、高性能的验证模式 特点，无状态、可扩展，支持移动设备，跨程序调用，安全 原理 基于 Token 的身份验证是无状态的，我们不用将用户信息存在服务器或 Session 中, 用户通过用户名和密码发送请求, 程序验证, 程序返回一个签名的 token 给客户端, 客户端储存 token, 并且每次请求都会附带它, 服务端验证 token 并返回数据 原理图 优点，无状态：token 无状态，session 是有状态的，基于标准化，你的 API 可以采用标准化的 JSON Web Token(JWT) 缺点，占用带宽，无法在服务器端销毁 验证方式传统用户身份验证特点，用户向服务器发送用户名和密码，服务器验证相关数据后（如用户角色，登录时间等）将保存在当前会话中，用户的每个后续请求都将通过在 Cookie 中取出 session_id 传给服务器，服务器收到 session_id 并对比之前保存的数据，确认用户的身份，服务器向用户返回 session_id，session 信息都会写入到用户的 Cookie 缺点，没有分布式架构，无法支持横向扩展 session 共享将透明令牌存入 cookie，将用户身份信息存入 redis JWT 令牌在微服务之间使用 JWT 共享信息 JWT 令牌什么是 JWT在微服务之间使用 JWT 共享信息 JSON Web Token（JWT）是一个开放的行业标准（RFC 7519）它定义了一种简介的、自包含的协议格式，用于在通信双方传递 JSON 对象, 传递的信息经过数字签名可以被验证和信任, JWT 可以使用 HMAC 算法或使用 RSA 的公钥 &#x2F; 私钥对来签名，防止被篡改, 对普通的信息进行加密处理后, 转成 JSON, 转过之后的数据称它是 token JWT 能做什么授权, 这是使用 JWT 的最常见方案。一旦用户登录，每个后续请求将包括 JWT，从而允许用户访问该令牌允许的路由，服务和资源, 登录成功之后, 生成一个 JWT 当中包含用户的信息 信息交换, JSON Web Token 是在各方之间安全地传输信息的好方法 session 认证与 JWT 认证的区别session: 基于 session 和基于 jwt 的方式的主要区别就是用户的状态保存的位置，session 是保存在服务端的，下一次再去从 session 当中取数据 jwt: 用户输入用户名与密码, 校验(从数据库当中查看有没有对应的数据)如果有对应的数据, 会把用户取出来, 把取出的用户数据, 转成 JWT，以 token 令牌的形式传给前端, 前端拿到数据之后, 会给存储到 cookie，以后每一次请求都要携带 token，服务器就会获取 token 之后, 再进行 jwt 解析, 读取用户数据, 如果没有数据, 就代表没有登录, 而 jwt 是保存在客户端的 JWT 令牌的优缺点优点：jwt 基于 JSON，非常方便解析, 可以在令牌中自定义丰富的内容，易扩展, 通过 非对称 加密算法及数字签名技术，JWT 防止篡改，安全性高, 资源服务使用 JWT 可不依赖认证服务即可完成授权 缺点：JWT 令牌较长，占存储空间比较大 令牌结构JWT 令牌由三部分组成，每部分中间使用点（.）分隔, 比如：xxxxx.yyyyy.zzzzz 三部分HeaderJWT 头部分是一个描述 JWT 元数据的 JSON 对象, 头部包括令牌的类型（即 JWT）及使用的哈希算法（如 HMAC SHA256 或 RSA） 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; Payload第二部分是负载，内容也是一个 JSON 对象, JWT 指定七个默认字段供选择 iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID 用于标识该 JWT 除以上默认字段外，我们还可以自定义私有字段 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;456&quot;, &quot;admin&quot;: true&#125; 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容, 最后将第二部分负载使用 Base64Url 编码，得到一个字符串就是 JWT 令牌的第二部分 Signature第三部分签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改, 首先，需要指定一个密码（secret）该密码仅仅为保存在服务器中，并且不能向用户公开, 然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名 123HMACSHA256( base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret) 在工具类当中集成 JWT 令牌在 common_utils 微服务当中添加 jwt 依赖如下，你直接替换一下全部的内容吧 common_utils pom.xml 依赖如下 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;!-- JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--工具类包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 JwtUtils java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author BNTang * @version 1.0 * @project video_parent * @description jwt工具类 * @since Created in 2021/5/2 002 16:15 **/public class JwtUtils &#123; /** * 过期时间 */ public static final long EXPIRE = 1000 * 60 * 60 * 24; /** * 密钥 */ public static final String APP_SECRET = &quot;BNTang&quot;; /** * 根据id和昵称获取token */ public static String getJwtToken(String id, String nickname) &#123; return Jwts.builder() .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;) .setSubject(&quot;fm-user&quot;) .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) .claim(&quot;id&quot;, id) .claim(&quot;nickname&quot;, nickname) .signWith(SignatureAlgorithm.HS256, APP_SECRET) .compact(); &#125; /** * 判断token是否存在与有效 */ public static boolean checkToken(String jwtToken) &#123; if (StringUtils.isEmpty(jwtToken)) &#123; return false; &#125; try &#123; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 判断token是否存在与有效 */ public static boolean checkToken(HttpServletRequest request) &#123; try &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) &#123; return false; &#125; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 根据token获取id */ public static String getUserIdByJwtToken(HttpServletRequest request) &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) &#123; return &quot;&quot;; &#125; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); Claims claims = claimsJws.getBody(); return (String) claims.get(&quot;id&quot;); &#125;&#125; 45-权限控制-auth工程当中添加用户验证Service创建 IndexService 123456789101112131415161718192021222324/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/5/2 002 21:03 **/public interface IndexService &#123; /** * 根据token获取用户信息 * * @param name 用户名 * @return 用户信息 */ Map&lt;String, Object&gt; getUserInfo(String name); /** * 获取当前登陆用户的菜单 * @param name 用户名 * @return 用户菜单信息 */ List&lt;JSONObject&gt; getMenu(String name);&#125; 修改 MenuService 123456789101112131415/** * 根据用户ID查询用户权限 * * @param id 用户ID * @return 用户权限 */List&lt;String&gt; selectPermissionValueByUserId(String id);/** * 根据用户id返回前端的菜单 * * @param id 用户id * @return 前端的菜单 */List&lt;JSONObject&gt; selectPermissionByUserId(String id); 修改 RoleService 1234567/** * 根据用户id查询角色 * * @param id 用户ID * @return 用户对应的角色 */List&lt;Role&gt; selectRoleByUserId(String id); 修改 UserService 1234567/** * 根据用户名从数据库中取出用户信息 * * @param username 用户名 * @return 用户信息 */User selectByUserName(String username); Impl创建 IndexServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/5/2 002 21:09 **/@Servicepublic class IndexServiceImpl implements IndexService &#123; @Resource private UserService userService; @Resource private RoleService roleService; @Resource private MenuService menuService; @Resource private RedisTemplate&lt;String, List&lt;String&gt;&gt; redisTemplate; /** * 根据用户名获取用户登录信息 */ @Override public Map&lt;String, Object&gt; getUserInfo(String username) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(4); User user = userService.selectByUserName(username); if (ObjectUtils.isEmpty(user)) &#123; throw new BnTangException(200001, &quot;没有该用户&quot;); &#125; // 根据用户id获取角色 List&lt;Role&gt; roleList = roleService.selectRoleByUserId(user.getId()); List&lt;String&gt; roleNameList = roleList.stream().map(Role::getRoleName).collect(Collectors.toList()); if (roleNameList.size() == 0) &#123; // 前端框架必须返回一个角色，否则报错，如果没有角色，返回一个空角色 roleNameList.add(&quot;&quot;); &#125; // 根据用户id获取操作权限值 List&lt;String&gt; permissionValueList = menuService.selectPermissionValueByUserId(user.getId()); // 把权限缓存到redis当中 redisTemplate.opsForValue().set(username, permissionValueList); result.put(&quot;name&quot;, user.getUsername()); result.put(&quot;avatar&quot;, user.getSalt()); result.put(&quot;roles&quot;, roleNameList); result.put(&quot;permissionValueList&quot;, permissionValueList); return result; &#125; /** * 根据用户名获取动态菜单 */ @Override public List&lt;JSONObject&gt; getMenu(String username) &#123; // 根据用户id获取用户菜单权限 return menuService.selectPermissionByUserId(userService.selectByUserName(username).getId()); &#125;&#125; 修改 MenuServiceImpl 12@Resourceprivate UserService userService; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Overridepublic List&lt;String&gt; selectPermissionValueByUserId(String id) &#123; List&lt;String&gt; selectPermissionValueList; if (this.isSysAdmin(id)) &#123; // 如果是系统管理员，获取所有权限 selectPermissionValueList = baseMapper.selectAllMenuValue(); &#125; else &#123; // 否则就不是系统管理员，根据用户查询菜单权限 selectPermissionValueList = baseMapper.selectMenuValueByUserId(id); &#125; return selectPermissionValueList;&#125;@Overridepublic List&lt;JSONObject&gt; selectPermissionByUserId(String id) &#123; List&lt;Menu&gt; selectMenuList; if (this.isSysAdmin(id)) &#123; // 如果是超级管理员，获取所有菜单 selectMenuList = baseMapper.selectList(null); &#125; else &#123; selectMenuList = baseMapper.selectMenuByUserId(id); &#125; // 1.构建树形菜单 List&lt;Menu&gt; menuList = buildTreeMenu(selectMenuList); // 2.返回给前端json数据 return buildMenuWebList(menuList);&#125;private List&lt;JSONObject&gt; buildMenuWebList(List&lt;Menu&gt; menuList) &#123; List&lt;JSONObject&gt; menus = new ArrayList&lt;&gt;(); if (menuList.size() == 1) &#123; // 左侧一级菜单 menuList.get(0).getChildren().forEach(oneMenu -&gt; &#123; JSONObject oneMenuObj = this.generateJsonObj(oneMenu, false); List&lt;JSONObject&gt; children = new ArrayList&lt;&gt;(); oneMenu.getChildren().forEach(twoMenu -&gt; &#123; JSONObject twoMenuObj = this.generateJsonObj(twoMenu, false); children.add(twoMenuObj); twoMenu.getChildren().forEach(three -&gt; &#123; if (StringUtils.isEmpty(three.getPath())) &#123; return; &#125; JSONObject threeMenu = this.generateJsonObj(three, true); children.add(threeMenu); &#125;); &#125;); oneMenuObj.put(&quot;children&quot;, children); menus.add(oneMenuObj); &#125;); &#125; return menus;&#125;/** * 生成菜单信息JSON对象 */private JSONObject generateJsonObj(Menu menu, Boolean whetherDisplay) &#123; JSONObject jsonObj = new JSONObject(); jsonObj.put(&quot;path&quot;, menu.getPath()); jsonObj.put(&quot;component&quot;, menu.getComponent()); jsonObj.put(&quot;hidden&quot;, whetherDisplay); JSONObject oneMeta = new JSONObject(); oneMeta.put(&quot;title&quot;, menu.getName()); if (!StringUtils.isEmpty(menu.getIcon())) &#123; oneMeta.put(&quot;icon&quot;, menu.getIcon()); &#125; jsonObj.put(&quot;meta&quot;, oneMeta); return jsonObj;&#125;/** * 判断用户是否是系统管理员 */private boolean isSysAdmin(String userId) &#123; User user = userService.getById(userId); return !ObjectUtils.isEmpty(user) &amp;&amp; &quot;admin&quot;.equals(user.getUsername());&#125; 修改 RoleServiceImpl 123456789101112131415161718@Overridepublic List&lt;Role&gt; selectRoleByUserId(String id) &#123; // 根据用户id查询拥有的角色id List&lt;UserRole&gt; userRoleList = userRoleService.list(new QueryWrapper&lt;UserRole&gt;() .eq(&quot;user_id&quot;, id) .select(&quot;role_id&quot;)); //获取所有角色id List&lt;String&gt; roleIdList = userRoleList.stream().map(UserRole::getRoleId).collect(Collectors.toList()); // 根据角色id查询所有的角色信息 List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); if (roleIdList.size() &gt; 0) &#123; roleList = baseMapper.selectBatchIds(roleIdList); &#125; return roleList;&#125; 创建 UserDetailsServiceImpl 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author BNTang * @version 1.0 * @project video_parent * @description 用户验证业务 * @since Created in 2021/5/2 002 16:42 **/@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Resource private UserService userService; @Resource private MenuService menuService; /*** * 根据账号获取用户信息 */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 从数据库中取出用户信息 User user = userService.selectByUserName(username); // 判断用户是否存在 if (ObjectUtils.isEmpty(user)) &#123; throw new UsernameNotFoundException(&quot;用户不存在！&quot;); &#125; // 返回UserDetails实现类 top.it6666.common_security.entity.User curUser = new top.it6666.common_security.entity.User(); BeanUtils.copyProperties(user, curUser); // 查询用户权限 List&lt;String&gt; authorities = menuService.selectPermissionValueByUserId(user.getId()); SecurityUser securityUser = new SecurityUser(curUser); securityUser.setPermissionValueList(authorities); return securityUser; &#125;&#125; 修改 UserServiceImpl 1234@Overridepublic User selectByUserName(String username) &#123; return baseMapper.selectOne(new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, username));&#125; Controller创建 IndexController 1234567891011121314151617181920212223242526272829303132333435/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/5/2 002 21:02 **/@Api(tags = &quot;工作人员-用户组&quot;)@RestController@RequestMapping(&quot;/service_auth/admin/index&quot;)public class IndexController &#123; @Resource private IndexService indexService; /** * 根据token获取用户信息 */ @ApiOperation(value = &quot;根据token获取用户信息&quot;) @GetMapping(&quot;info&quot;) public ResponseResult info() &#123; // 获取当前登录用户用户名 return ResponseResult.ok().data(indexService.getUserInfo(SecurityContextHolder.getContext().getAuthentication().getName())); &#125; /** * 获取当前登陆用户的菜单 */ @ApiOperation(value = &quot;获取当前登陆用户的菜单&quot;) @GetMapping(&quot;menu&quot;) public ResponseResult getMenu() &#123; // 获取当前登录用户用户名 List&lt;JSONObject&gt; menuList = indexService.getMenu(SecurityContextHolder.getContext().getAuthentication().getName()); return ResponseResult.ok().data(&quot;menuList&quot;, menuList); &#125;&#125; 修改 application.yml 加入 Redis 的相关配置 123456789101112redis: host: 127.0.0.1 port: 6379 database: 0 timeout: 1800000 lettuce: pool: max-active: 20 max-wait: 1 # 最大阻塞等待时间 max-idle: 5 min-idle: 0 修改 service_auth 的 pom.xml 加入 security 安全认证 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.it6666&lt;/groupId&gt; &lt;artifactId&gt;common_security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Mapper修改 MenuMapper 123456789101112131415161718192021222324252627282930313233/** * &lt;p&gt; * 菜单权限 Mapper 接口 * &lt;/p&gt; * * @author BNTang * @since 2021-04-21 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; /** * 查询所有的菜单 * * @return 菜单信息 */ List&lt;String&gt; selectAllMenuValue(); /** * 根据用户ID查询用户菜单权限 * * @param id 用户ID * @return 菜单权限 */ List&lt;String&gt; selectMenuValueByUserId(String id); /** * 根据用户id获取菜单权限 * * @param id 用户id * @return 菜单权限信息数据 */ List&lt;Menu&gt; selectMenuByUserId(String id);&#125; 修改 MenuMapper.xml xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.it6666.service_auth.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectAllMenuValue&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT permission_value FROM auth_menu WHERE type = 2 AND is_deleted = 0 &lt;/select&gt; &lt;select id=&quot;selectMenuValueByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT p.permission_value FROM auth_user_role ur INNER JOIN auth_role_menu rp ON rp.role_id = ur.role_id INNER JOIN auth_menu p ON p.id = rp.permission_id WHERE ur.user_id = #&#123;userId&#125; AND p.type = 2 AND ur.is_deleted = 0 AND rp.is_deleted = 0 AND p.is_deleted = 0 &lt;/select&gt; &lt;select id=&quot;selectMenuByUserId&quot; resultType=&quot;top.it6666.service_auth.entity.Menu&quot;&gt; SELECT p.id, p.pid, p.name, p.type, p.permission_value, path, p.component, p.icon, p.status, p.is_deleted FROM auth_user_role ur INNER JOIN auth_role_menu rp ON rp.role_id = ur.role_id INNER JOIN auth_menu p ON p.id = rp.permission_id WHERE ur.user_id = #&#123;userId&#125; AND ur.is_deleted = 0 AND rp.is_deleted = 0 AND p.is_deleted = 0 &lt;/select&gt;&lt;/mapper&gt; 修改 Menu 实体类去除逻辑删除 46-权限控制-前端权限按钮控制创建 button-control.js 如下代码的含义为就是校验一下看看是否有对应的权限如果有就是返回 true 没有就是 false 123456import store from &#x27;@/store&#x27;;export function hasBtnPermission(value) &#123; const myBtns = store.getters.buttons return myBtns.indexOf(value) &gt; -1;&#125; 将自定义的方法绑定到 vue 的实例上面这样我们就可以在 v-if 获取其它的标签当中直接使用我们的方法了如下 使用方式如下，看看是否有对应的权限值如果没有就不显示按钮给用户操作 修复一个 BUG 修改 user.js 如下添加如下内容即可修复，问题就是同一个用户登录，退出之后在登陆路由信息点击有问题就是重置路由的问题 47-前端门户-服务端渲染SSR关于服务端渲染 服务端渲染又称 SSR(Server Side Render) 是在服务端完成页面的内容，而不是在客户端通过 AJAX 获取数据。 服务器端渲染 (SSR) 的优势主要在于：更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 使用服务器端渲染，我们可以获得更快的内容到达时间 (time-to-content) 无需等待所有的 JavaScript 都完成下载并执行，产生更好的用户体验。 简单理解就是将组件或页面通过服务器生成 HTML 字符串，再发送到浏览器，最后将静态标记 “混合” 为客户端上完全交互的应用程序。 NUXT.js Nuxt.js 是一个基于 Vue.js 的轻量级应用框架, 可用来创建服务端渲染 (SSR) 应用。 也可以充当静态站点引擎生成静态站点应用, 具有优雅的代码结构分层和热加载等特性。 官方地址：https://zh.nuxtjs.org 一个用于 Vue.js 开发 SSR 应用的一站式解决方案。 Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于 Vue 的 SSR 框架。 NUXT 环境初始化有两种方式可以进行初始化 第一种就是直接去 GitHub 下载对应的模板 GitHub 地址：https://github.com/nuxt-community/starter-template 第二种就是使用 vue-cli 安装 vue-cli bash 1npm install -g @vue/cli-init bash 1vue init nuxt-community/starter-template video_portal 选择一个存放位置如下图所示 在该项目当中使用安装相关依赖 bash 1npm install 配置启动设置 NUXT 目录结构 资源目录：assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录：components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录：layouts 用于组织应用的布局组件。对整个页面进行整体划分布局。 页面目录：pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置，具体的页面信息。 插件目录：plugins 用于组织那些需要在根 vue.js 应用实例化之前需要运行的 Javascript 插件。 nuxt.config.js：文件，nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。 布局与页面 页面整合安装轮播图插件1npm install swiper vue-awesome-swiper --save 配置轮播图插件在 plugins 文件夹下新建文件 nuxt-swiper-plugin.js 1234import Vue from &#x27;vue&#x27;;import VueAwesomeSwiper from &#x27;vue-awesome-swiper&#x27;;Vue.use(VueAwesomeSwiper); 在 nuxt.config.js 文件中配置轮播图插件，将 plugins 和 css 节点复制到 module.exports 节点下 123456789101112/** plugins* */plugins: [ &#123;src: &#x27;~/plugins/nuxt-swiper-plugin.js&#x27;, ssr: false&#125;],/** CSS* */css: [ &#x27;swiper/swiper-bundle.css&#x27;] 集成 Element-UI安装 Element-UI1npm install element-ui 在 plugins 文件夹下，添加 ElementUI.js 文件 1234import Vue from &#x27;vue&#x27;;import ElementUI from &#x27;element-ui&#x27;;Vue.use(ElementUI); 在 nuxt.config.js 中添加 Element-UI 配置 1&#123;src: &#x27;~plugins/ElementUI&#x27;, ssr: true&#125; 1&#x27;element-ui/lib/theme-chalk/index.css&#x27; 页面布局复制静态资源将静态原型中的 css、img、js 目录拷贝至 assets 目录下, 将 favicon.ico 复制到 static 目录下，页面资源下载链接：https://wwe.lanzoui.com/iQyhyp5jwab 定义布局修改 layouts 目录下 default.vue 12345678910&lt;template&gt; &lt;div&gt; &lt;!-- 页头部分 --&gt; &lt;!-- 内容的区域 --&gt; &lt;nuxt/&gt; &lt;!-- 页尾部分 --&gt; &lt;/div&gt;&lt;/template&gt; 定义首页页面, 修改 pages/index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;template&gt; &lt;div&gt; &lt;!-- 轮播图 开始 --&gt; &lt;div class=&quot;warper&quot; style=&quot;position: relative&quot;&gt; &lt;div class=&quot;warper_content&quot;&gt; &lt;!--分类--&gt; &lt;div class=&quot;category&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(cate, index) in categoryList&quot; v-bind:key=&quot;index&quot;&gt; &lt;div class=&quot;coursex-item1&quot;&gt; &lt;a class=&quot;shuang&quot;&gt;&#123;&#123; cate.title &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;swiper :options=&quot;swiperOptions&quot; class=&quot;swiper-cus&quot;&gt; &lt;swiper-slide v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; :style=&quot;&#123;background:banner.imageBg&#125;&quot;&gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img width=&quot;1200&quot; height=&quot;380&quot; style=&quot;min-height: 380px;&quot; :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot;/&gt; &lt;/a&gt; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;div style=&quot;left: 200px;&quot; class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt; &lt;div style=&quot;right: 200px&quot; class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 轮播图 结束 --&gt; &lt;!--列表--&gt; &lt;div id=&quot;videoList&quot;&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:left; border-left: 3px solid red; padding-left: 10px;&quot;&gt;热门视频&lt;/span&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:right; font-size: 18px; &quot;&gt;&lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-video-list&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(content,index) in contentList&quot; class=&quot;fl&quot; v-bind:key=&quot;index&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;video-img&quot;&gt; &lt;img style=&quot;width: 100%;height: 100%&quot; :src=&quot;content.cover&quot; class=&quot;img-responsive&quot; &gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+content.id&quot; class=&quot;comm-btn c-btn-1&quot;&gt;播放&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123; content.title &#125;&#125;&lt;/a&gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-if=&quot;Number(content.price) === 0&quot;&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-else&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt; ￥&#123;&#123; content.price &#125;&#125;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.buyCount &#125;&#125; 人学习&lt;/i&gt;| &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.viewCount &#125;&#125; 人浏览&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- 优秀创作者 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:left; border-left: 3px solid red; padding-left: 10px;&quot;&gt;优秀创作者&lt;/span&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:right; font-size: 18px; &quot;&gt;&lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-author-list&quot;&gt; &lt;div v-for=&quot;(author,index) in authorList&quot; v-bind:key=&quot;index&quot; class=&quot;yd-open-course-card open-course-card&quot;&gt; &lt;a :href=&#x27;&quot;/author/&quot;+author.id&#x27; :title=&quot;index.name&quot; style=&quot;color: #7F828B;text-decoration:none;&quot;&gt; &lt;div class=&quot;yd-open-course-card_avatar&quot;&gt; &lt;img :alt=&quot;author.name&quot; :src=&quot;author.avatar&quot;&gt; &lt;/div&gt; &lt;div class=&quot;yd-open-course-card_content_teacher&quot;&gt; &lt;div class=&quot;yd-open-course-card_content_teacher_tag&quot;&gt;&#123;&#123; author.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&#123;&#123; author.intro &#125;&#125;&lt;/div&gt; &lt;span&gt;-------------------------&lt;/span&gt; &lt;div&gt;&#123;&#123; author.career &#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Swiper, &#123;Pagination, Navigation&#125; from &#x27;swiper&#x27;;Swiper.use([Pagination, Navigation]);import banner from &quot;@/api/banner&quot;;import index from &#x27;@/api/index&#x27;;export default &#123; data() &#123; return &#123; swiperOptions: &#123; loop: true, pagination: &#123; el: &#x27;.swiper-pagination&#x27; &#125;, // 配置导航 navigation: &#123; // 下一页dom节点 nextEl: &#x27;.swiper-button-next&#x27;, // 前一页dom节点 prevEl: &#x27;.swiper-button-prev&#x27; &#125; &#125;, bannerList: &#123;&#125;, categoryList: &#123;&#125;, authorList: &#123;&#125;, contentList: &#123;&#125;, &#125; &#125;, created() &#123; this.initBanner(); this.initIndexData(); &#125;, methods: &#123; initBanner() &#123; banner.getList().then(response =&gt; &#123; this.bannerList = response.data.list; &#125;); &#125;, initIndexData() &#123; index.getList().then(response =&gt; &#123; this.authorList = response.data.authorList; this.contentList = response.data.contentList; this.categoryList = response.data.categoryList; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; 路由固定路由使用 router-link 构建路由，地址是 &#x2F;course，在 page 目录创建文件夹 video，在 video 目录创建 index.vue 动态路由如果我们需要根据 id 查询一条记录，就需要使用动态路由，NUXT 的动态路由是以下划线开头的 vue 文件，参数名为下划线后边的文件名 静态页面布局页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;in-wrap&quot;&gt; &lt;!--头部布局--&gt; &lt;header id=&quot;header&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;h1 id=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;BNTang&quot;&gt; &lt;img src=&quot;~/assets/img/logo.png&quot; height=&quot;100px&quot; alt=&quot;BNTang&quot;&gt; &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;h-r-nsl&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot; tag=&quot;li&quot; active-class=&quot;current&quot; exact&gt; &lt;a&gt;首页&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/video&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;全部视频&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/author&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;创作者&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/article&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;资讯信息&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/qa&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;学习交流&lt;/a&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;!-- / nav --&gt; &lt;ul class=&quot;h-r-login&quot;&gt; &lt;li id=&quot;no-login&quot;&gt; &lt;a href=&quot;/login&quot;&gt; &lt;em class=&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;vam ml5&quot;&gt;登录&lt;/span&gt; &lt;/a&gt; | &lt;a href=&quot;/register&quot;&gt; &lt;span class=&quot;vam ml5&quot;&gt;注册&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;aside class=&quot;h-r-search&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;label class=&quot;h-r-s-box&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜索...&quot; value&gt; &lt;button type=&quot;submit&quot; class=&quot;s-btn&quot;&gt; &lt;em class=&quot;icon18&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/button&gt; &lt;/label&gt; &lt;/form&gt; &lt;/aside&gt; &lt;/div&gt; &lt;aside class=&quot;mw-nav-btn&quot;&gt; &lt;div class=&quot;mw-nav-icon&quot;&gt;&lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;/header&gt; &lt;!--引入主体--&gt; &lt;nuxt/&gt; &lt;!--尾部布局--&gt; &lt;div class=&quot;footer&quot; style=&quot;height: 121px; background-color: #242A39; width: 100%;text-align: center;&quot;&gt; &lt;div class=&quot;&quot;&gt; &lt;div class=&quot;three links&quot;&gt;友情链接：&lt;a style=&quot;color: #ffff;&quot; href=&quot;https://tool.oschina.net/codeformat/js/&quot; target=&quot;_blank&quot;&gt;在线代码格式化&lt;/a&gt;&lt;a style=&quot;color: #ffff;&quot;&gt; &amp;nbsp;|&amp;nbsp; &lt;/a&gt;&lt;a style=&quot;color: #ffff;&quot; href=&quot;https://www.processon.com/&quot; target=&quot;_blank&quot;&gt;在线UML&lt;/a&gt;&lt;a style=&quot;color: #ffff;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;footer-words&quot;&gt; &lt;span&gt;版权所有 © 2021 BNTang 科技有限公司 &amp;nbsp; &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://www.beian.miit.gov.cn&quot; target=&quot;_blank&quot; style=&quot;color: #C0C4CC;&quot;&gt;苏ICP备20019650号-1&lt;/a&gt; &amp;nbsp;&lt;/span&gt; BNTang 技术有限公司 &lt;a style=&quot;padding-left: 14px;color:rgba(246,246,246,1);&quot; href=&quot;/sitemap.html&quot;&gt;网站地图&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &quot;~/assets/css/reset.css&quot;;import &quot;~/assets/css/theme.css&quot;;import &quot;~/assets/css/global.css&quot;;import &quot;~/assets/css/web.css&quot;;import &quot;~/assets/css/content.css&quot;;export default &#123; name: &quot;default&quot;, data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 封装 axios下载 axios使用命令 sh 1npm install axios 创建 utils 文件夹，utils 下创建 request.js javascript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import axios from &#x27;axios&#x27;;import &#123;MessageBox, Message&#125; from &#x27;element-ui&#x27;;// create an axios instanceconst service = axios.create(&#123; baseURL: &#x27;http://localhost:9000&#x27;, timeout: 5000 // request timeout&#125;);service.interceptors.response.use( response =&gt; &#123; const res = response.data; // if the custom code is not 20000, it is judged as an error. if (res.code !== 20000) &#123; Message(&#123; message: res.message || &#x27;Error&#x27;, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;); // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired; if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // to re-login MessageBox.confirm(&#x27;You have been logged out, you can cancel to stay on this page, or log in again&#x27;, &#x27;Confirm logout&#x27;, &#123; confirmButtonText: &#x27;Re-Login&#x27;, cancelButtonText: &#x27;Cancel&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; store.dispatch(&#x27;user/resetToken&#x27;).then(() =&gt; &#123; location.reload(); &#125;); &#125;); &#125; return Promise.reject(new Error(res.message || &#x27;Error&#x27;)); &#125; else &#123; return res; &#125; &#125;, error =&gt; &#123; Message(&#123; message: error.message, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;); return Promise.reject(error); &#125;);export default service; 48-前端门户-banner微服务创建 service_cms 工程 创建数据库12345678910111213CREATE TABLE `cms_banner` ( `id` CHAR ( 19 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;ID&#x27;, `title` VARCHAR ( 20 ) DEFAULT &#x27;&#x27; COMMENT &#x27;标题&#x27;, `image_url` VARCHAR ( 500 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;图片地址&#x27;, `link_url` VARCHAR ( 500 ) DEFAULT &#x27;&#x27; COMMENT &#x27;链接地址&#x27;, `image_bg` VARCHAR ( 500 ) DEFAULT &#x27;&#x27; COMMENT &#x27;背景颜色&#x27;, `sort` INT ( 10 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `is_deleted` TINYINT ( 1 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, `gmt_create` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY ( `id` ),UNIQUE KEY `uk_name` ( `title` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = &#x27;首页banner表&#x27;; 使用代码生成器生成代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author BNTang */public class CodeGenerator &#123; @Test public void main() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); //配置输出路径 gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_cms\\\\src\\\\main\\\\java&quot;); gc.setOpen(false); //生成后是否打开资源管理器 gc.setAuthor(&quot;BNTang&quot;); gc.setFileOverride(false); //重新生成时文件是否覆盖 /* * mp生成service层代码，默认接口名称第一个字母有 I * */ gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;service_cms&quot;); //模块名 pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;cms_banner&quot;); //数据库表映射到实体的命名策略 驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); //生成实体时去掉表前缀 strategy.setTablePrefix(&quot;cms_&quot;); //数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); //restful api风格控制器 strategy.setRestControllerStyle(true); //url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 添加配置文件创建 application.yml 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# application-dev.ymlserver: port: 8005logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-cms profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: HikariPool jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: nacos: discovery: server-addr: localhost:8848 redis: host: 127.0.0.1 port: 6379 database: 0 timeout: 1800000 lettuce: pool: max-active: 20 max-wait: 1 # 最大阻塞等待时间 max-idle: 5 min-idle: 0mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: top/it6666/service_cms/mapper/xml/*.xml 添加网关地址修改网关服务的 application.yml yaml 1234- id: service-cms uri: lb://service-cms predicates: - Path=/service_cms/** 添加启动类123456789101112/** * @author BNTang */@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;)@EnableDiscoveryClient@MapperScan(&quot;top.it6666.service_cms.mapper&quot;)public class CmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CmsApplication.class, args); &#125;&#125; 接口与业务修改 BannerController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * &lt;p&gt; * 首页banner表 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-05-15 */@Api(tags = &quot;首页banner组&quot;)@RestController@RequestMapping(&quot;/service_cms/banner&quot;)public class BannerController &#123; @Resource private BannerService bannerService; /** * 查询所有banner */ @ApiOperation(value = &quot;查询所有banner&quot;) @GetMapping(&quot;/getAllBanner&quot;) public ResponseResult getAllBanner() &#123; List&lt;Banner&gt; list = bannerService.selectAllBanner(); return ResponseResult.ok().data(&quot;list&quot;, list); &#125; /** * 分页查询banner */ @ApiOperation(value = &quot;分页查询banner&quot;) @GetMapping(&quot;pageBanner/&#123;page&#125;/&#123;limit&#125;&quot;) public ResponseResult pageBanner(@PathVariable long page, @PathVariable long limit) &#123; Page&lt;Banner&gt; pageBanner = new Page&lt;&gt;(page, limit); bannerService.page(pageBanner, null); return ResponseResult.ok() .data(&quot;items&quot;, pageBanner.getRecords()) .data(&quot;total&quot;, pageBanner.getTotal()); &#125; /** * 添加banner */ @ApiOperation(value = &quot;添加banner&quot;) @PostMapping(&quot;addBanner&quot;) public ResponseResult addBanner(@RequestBody Banner crmBanner) &#123; bannerService.save(crmBanner); return ResponseResult.ok(); &#125; /** * 获取Banner */ @ApiOperation(value = &quot;获取Banner&quot;) @GetMapping(&quot;get/&#123;id&#125;&quot;) public ResponseResult get(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;item&quot;, bannerService.getById(id)); &#125; /** * 修改Banner */ @ApiOperation(value = &quot;修改Banner&quot;) @PutMapping(&quot;update&quot;) public ResponseResult updateById(@RequestBody Banner banner) &#123; bannerService.updateById(banner); return ResponseResult.ok(); &#125; /** * 删除Banner */ @ApiOperation(value = &quot;删除Banner&quot;) @DeleteMapping(&quot;remove/&#123;id&#125;&quot;) public ResponseResult remove(@PathVariable String id) &#123; bannerService.removeById(id); return ResponseResult.ok(); &#125;&#125; 修改 BannerService.java 1234567891011121314151617/** * &lt;p&gt; * 首页banner表 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-05-15 */public interface BannerService extends IService&lt;Banner&gt; &#123; /** * 查询所有banner * * @return banner信息 */ List&lt;Banner&gt; selectAllBanner();&#125; 修改 BannerServiceImpl.java 1234567891011121314151617181920212223/** * &lt;p&gt; * 首页banner表 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-05-15 */@Servicepublic class BannerServiceImpl extends ServiceImpl&lt;BannerMapper, Banner&gt; implements BannerService &#123; @Cacheable(value = &quot;banner&quot;, key = &quot;&#x27;selectIndexList&#x27;&quot;) @Override public List&lt;Banner&gt; selectAllBanner() &#123; // 根据id进行降序排列，显示排列之后前两条记录 QueryWrapper&lt;Banner&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); // last方法，拼接sql语句 wrapper.last(&quot;limit 3&quot;); return baseMapper.selectList(null); &#125;&#125; 在如上的 BannerServiceImpl 当中添加了 Redis 缓存 SpringBoot 中 Redis 缓存注解介绍@Cacheable作用根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。 属性 value：缓存名，必填，它指定了你的缓存存放在哪块命名空间。 cacheNames：与 value 差不多，二选一即可。 key：可选属性，可以使用 SpEL 标签自定义缓存的 key。 @CachePut作用使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。 属性 value：缓存名，必填，它指定了你的缓存存放在哪块命名空间。 cacheNames：与 value 差不多，二选一即可。 key：可选属性，可以使用 SpEL 标签自定义缓存的 key。 @CacheEvict作用使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上。 属性 value：缓存名，必填，它指定了你的缓存存放在哪块命名空间。 cacheNames：与 value 差不多，二选一即可。 key：可选属性，可以使用 SpEL 标签自定义缓存的 key。 allEntries：是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存。 beforeInvocation：是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存。 示例如上的代码参考即可 banner 前端数据显示创建 api 文件夹，创建 banner.js 文件内容如下 javascript 12345678910111213import request from &#x27;@/utils/request&#x27;;export default &#123; getList() &#123; return request(&#123; url: &quot;/service_cms/banner/getAllBanner&quot;, method: &#x27;get&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;); &#125;&#125; 在首页面引入，调用实现, 引入 banner.js javascript 1import banner from &quot;@/api/banner&quot;; 在 data 当中定义 bannerList: &#123;&#125; 初始化时加载 banner 123created() &#123; this.initBanner();&#125; 1234567methods: &#123; initBanner() &#123; banner.getList().then(response =&gt; &#123; this.bannerList = response.data.list; &#125;); &#125;&#125; 页面渲染 12345678910111213141516171819202122232425262728&lt;div class=&quot;warper&quot; style=&quot;position: relative&quot;&gt; &lt;div class=&quot;warper_content&quot;&gt; &lt;!-- 分类 --&gt; &lt;div class=&quot;category&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(cate, index) in categoryList&quot; v-bind:key=&quot;index&quot;&gt; &lt;div class=&quot;coursex-item1&quot;&gt; &lt;a class=&quot;shuang&quot;&gt;&#123;&#123; cate.title &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;swiper :options=&quot;swiperOptions&quot; class=&quot;swiper-cus&quot;&gt; &lt;swiper-slide v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; :style=&quot;&#123;background:banner.imageBg&#125;&quot;&gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img width=&quot;1200&quot; height=&quot;380&quot; style=&quot;min-height: 380px;&quot; :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot;/&gt; &lt;/a&gt; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;div style=&quot;left: 200px;&quot; class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt; &lt;div style=&quot;right: 200px&quot; class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/div&gt; 49-前端门户-门户首页数据显示修改 service_video 模块在后台当中创建门户首页接口 创建 IndexPortalController.java12345678910111213141516171819202122/** * @author BNTang */@RestController@RequestMapping(&quot;/service_video/index&quot;)@Api(tags = &quot;门户首页组&quot;)public class IndexPortalController &#123; @Resource private IndexPortalService indexPortalService; /** * 获取门户首页所有数据 */ @GetMapping(&quot;/getIndexData&quot;) public ResponseResult index() &#123; return ResponseResult.ok() .data(&quot;contentList&quot;, indexPortalService.getContentIndexList()) .data(&quot;authorList&quot;, indexPortalService.getAuthorIndexList()) .data(&quot;categoryList&quot;, indexPortalService.getCategoryIndexList()); &#125; &#125; 接口创建 IndexPortalService.jav 12345678910111213141516171819202122232425/** * @author BNTang **/public interface IndexPortalService &#123; /** * 获取作品 * * @return 作品列表 */ Object getContentIndexList(); /** * 获取创作者 * * @return 创作者 */ Object getAuthorIndexList(); /** * 获取作品分类 * * @return 分类 */ Object getCategoryIndexList();&#125; 实现类创建 IndexPortalServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @author BNTang */@Servicepublic class IndexPortalServiceImpl implements IndexPortalService &#123; @Resource private ContentService contentService; @Resource private AuthorService authorService; @Resource private CategoryService categoryService; @Override @Cacheable(value = &quot;index&quot;, key = &quot;&#x27;getContentIndexList&#x27;&quot;) public List&lt;Content&gt; getContentIndexList() &#123; QueryWrapper&lt;Content&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); wrapper.last(&quot;limit 8&quot;); return contentService.list(wrapper); &#125; @Override @Cacheable(value = &quot;index&quot;, key = &quot;&#x27;getAuthorIndexList&#x27;&quot;) public List&lt;Author&gt; getAuthorIndexList() &#123; // 查询前4条作者 QueryWrapper&lt;Author&gt; wrapperAuthor = new QueryWrapper&lt;&gt;(); wrapperAuthor.orderByDesc(&quot;id&quot;); wrapperAuthor.last(&quot;limit 4&quot;); return authorService.list(wrapperAuthor); &#125; @Override @Cacheable(value = &quot;index&quot;, key = &quot;&#x27;getCategoryIndexList&#x27;&quot;) public List&lt;Category&gt; getCategoryIndexList() &#123; QueryWrapper&lt;Category&gt; wrapperCategory = new QueryWrapper&lt;&gt;(); wrapperCategory.orderByDesc(&quot;id&quot;); wrapperCategory.eq(&quot;parent_id&quot;, &quot;0&quot;); wrapperCategory.last(&quot;limit 8&quot;); return categoryService.list(wrapperCategory); &#125;&#125; 前端在门户工程 api 当中创建 index.js 文件 javascript 12345678910111213import request from &#x27;@/utils/request&#x27;;export default &#123; getList() &#123; return request(&#123; url: `/service_video/index/getIndexData`, method: &#x27;get&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;); &#125;&#125; 在首页面引入，调用实现 javascript 1import index from &#x27;@/api/index&#x27;; 定义数据结果集 123categoryList: &#123;&#125;,authorList: &#123;&#125;,contentList: &#123;&#125;, 请求数据 1this.initIndexData(); 1234567initIndexData() &#123; index.getList().then(response =&gt; &#123; this.authorList = response.data.authorList; this.contentList = response.data.contentList; this.categoryList = response.data.categoryList; &#125;);&#125; 渲染数据渲染分类 123456789&lt;div class=&quot;category&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(cate, index) in categoryList&quot; v-bind:key=&quot;index&quot;&gt; &lt;div class=&quot;coursex-item1&quot;&gt; &lt;a class=&quot;shuang&quot;&gt;&#123;&#123; cate.title &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 渲染视频 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;videoList&quot;&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:left; border-left: 3px solid red; padding-left: 10px;&quot;&gt;热门视频&lt;/span&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:right; font-size: 18px; &quot;&gt;&lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-video-list&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(content,index) in contentList&quot; class=&quot;fl&quot; v-bind:key=&quot;index&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;video-img&quot;&gt; &lt;img style=&quot;width: 100%;height: 100%&quot; :src=&quot;content.cover&quot; class=&quot;img-responsive&quot; &gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+content.id&quot; class=&quot;comm-btn c-btn-1&quot;&gt;播放&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123; content.title &#125;&#125;&lt;/a&gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-if=&quot;Number(content.price) === 0&quot;&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-else&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt; ￥&#123;&#123; content.price &#125;&#125;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.buyCount &#125;&#125; 人学习&lt;/i&gt;| &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.viewCount &#125;&#125; 人浏览&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; 渲染作者 12345678910111213141516171819202122232425262728&lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:left; border-left: 3px solid red; padding-left: 10px;&quot;&gt;优秀创作者&lt;/span&gt; &lt;span class=&quot;c-333&quot; style=&quot;float:right; font-size: 18px; &quot;&gt;&lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-author-list&quot;&gt; &lt;div v-for=&quot;(author,index) in authorList&quot; v-bind:key=&quot;index&quot; class=&quot;yd-open-course-card open-course-card&quot;&gt; &lt;a :href=&#x27;&quot;/author/&quot;+author.id&#x27; :title=&quot;index.name&quot; style=&quot;color: #7F828B;text-decoration:none;&quot;&gt; &lt;div class=&quot;yd-open-course-card_avatar&quot;&gt; &lt;img :alt=&quot;author.name&quot; :src=&quot;author.avatar&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;yd-open-course-card_content_teacher&quot;&gt; &lt;div class=&quot;yd-open-course-card_content_teacher_tag&quot;&gt;&#123;&#123; author.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&#123;&#123; author.intro &#125;&#125;&lt;/div&gt; &lt;span&gt;-------------------------&lt;/span&gt; &lt;div&gt;&#123;&#123; author.career &#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 50-门户登录-用户前端登录注册登录与注册按钮点击跳转到指定的页面处，如下图 在 Layout 当中添加新布局 loginLayout.vue 如下图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div class=&quot;login&quot;&gt; &lt;!--头部布局--&gt; &lt;header id=&quot;header&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;h1 id=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;BNTang&quot;&gt; &lt;img src=&quot;~/assets/img/logo.png&quot; height=&quot;100px&quot; alt=&quot;BNTang&quot;&gt; &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;h-r-nsl&quot;&gt; &lt;!--导航--&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot; tag=&quot;li&quot; active-class=&quot;current&quot; exact&gt; &lt;a&gt;首页&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/video&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;全部视频&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/author&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;创作者&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/article&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;资讯信息&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/qa&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;学习交流&lt;/a&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;!--搜索--&gt; &lt;aside class=&quot;h-r-search&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;label class=&quot;h-r-s-box&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜索...&quot; name=&quot;queryCourse.courseName&quot; value&gt; &lt;button type=&quot;submit&quot; class=&quot;s-btn&quot;&gt; &lt;em class=&quot;icon18&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/button&gt; &lt;/label&gt; &lt;/form&gt; &lt;/aside&gt; &lt;/div&gt; &lt;aside class=&quot;mw-nav-btn&quot;&gt; &lt;div class=&quot;mw-nav-icon&quot;&gt;&lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;/header&gt; &lt;!--页面信息--&gt; &lt;nuxt/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;loginLayout&quot;,&#125;&lt;/script&gt;&lt;style&gt;#logo a img&#123; width: 110px !important;&#125;&lt;/style&gt; 在 pages 文件夹下，创建登录与注册页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;login-up-container&quot;&gt; &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt; &lt;el-tab-pane label=&quot;用户登录&quot; name=&quot;first&quot;&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;立即注册&quot; name=&quot;second&quot;&gt;&lt;/el-tab-pane&gt; &lt;div class=&quot;login-up-container&quot;&gt; &lt;el-form ref=&quot;userForm&quot; :model=&quot;params&quot;&gt; &lt;!--用户昵称--&gt; &lt;el-form-item class=&quot;input-prepend restyle&quot; prop=&quot;nickname&quot; v-if=&quot;!isLogin&quot;&gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;用户昵称&quot; v-model=&quot;params.nickname&quot;/&gt; &lt;i class=&quot;iconfont icon-user&quot;/&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;!--用户手机号--&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot;&gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;手机号&quot; v-model=&quot;params.phone&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot;/&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;!--用户密码--&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;password&quot; v-if=&quot;isLogin&quot;&gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;用户密码&quot; v-model=&quot;params.password&quot; /&gt; &lt;i class=&quot;iconfont icon-password&quot;/&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;!--验证码--&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;code&quot; v-if=&quot;!isLogin&quot;&gt; &lt;div style=&quot;width: 100%;display: block;float: left;position: relative&quot;&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;验证码&quot; v-model=&quot;params.code&quot;/&gt; &lt;i class=&quot;iconfont icon-phone&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;btn&quot; style=&quot;position:absolute;right: -10px;top: 6px;width: 40%;&quot;&gt; &lt;a href=&quot;javascript:&quot; type=&quot;button&quot; @click=&quot;getCodeFun()&quot; :value=&quot;codeValue&quot; style=&quot;color: orangered&quot;&gt; &#123;&#123;codeValue&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;!--设置密码--&gt; &lt;el-form-item class=&quot;input-prepend&quot; prop=&quot;password&quot; v-if=&quot;!isLogin&quot;&gt; &lt;div&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;设置密码&quot; v-model=&quot;params.password&quot;/&gt; &lt;i class=&quot;iconfont icon-password&quot;/&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; v-model=&quot;btn_value&quot; class=&quot;login-up-button&quot; @click=&quot;btnClick()&quot;&gt; &lt;/div&gt; &lt;p class=&quot;login-up-msg&quot; v-if=&quot;!isLogin&quot;&gt; 点击 “注册” 即表示您同意并愿意遵守简书 &lt;br&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/c44d171298ce&quot;&gt;用户协议&lt;/a&gt; 和 &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/2ov8x3&quot;&gt;隐私政策&lt;/a&gt; 。 &lt;/p&gt; &lt;/el-form&gt; &lt;!-- 更多注册方式 --&gt; &lt;div class=&quot;more-sign&quot;&gt; &lt;h6&gt;社交帐号直接注册&lt;/h6&gt; &lt;ul&gt; &lt;li&gt; &lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; href=&quot;http://huaan.free.idcfengye.com/api/ucenter/wx/login&quot;&gt; &lt;i class=&quot;iconfont icon-weixin&quot;/&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;qq&quot; class=&quot;qq&quot; target=&quot;_blank&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;iconfont icon-qq&quot;/&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-tabs&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#x27;assets/css/login.css&#x27;import &#x27;~/assets/css/iconfont.css&#x27;export default &#123; layout: &#x27;loginLayout&#x27;, data () &#123; return &#123; // 记录当前是否为登录状态 isLogin:true, // 记录当前选择的tabs activeName: &#x27;first&#x27;, // 封装注册输入数据 params: &#123; phone: &#x27;&#x27;, // 验证码 code: &#x27;&#x27;, // 用户昵称 nickname: &#x27;&#x27;, password: &#x27;&#x27; &#125;, // 是否发送验证码 isSend: true, // 倒计时间 second: 60, codeValue: &#x27;获取验证码&#x27;, btn_value:&#x27;登录&#x27; &#125; &#125;, methods: &#123; handleClick(tab, event) &#123; if (tab.index == 0)&#123; this.isLogin = true; this.btn_value = &quot;登录&quot;; &#125;else &#123; this.isLogin = false; this.btn_value = &quot;注册&quot;; &#125; &#125;, checkPhone (rule, value, callback) &#123; if (!(/^1[34578]\\d&#123;9&#125;$/.test(value))) &#123; return callback(new Error(&#x27;手机号码格式不正确&#x27;)); &#125; return callback(); &#125;, &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在 api 当中创建 login.js 与 regist.js login.js123456789101112131415161718192021222324252627import request from &#x27;@/utils/request&#x27;;export default &#123; // 登录 login(userInfo) &#123; return request(&#123; url: `/service_user/user/login`, method: &#x27;post&#x27;, data: userInfo &#125;); &#125;, // 根据token获取用户信息 getLoginInfo() &#123; return request(&#123; url: `/service_user/user/auth/getLoginInfo`, method: &#x27;get&#x27;, &#125;); &#125;, // 验证是否已经登录 checkLogin()&#123; return request(&#123; url: `/service_user/user/wx/checkLogin`, method: &#x27;get&#x27;, &#125;); &#125;&#125; register.js12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 根据手机号发验证码 sendCode(phone) &#123; return request(&#123; url: `/service_sms/api/sms/send/$&#123;phone&#125;`, method: &#x27;get&#x27; &#125;); &#125;, // 注册的方法 register(formItem) &#123; return request(&#123; url: `/service_user/user/register`, method: &#x27;post&#x27;, data: formItem &#125;); &#125;&#125; 在 login.vue 页面当中引入 api 中创建的如上的两个 js 文件 javascript 12import registerApi from &quot;@/api/register&quot;;import loginApi from &quot;@/api/login&quot;; 获取验证码 javascript 1234567891011121314151617181920212223242526272829// 获取验证码timeDown() &#123; let result = setInterval(() =&gt; &#123; --this.second; this.codeValue = this.second+&quot;秒后重发&quot;; if (this.second &lt; 1) &#123; clearInterval(result); this.isSend = true; this.second = 60; this.codeValue = &quot;获取验证码&quot;; &#125; &#125;, 1000);&#125;,// 通过输入的手机号发送验证码getCodeFun() &#123; if (this.isSend)&#123; registerApi.sendCode(this.params.phone) .then(response =&gt; &#123; // 调用倒计时的方法 this.timeDown(); this.isSend = false; // 提示注册成功 this.$message(&#123; type: &#x27;success&#x27;, message: &quot;短信发送成功&quot; &#125;); &#125;); &#125;&#125; 注册功能 1234567891011121314151617181920btnClick() &#123; // 登录 if (this.isLogin)&#123; &#125;else &#123; // 注册 registerApi.register(this.params).then(response =&gt; &#123; // 提示注册成功 this.$message(&#123; type: &#x27;success&#x27;, message: &quot;注册成功&quot; &#125;); // 跳转登录页面 this.activeName = &quot;first&quot;; this.isLogin = true; this.btn_value = &quot;登录&quot;; &#125;); &#125;&#125;, 登录功能安装 js-cookie 插件1npm install js-cookie 引入 js-cookie 1import cookie from &#x27;js-cookie&#x27;; 登录逻辑 123456789101112131415loginApi.login(this.params).then(res=&gt;&#123; if(res.success)&#123; // 把token存在cookie中 cookie.set(&#x27;login_token&#x27;, res.data.token, &#123; domain: &#x27;localhost&#x27; &#125;); // 登录成功根据token获取用户信息 loginApi.getLoginInfo().then(response =&gt; &#123; // 将用户信息记录cookie cookie.set(&#x27;portal_user&#x27;, response.data.userInfo, &#123; domain: &#x27;localhost&#x27; &#125;); // 跳转页面 window.location.href = &quot;/&quot;; &#125;); &#125;&#125;); 首页中用户信息显示定义属性信息 javascript 123456789data() &#123; return &#123; loginInfo: &#123; id: &#x27;&#x27;, avatar: &#x27;&#x27;, nickname: &#x27;&#x27; &#125; &#125;&#125;, 在 created 方法当中加载用户信息 javascript 1234567891011121314151617created() &#123; this.showInfo();&#125;,methods: &#123; showInfo() &#123; let jsonStr = cookie.get(&quot;portal_user&quot;); if (jsonStr) &#123; this.loginInfo = JSON.parse(jsonStr); &#125; &#125;, logout() &#123; cookie.set(&#x27;portal_user&#x27;, &quot;&quot;, &#123;domain: &#x27;localhost&#x27;&#125;); cookie.set(&#x27;login_token&#x27;, &quot;&quot;, &#123;domain: &#x27;localhost&#x27;&#125;); // 跳转页面 window.location.href = &quot;/&quot;; &#125;&#125; 在首页当中显示登录成功之后的用户信息 1234567891011121314151617181920212223242526&lt;ul class=&quot;h-r-login&quot;&gt; &lt;li v-if=&quot;!loginInfo.id&quot; id=&quot;no-login&quot;&gt; &lt;a href=&quot;/login&quot;&gt; &lt;em class=&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;vam ml5&quot;&gt;登录&lt;/span&gt; &lt;/a&gt; | &lt;a href=&quot;/register&quot;&gt; &lt;span class=&quot;vam ml5&quot;&gt;注册&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--退出--&gt; &lt;li v-if=&quot;loginInfo.id&quot; id=&quot;is-login-two&quot; class=&quot;h-r-user&quot;&gt; &lt;a href=&quot;#&quot; title&gt; &lt;img :src=&quot;loginInfo.avatar&quot; width=&quot;30&quot; height=&quot;30&quot; class=&quot;vam picImg&quot; alt &gt; &lt;span id=&quot;userName&quot; class=&quot;vam disIb&quot;&gt;&#123;&#123; loginInfo.nickname &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; title=&quot;退出&quot; @click=&quot;logout()&quot; class=&quot;ml5&quot;&gt;退出&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 在 default.vue 当中引入 js-cookie sh 1import cookie from &#x27;js-cookie&#x27;; 修改 utils&#x2F;request.js axios 的封装方法修改内容如下 javascript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import axios from &#x27;axios&#x27;;import &#123;MessageBox, Message&#125; from &#x27;element-ui&#x27;;import cookie from &#x27;js-cookie&#x27;;const service = axios.create(&#123; baseURL: &#x27;http://localhost:9000&#x27;, // request timeout timeout: 50000&#125;);service.interceptors.response.use( response =&gt; &#123; const res = response.data; if (res.code !== 20000) &#123; Message(&#123; message: res.message || &#x27;Error&#x27;, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;); if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // to re-login MessageBox.confirm(&#x27;You have been logged out, you can cancel to stay on this page, or log in again&#x27;, &#x27;Confirm logout&#x27;, &#123; confirmButtonText: &#x27;Re-Login&#x27;, cancelButtonText: &#x27;Cancel&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; store.dispatch(&#x27;user/resetToken&#x27;).then(() =&gt; &#123; location.reload() &#125;); &#125;); &#125; return Promise.reject(new Error(res.message || &#x27;Error&#x27;)); &#125; else &#123; return res; &#125; &#125;, error =&gt; &#123; Message(&#123; message: error.message, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;); return Promise.reject(error); &#125;)service.interceptors.request.use( config =&gt; &#123; if (cookie.get(&#x27;login_token&#x27;)) &#123; config.headers[&#x27;token&#x27;] = cookie.get(&#x27;login_token&#x27;); &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);export default service; 51-门户登录-短信微服务创建短信微服务工程 添加配置文件application.yml yaml 123456789101112131415161718192021222324252627282930313233# application-dev.ymlserver: port: 8006logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-sms profiles: active: dev jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: nacos: discovery: server-addr: localhost:8848 redis: host: localhost port: 6379 database: 0 timeout: 1800000 # password: 1234 lettuce: pool: max-active: 20 max-wait: 1 # 最大阻塞等待时间 max-idle: 5 min-idle: 0 创建启动类 12345678910/** * @author BNTang * @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 取消数据源自动配置 */@ComponentScan(&#123;&quot;top.it6666&quot;&#125;)public class SmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SmsApplication.class, args); &#125;&#125; 发送短信签名 进入查看 API 的页面之后就有对应语言发送代码的 Demo 了如下 java 1234567891011121314151617181920212223public static void main(String[] args) &#123; DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;, &quot;LTAIqImmxZn7yCpS&quot;, &quot;pJ4OOiDnHYdZZZOkxlPN8HyXiaatZe&quot;); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setMethod(MethodType.POST); request.setDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setVersion(&quot;2017-05-25&quot;); request.setAction(&quot;SendSms&quot;); request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;); request.putQueryParameter(&quot;PhoneNumbers&quot;, &quot;1599767931&quot;); request.putQueryParameter(&quot;SignName&quot;, &quot;BNTang&quot;); request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_169111508&quot;); request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;code:910612&#125;&quot;); try &#123; CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); &#125; catch (ServerException e) &#123; e.printStackTrace(); &#125; catch (ClientException e) &#123; e.printStackTrace(); &#125;&#125; 添加依赖 xml 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 SmsController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @author BNTang **/@RestController@RequestMapping(&quot;/service_sms/api/sms&quot;)public class SmsController &#123; @Resource private SmsService smsService; /** * 发送完短信后, 把生成的验证码写到redis */ @Resource private RedisTemplate&lt;String, String&gt; redisTemplate; @GetMapping(value = &quot;/send/&#123;phone&#125;&quot;) public ResponseResult code(@PathVariable String phone) &#123; // 查看redis当中是否有当前手机对应的验证码 手机号当作key String code = redisTemplate.opsForValue().get(phone); if(!StringUtils.isEmpty(code)) &#123; // 已经发送过了 还没有过期 return ResponseResult.ok(); &#125; // 生成新的验证码 code = randomCode(); Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(1); // 把验证码写到参数当中去 param.put(&quot;code&quot;, code); // 发送短信 boolean isSend = smsService.send(phone, &quot;SMS_169111508&quot;, param); // 发送成功 if(isSend) &#123; // 把验证码写到Redis当中 redisTemplate.opsForValue().set(phone, code,5, TimeUnit.MINUTES); return ResponseResult.ok(); &#125; // 提示用户失败 return ResponseResult.error().message(&quot;发送短信失败&quot;); &#125; /** * 生成4位的数字验证码 * @return 验证码 */ public String randomCode()&#123; StringBuilder sb = new StringBuilder(); for (int i =0; i &lt; 4; i++) &#123; sb.append(new Random().nextInt(10)); &#125; return sb.toString(); &#125;&#125; 创建短信发送业务类，SmsService.java 12345678910111213/** * @author BNTang **/public interface SmsService &#123; /** * 发送短信 * @param phone 手机号 * @param sms sms模板 * @param param 参数 * @return 发送结果 */ boolean send(String phone, String sms, Map&lt;String, Object&gt; param);&#125; SmsServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536/** * @author BNTang **/@Servicepublic class SmsServiceImpl implements SmsService &#123; @Override public boolean send(String phoneNumbers, String templateCode, Map&lt;String, Object&gt; param) &#123; if(StringUtils.isEmpty(phoneNumbers)) &#123; return false; &#125; DefaultProfile profile = DefaultProfile.getProfile( &quot;cn-hangzhou&quot;, &quot;LTAI4GH19ep2P8caxW2E2N6A&quot;, &quot;NAmWiBmKXofw7hs4JRcx7SLhF1MN6P&quot;); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setMethod(MethodType.POST); request.setDomain(&quot;dysmsapi.aliyuncs.com&quot;); request.setVersion(&quot;2017-05-25&quot;); request.setAction(&quot;SendSms&quot;); request.putQueryParameter(&quot;PhoneNumbers&quot;, phoneNumbers); request.putQueryParameter(&quot;SignName&quot;, &quot;BNTang&quot;); request.putQueryParameter(&quot;TemplateCode&quot;, templateCode); request.putQueryParameter(&quot;TemplateParam&quot;, JSONObject.toJSONString(param)); try &#123; client.getCommonResponse(request); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 52-门户登录-用户微服务创建用户微服务 创建用户表sql 1234567891011121314CREATE TABLE `portal_user` ( `id` CHAR ( 19 ) NOT NULL COMMENT &#x27;用户id&#x27;, `openid` VARCHAR ( 128 ) DEFAULT NULL COMMENT &#x27;微信openid&#x27;, `mobile` VARCHAR ( 11 ) DEFAULT &#x27;&#x27; COMMENT &#x27;手机号&#x27;, `password` VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;密码&#x27;, `nickname` VARCHAR ( 50 ) DEFAULT NULL COMMENT &#x27;昵称&#x27;, `sex` TINYINT ( 2 ) UNSIGNED DEFAULT NULL COMMENT &#x27;性别 1 女，2 男&#x27;, `age` TINYINT ( 3 ) UNSIGNED DEFAULT NULL COMMENT &#x27;年龄&#x27;, `avatar` VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;用户头像&#x27;, `sign` VARCHAR ( 100 ) DEFAULT NULL COMMENT &#x27;用户签名&#x27;, `is_disabled` TINYINT ( 1 ) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;是否禁用 1（true）已禁用， 0（false）未禁用&#x27;, `is_deleted` TINYINT ( 1 ) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;,PRIMARY KEY ( `id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;用户表&#x27;; 使用代码生成器生成代码 java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class CodeGenerator &#123; @Test public void main() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // 配置输出路径 gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_user\\\\src\\\\main\\\\java&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); gc.setAuthor(&quot;BNTang&quot;); // 重新生成时文件是否覆盖 gc.setFileOverride(false); /* * mp生成service层代码，默认接口名称第一个字母有 I * */ gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_user&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;portal_user&quot;); // 数据库表映射到实体的命名策略 驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;portal_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 添加配置文件application.yml yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# application-dev.ymlserver: port: 8007logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-user profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: HikariPool redis: host: localhost port: 6379 database: 0 timeout: 1800000 # password: 1234 lettuce: pool: max-active: 20 max-wait: 1 # 最大阻塞等待时间 max-idle: 5 min-idle: 0 jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: nacos: discovery: server-addr: localhost:8848mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: top/it6666/service_user/mapper/xml/*.xmlfeign: sentinel: enabled: true 添加启动类 UserApplication.java 1234567891011/** * @author BNTang */@ComponentScan(&#123;&quot;top.it6666&quot;&#125;)@SpringBootApplication@MapperScan(&quot;top.it6666.service_user.mapper&quot;)public class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class, args); &#125;&#125; 创建 LoginVo 和 RegisterVo 用于数据封装 LoginVo.java 1234567891011121314/** * @author BNTang */@Datapublic class LoginVo &#123; /** * 手机号 */ private String phone; /** * 密码 */ private String password;&#125; RegisterVo.java 12345678910111213141516171819202122/** * @author BNTang */@Datapublic class RegisterVo &#123; /** * 昵称 */ private String nickname; /** * 手机号 */ private String phone; /** * 密码 */ private String password; /** * 验证码 */ private String code;&#125; 创建用户业务类 UserService.java 1234567891011121314151617181920212223242526/** * &lt;p&gt; * 用户表 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-05-22 */public interface UserService extends IService&lt;User&gt; &#123; /** * 登录 * * @param loginVo * 登录信息 * @return token */ String login(LoginVo loginVo); /** * 注册 * * @param registerVo * 注册信息 */ void register(RegisterVo registerVo);&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * &lt;p&gt; * 用户表 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-05-22 */@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; @Resource private RedisTemplate&lt;String, String&gt; redisTemplate; @Override public String login(LoginVo loginVo) &#123; String phone = loginVo.getPhone(); String password = loginVo.getPassword(); // 校验参数 if (StringUtils.isEmpty(phone) || StringUtils.isEmpty(password)) &#123; throw new BnTangException(20001, &quot;缺少参数&quot;); &#125; // 获取用户 User user = baseMapper.selectOne(new QueryWrapper&lt;User&gt;().eq(&quot;mobile&quot;, phone)); if (null == user) &#123; throw new BnTangException(20001, &quot;用户不存在&quot;); &#125; // 校验密码 if (!Md5.encrypt(password).equals(user.getPassword())) &#123; throw new BnTangException(20001, &quot;密码错误&quot;); &#125; // 校验是否被禁用 if (user.getIsDisabled()) &#123; throw new BnTangException(20001, &quot;用户被禁用&quot;); &#125; // 使用JWT生成token字符串 return JwtUtils.getJwtToken(user.getId(), user.getNickname()); &#125; @Override public void register(RegisterVo registerVo) &#123; // 获取注册信息，进行校验 String nickname = registerVo.getNickname(); String phone = registerVo.getPhone(); String password = registerVo.getPassword(); String code = registerVo.getCode(); // 校验参数 if (StringUtils.isEmpty(phone) || StringUtils.isEmpty(nickname) || StringUtils.isEmpty(password) || StringUtils.isEmpty(code)) &#123; throw new BnTangException(20001, &quot;缺少参数&quot;); &#125; // 校验校验验证码 // 从redis获取发送的验证码 if (!code.equals(redisTemplate.opsForValue().get(phone))) &#123; throw new BnTangException(20001, &quot;验证码错误&quot;); &#125; // 查询数据库中是否存在相同的手机号码 if (baseMapper.selectCount(new QueryWrapper&lt;User&gt;().eq(&quot;mobile&quot;, phone)) &gt; 0) &#123; throw new BnTangException(20001, &quot;手机号已被使用&quot;); &#125; // 添加注册信息到数据库 User member = new User(); member.setNickname(nickname); member.setMobile(registerVo.getPhone()); member.setPassword(Md5.encrypt(password)); member.setIsDisabled(false); member.setAvatar(&quot;https://xiaohuihuit.github.io/images/avatar.jpg&quot;); this.save(member); &#125;&#125; 创建用户请求 api 控制器 UserController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * &lt;p&gt; * 用户表 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-05-22 */@RestController@RequestMapping(&quot;/service_user/user&quot;)public class UserController &#123; @Resource private UserService userService; /** * 用户登录 */ @ApiOperation(value = &quot;用户登录&quot;) @PostMapping(&quot;/login&quot;) public ResponseResult login(@RequestBody LoginVo loginVo) &#123; String token = userService.login(loginVo); return ResponseResult.ok().data(&quot;token&quot;, token); &#125; /** * 用户注册 */ @ApiOperation(value = &quot;用户注册&quot;) @PostMapping(&quot;/register&quot;) public ResponseResult register(@RequestBody RegisterVo registerVo) &#123; userService.register(registerVo); return ResponseResult.ok(); &#125; /** * 获取用户登陆成功之后的用户信息 * */ @ApiOperation(value = &quot;获取用户登陆成功之后的用户信息&quot;) @GetMapping(&quot;auth/getLoginInfo&quot;) public ResponseResult getLoginInfo(HttpServletRequest request) &#123; try &#123; // 查询数据库根据用户id获取用户信息 return ResponseResult.ok().data(&quot;userInfo&quot;, userService.getById(JwtUtils.getUserIdByJwtToken(request))); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new BnTangException(20001, &quot;获取失败&quot;); &#125; &#125;&#125; 53-门户登录-微信登录OAuth2 开放授权什么是 OAuth2是开放授权的一个标准，旨在让用户允许第三方应用去访问该用户在某服务器中的特定私有的资源，而可以不提供其在某服务器的账号密码给到第三方应用。 运行流程名词说明 Third-party application：第三方应用程序, 又称 “客户端”（client）比如打开视频网站，使用第三方登录，选择微信登录，这时候视频网站就是客户端。 HTTP service：HTTP 服务提供商，简称 “服务提供商” 即微信。 Resource Owner：资源所有者，登录用户。 User Agent：用户代理，指浏览器, 手机。 Authorization server：认证服务器, 即服务提供商专门用来处理认证的服务器。 Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 运行流程图 交互过程 OAuth 在 “客户端” 与 “服务提供商” 之间，设置了一个授权层（authorization layer） “客户端” 不能直接登录 “服务提供商”，只能登录授权层，以此将用户与客户端区分开来。 “客户端” 登录授权层所用的令牌（token）与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 “客户端” 登录授权层以后，“服务提供商” 根据令牌的权限范围和有效期，向 “客户端” 开放用户储存的资料。 交互流程图 令牌的访问与刷新Access Token Access Token 是客户端访问资源服务器的令牌。拥有这个令牌代表着得到用户的授权。 这个授权应该是临时的，有一定的有效期。这是因为，Access Token 在使用的过程中可能会泄露。 给 Access Token 限定一个较短的有效期可以降低因 Access Token 泄露而带来的风险。 每当 Access Token 过期，客户端就必须重新向用户索要授权。这样用户可能每隔几天，甚至每天都需要进行授权操作。这是一件非常影响用户体验的事情。 Refresh Token Refresh Token 的作用是用来刷新 Access Token。认证服务器提供一个刷新接口，例如如下链接所示。 http://www.VX.com/refresh?refresh_token&#x3D;&amp;client_id&#x3D; 传入 refresh_token 和 client_id，认证服务器验证通过后，返回一个新的 Access Token。 为了安全，OAuth2.0 引入了两个措施 OAuth2.0 要求，Refresh Token 一定是保存在客户端的服务器上，而绝不能存放在狭义的客户端（例如 App、PC 端软件）上。调用 refresh 接口的时候，一定是从服务器到服务器的访问。 OAuth2.0 引入了 client_secret 机制 即每一个 client_id 都对应一个 client_secret。 这个 client_secret 会在客户端申请 client_id 时，随 client_id 一起分配给客户端。 客户端必须把 client_secret 妥善保管在服务器上，决不能泄露。 刷新 Access Token 时，需要验证这个 client_secret。 http://www.baidu.com/refresh?refresh_token=&amp;client_id=&amp;client_secret= Refresh Token 的有效期非常长，会在用户授权时，随 Access Token 一起重定向到回调 URL，传递给客户端。 授权模式客户端必须得到用户的授权（authorization grant）才能获得令牌（access token）OAuth 2.0 定义了四种授权方式。 简化模式简化模式，不推荐使用，简化模式适用于纯静态页面应用。所谓纯静态页面应用，也就是应用没有在服务器上执行代码的权限，只有前端 JS 代码的控制权。这种场景下，应用是没有持久化存储的能力的。因此，按照 OAuth2.0 的规定，这种应用是拿不到 Refresh Token 的。其整个授权流程如下。 该模式下，access_token 容易泄露且不可刷新。 授权码模式授权码模式适用于有自己的服务器的应用，它是一个一次性的临时凭证，用来换取 access_token 和 refresh_token。 https://www.baidu.com/exchange?code=&amp;client_id=&amp;client_secret= 需要传入 code、client_id 以及 client_secret。验证通过后，返回 access_token 和 refresh_token。一旦换取成功，code 立即作废，不能再使用第二次。 这个 code 的作用是保护 token 的安全性，在第 4 步当中直接把 token 返回给应用。而这一步容易被拦截、窃听。引入了 code 之后，即使攻击者能够窃取到 code，但是由于他无法获得应用保存在服务器的 client_secret，因此也无法通过 code 换取 token。第 5 步，为什么不容易被拦截、窃听呢？这是因为，首先，这是一个从服务器到服务器的访问，黑客比较难捕捉到；其次，这个请求通常要求是 HTTPS 的实现。即使能窃听到数据包也无法解析出内容。 密码模式密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向 “服务商提供” 索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分。 适用于同一公司内部的多个系统，不适用于不受信的第三方应用。 客户端模式如果信任关系再进一步，或者调用者是一个后端的模块，没有用户界面的时候，可以使用客户端模式。鉴权服务器直接对客户端进行身份验证，验证通过后，返回 token。 微信登录准备工作注册账号 注册地址：https://open.weixin.qq.com 注册微信开发平台账号 开发者资质认证准备营业执照，1-2 个工作日审批、300 元。 创建网站应用 提交审核，7 个工作日审批。 开发流程https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html 前端开发login.js 中添加验证登录请求，我记得之前的文章当中好像添加了，不过这里我还是列举出来，也把对应的代码放在下面。 javascript 1234567// 验证是否已经登录checkLogin() &#123; return request(&#123; url: `/service_user/user/wx/checkLogin`, method: &#x27;get&#x27;, &#125;);&#125; 在 login.vue 当中添加属性 javascript 12345head: &#123; script: [ &#123;src: &#x27;http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js&#x27;&#125; ]&#125;, javascript 1wxDialog: false 添加微信登录的对话框 12345678&lt;!--@opened 对话框打开后的回调--&gt;&lt;el-dialog :visible.sync=&quot;wxDialog&quot; @opened=&quot;wxOpen&quot; width=&quot;30%&quot; center&gt; &lt;div id=&quot;qrCode&quot; style=&quot;padding-left: 110px;&quot;&gt;&lt;/div&gt;&lt;/el-dialog&gt; 点击微信登录 html 1&lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; @click=&quot;wxDialog=true&quot;&gt; 弹框后在生成二维码 javascript 1234567891011121314151617181920212223242526272829wxCreate() &#123; let obj = new WxLogin(&#123; self_redirect: true, id: &quot;qrCode&quot;, appid: &quot;wx92b6693b8c01fc87&quot;, scope: &quot;snsapi_login&quot;, redirect_uri: &quot;http://www.sphskla.cn/service_user/user/wx/callBack&quot;, state: &quot;fm&quot;, style: &quot;black&quot;, href: &quot;&quot; &#125;);&#125;,wxOpen() &#123; // 生成登录二维码 this.wxCreate(); // 验证是否已经扫码 loginApi.checkLogin().then(response =&gt; &#123; if (response.success) &#123; // 携带token跳转到首页 this.$router.push(&#123;path: &#x27;/&#x27;, query: &#123;token: response.data.token&#125;&#125;); &#125; else &#123; this.$message(&#123; type: &#x27;error&#x27;, message: &quot;登录失败, 请重试&quot; &#125;); this.wxOpen(); &#125; &#125;);&#125; 登录成功跳转到首页后的处理修改 default.vue 如下 javascript 1234567891011121314151617created() &#123; // 获取token this.token = this.$route.query.token; // 判断路径是否有token值 if (this.token) &#123; // 存储token与user cookie.set(&#x27;login_token&#x27;, this.token, &#123;domain: &#x27;localhost&#x27;&#125;); cookie.set(&#x27;portal_user&#x27;, &#x27;&#x27;, &#123;domain: &#x27;localhost&#x27;&#125;); // 获取用户信息 loginApi.getLoginInfo().then(response =&gt; &#123; this.loginInfo = response.data.userInfo; cookie.set(&#x27;portal_user&#x27;, this.loginInfo, &#123;domain: &#x27;localhost&#x27;&#125;); &#125;); &#125; this.showInfo();&#125;, 后端开发在 service_user 工程当中添加配置 yaml 12345678wx: open: # 微信开放平台 openid app_id: wx92b6693b8c01fc87 # 微信开放平台 appsecret app_secret: d734ba63f66b7dsadscdcb958eea # 重定向url redirect_url: http://www.sphskla.cn/wechat/callBack 创建常量类 WxConstantUtil.java java 1234567891011121314151617181920212223242526272829/** * @author BNTang * @version 1.0 * @project video_parent * @description 微信相关常量工具类 * @since Created in 2021/5/28 028 21:24 **/@Componentpublic class WxConstantUtil implements InitializingBean &#123; @Value(&quot;$&#123;wx.open.app_id&#125;&quot;) private String appId; @Value(&quot;$&#123;wx.open.app_secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;) private String redirectUrl; public static String WX_OPEN_APP_ID; public static String WX_OPEN_APP_SECRET; public static String WX_OPEN_REDIRECT_URL; @Override public void afterPropertiesSet() &#123; WX_OPEN_APP_ID = appId; WX_OPEN_APP_SECRET = appSecret; WX_OPEN_REDIRECT_URL = redirectUrl; &#125;&#125; 添加 HTTP 请求的工具类 java 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author BNTang * @version 1.0 * @project video_parent * @description 发送 HTTP 请求工具类 * @since Created in 2021/5/28 028 21:39 **/public class HttpClientUtil &#123; /** * 发送get 网络请求 */ public static String get(String uri) &#123; CloseableHttpClient httpClient = null; HttpGet get = new HttpGet(uri); CloseableHttpResponse response = null; try &#123; httpClient = HttpClients.createDefault(); response = httpClient.execute(get); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200) &#123; HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity, &quot;UTF-8&quot;); &#125; else &#123; return null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != response) &#123; response.close(); &#125; if (null != httpClient) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125;&#125; 修改 UserService.java 添加新的用户业务方法 java 12345678/** * &lt;b&gt; 根据openId获取用户 &lt;/b&gt; * * @param openId * 微信openId * @return 通过openId获取的用户 */User getByOpenId(String openId); 修改 UserServiceImpl.java 实现该方法 java 123456@Overridepublic User getByOpenId(String openId) &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;openid&quot;, openId); return baseMapper.selectOne(queryWrapper);&#125; 如果想要在本地上调试微信扫描登录需要配置一下，因为微信回调的地址是在公网，我们需要配置一下 HOST 文件以及 nginx 的反向代理如下图所示 修改 HOST 有专门修改 HOST 文件的工具我这里没有列举出来 修改 C:\\Windows\\System32\\drivers\\etc\\host text 1127.0.0.1 www.sphskla.cn 修改 nginx.conf text 123location ~ /wx &#123; proxy_pass http://localhost:8007;&#125; 重启 nginx 然后在自行测试微信登录即可，重启命令如下 sh 1nginx.exe -s stop 在 Controller 当中创建 WxController java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * @author BNTang * @version 1.0 * @project video_parent * @description 微信请求控制器 * @since Created in 2021/5/29 029 8:27 **/@RestController@RequestMapping(&quot;/service_user/user/wx&quot;)@RequiredArgsConstructorpublic class WxController &#123; private final UserService userService; /** * 记录当前是否已经登录 */ private boolean isLogin; /** * 记录当前是否扫码登录失败 */ private boolean isLoginFail; /** * 当前登录用户token */ private String jwtToken; /** * &lt;b&gt;微信登录后端回调业务&lt;/b&gt; * * @param code * code * @param state * 站点状态 */ @RequestMapping(&quot;/callBack&quot;) public void callback(String code, String state) &#123; // 从redis中将state获取出来，和当前传入的state作比较 // 如果一致则放行，如果不一致则抛出异常：非法访问 try &#123; // 需修改为自己的app环境 String getToken = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot; + &quot;appid=%s&quot; + &quot;&amp;secret=%s&quot; + &quot;&amp;code=%s&quot; + &quot;&amp;grant_type=authorization_code&quot;; // 拼接请求地址 getToken = String.format(getToken, WxConstantUtil.WX_OPEN_APP_ID, WxConstantUtil.WX_OPEN_APP_SECRET, code); // 回调获得code，通过用户授权的code去获取微信令牌 Map&lt;String, Object&gt; map = JSON.parseObject(HttpClientUtil.get(getToken)); // 获取到了关键的令牌和openid后， // 就可以正式开始查询微信用户的信息，完成我们要做的微信绑定 String accessToken = (String)map.get(&quot;access_token&quot;); String openId = (String)map.get(&quot;openid&quot;); // 查询数据库当中有没有该用户 User user = userService.getByOpenId(openId); // 如果没有用户 if (null == user) &#123; String userInfo = &quot;&quot; + &quot;https://api.weixin.qq.com/sns/userinfo?&quot; + &quot;access_token=%s&quot; + &quot;&amp;openid=%s&quot;; userInfo = String.format(userInfo, accessToken, openId); // 获取微信用户信息 String wxUserInfo = HttpClientUtil.get(userInfo); // 解析用户json信息 Map&lt;String, Object&gt; info = JSON.parseObject(wxUserInfo); // 获取昵称与头像 String nickname = (String)info.get(&quot;nickname&quot;); String headImgUrl = (String)info.get(&quot;headimgurl&quot;); // 向数据库中插入一条记录 user = new User(); user.setNickname(nickname); user.setOpenid(openId); user.setAvatar(headImgUrl); // 保存用户信息 userService.save(user); &#125; // 使用jwt根据user对象生成token字符串 jwtToken = JwtUtils.getJwtToken(user.getId(), user.getNickname()); this.isLogin = true; &#125; catch (Exception e) &#123; this.isLoginFail = true; &#125; &#125; /** * &lt;b&gt;校验是否已经登录&lt;/b&gt; * * @return 校验结果 */ @GetMapping(&quot;/checkLogin&quot;) public ResponseResult checkLogin() &#123; ResponseResult result; int flag = 1; while (true) &#123; // 如果登录状态已经,登录,返回用户token if (this.isLogin) &#123; result = ResponseResult.ok().data(&quot;token&quot;, this.jwtToken); // 状态复位 isLogin = false; // 退出 break; &#125; // 扫描登录失败 返回错误信息 if (isLoginFail) &#123; result = ResponseResult.error(); &#125; try &#123; // 每500毫秒查询一下状态 Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 超时处理 if (flag &gt; 500) &#123; result = ResponseResult.error(); break; &#125; flag++; &#125; return result; &#125;&#125; 修改前端的 default.vue 导入 loginApi 如下图 javascript 1import loginApi from &quot;@/api/login&quot;; 54-作品展示与播放-作者列表与详情接口准备创建 author.js javascript 12345678910111213141516171819202122import request from &#x27;@/utils/request&#x27;;const api_name = &#x27;/service_video/author&#x27;;export default &#123; authorWebList(page, limit) &#123; return request(&#123; url: `$&#123;api_name&#125;/pageList/$&#123;page&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;); &#125;, // 获取作者的信息 个人信息与作品信息 getAuthorById(authorId) &#123; return request(&#123; url: `$&#123;api_name&#125;/getAuthorById/$&#123;authorId&#125;`, method: &#x27;get&#x27; &#125;); &#125;&#125; 后端服务修改 AuthorController.java java 12345678/** * &lt;b&gt; 根据作者ID查询作者信息以及作者的作品 &lt;/b&gt; */@GetMapping(value = &quot;getAuthorById/&#123;id&#125;&quot;)public ResponseResult getById(@PathVariable String id) &#123; return ResponseResult.ok().data(&quot;author&quot;, authorService.getById(id)).data(&quot;contentList&quot;, contentService.selectByAuthorId(id));&#125; 修改 ContentService.java java 12345678/** * &lt;b&gt; 根据作者id查询这个作者的作品列表 &lt;/b&gt; * * @param authorId * 作者ID * @return 作品 */List&lt;Content&gt; selectByAuthorId(String authorId); 修改 ContentServiceImpl.java java 12345678910@Overridepublic List&lt;Content&gt; selectByAuthorId(String authorId) &#123; QueryWrapper&lt;Content&gt; queryWrapper = new QueryWrapper&lt;Content&gt;(); queryWrapper.eq(&quot;author_id&quot;, authorId); // 按照最后更新时间倒序排列 queryWrapper.orderByDesc(&quot;gmt_modified&quot;); return baseMapper.selectList(queryWrapper);&#125; 列表展示在 pages 下创建 author 文件夹，在 author 文件夹下面创建两个 vue 组件页面如下图 两个页面的内容都是之前写过的，不在一一说明直接上代码了，里面就用到了一个新的内容就是异步加载如下图所示 _id.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;template&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;作者介绍&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;t-infor-wrap&quot;&gt; &lt;!-- 作者基本信息 --&gt; &lt;section class=&quot;fl t-infor-box c-desc-content&quot;&gt; &lt;div class=&quot;mt20 ml20&quot;&gt; &lt;section class=&quot;t-infor-pic&quot;&gt; &lt;img :src=&quot;author.avatar&quot;&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30&quot;&gt; &lt;span class=&quot;fsize24 c-333&quot;&gt; &#123;&#123; author.name &#125;&#125;&amp;nbsp; &#123;&#123; author.level === 1 ? &#x27;普通作者&#x27; : &#x27;特邀作者&#x27; &#125;&#125; &lt;/span&gt; &lt;/h3&gt; &lt;section class=&quot;mt10&quot;&gt; &lt;span class=&quot;t-tag-bg&quot;&gt;&#123;&#123; author.intro &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;t-infor-txt&quot;&gt; &lt;p class=&quot;mt20&quot;&gt;&#123;&#123; author.career &#125;&#125;&lt;/p&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;section class=&quot;mt30&quot;&gt; &lt;div&gt; &lt;header class=&quot;comm-title all-teacher-title c-course-content&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;作品信息&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-tab-title&quot;&gt; &lt;a href=&quot;javascript: void(0)&quot;&gt;&amp;nbsp;&lt;/a&gt; &lt;/section&gt; &lt;/header&gt; &lt;!-- 没有数据 --&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;contentList.length==0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot;&gt;该作品还未发布作品&lt;/span&gt; &lt;/section&gt; &lt;article class=&quot;comm-video-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;content in contentList&quot; :key=&quot;content.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;video-img&quot;&gt; &lt;img :src=&quot;content.cover&quot; class=&quot;img-responsive&quot;&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+content.id&quot; class=&quot;comm-btn c-btn-1&quot;&gt;播放&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+content.id&quot; class=&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123; content.title &#125;&#125;&lt;/a&gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-orange&quot; v-if=&quot;Number(content.price) === 0&quot;&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fr jgTag bg-orange&quot; v-else&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt; ￥&#123;&#123; content.price &#125;&#125;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.buyCount &#125;&#125; 人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; content.viewCount &#125;&#125; 人浏览&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import author from &quot;@/api/author&quot;;export default &#123; /* 接收参数：params内容为路由参数 * */ asyncData(&#123;params, error&#125;) &#123; return author.getAuthorById(params.id).then(response =&gt; &#123; return &#123; // 作者信息 author: response.data.author, // 作品列表 contentList: response.data.contentList &#125; &#125;); &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;template&gt; &lt;div id=&quot;videoList&quot; class=&quot;bg-fa of&quot;&gt; &lt;section class=&quot;container&quot; style=&quot;min-height: 600px;&quot;&gt; &lt;section class=&quot;c-sort-box unBr&quot;&gt; &lt;div&gt; &lt;!-- 列表展示 --&gt; &lt;article class=&quot;i-author-list&quot; style=&quot;padding-top: 50px;&quot;&gt; &lt;div class=&quot;yd-open-course-card open-course-card&quot; v-for=&quot;author in list&quot; :key=&quot;author.id&quot;&gt; &lt;a :href=&quot;&#x27;/author/&#x27;+author.id&quot; style=&quot;color: #7F828B;text-decoration:none;&quot;&gt; &lt;div class=&quot;yd-open-course-card_avatar&quot;&gt; &lt;img :src=&quot;author.avatar&quot; :alt=&quot;author.name&quot;&gt;&lt;/div&gt; &lt;div class=&quot;yd-open-course-card_content_teacher&quot;&gt; &lt;div class=&quot;yd-open-course-card_content_teacher_tag&quot;&gt;&#123;&#123; author.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&#123;&#123; author.intro &#125;&#125;&lt;/div&gt; &lt;span&gt;-------------------------&lt;/span&gt; &lt;div&gt;&#123;&#123; author.career &#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;!-- 没有数据 --&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;total==0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据...&lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- 分页 --&gt; &lt;el-pagination style=&quot;padding: 30px 0; text-align: center&quot; background :current-page=&quot;page&quot; :page-size=&quot;limit&quot; layout=&quot;total, prev, pager, next, jumper &quot; :total=&quot;total&quot; @current-change=&quot;getData&quot; /&gt; &lt;/section&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import author from &quot;@/api/author&quot;;export default &#123; asyncData(&#123;params, error&#125;) &#123; return author.authorWebList(1, 3).then(response =&gt; &#123; if (response.success === true) &#123; return &#123; // 作者信息 list: response.data.rows, // 作品列表 total: response.data.total &#125; &#125; &#125;); &#125;, data() &#123; // 定义变量与初始值 return &#123; // 数据列表 list: null, // 总记录数 total: 0, // 页码 page: 1, // 每页记录数 limit: 3 &#125; &#125;, methods: &#123; // 分页切换 page:当前页 getData(page = 1) &#123; // 调用api层获取数据库中的数据 this.page = page; author.authorWebList(this.page, this.limit).then(response =&gt; &#123; if (response.success === true) &#123; this.list = response.data.rows; this.total = response.data.total; &#125; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;::v-deep .el-pagination.is-background .el-pager li:not(.disabled).active &#123; background-color: orangered; color: #fff;&#125;.open-course-card &#123; width: 375px; margin-top: 5px; background: white;&#125;.yd-open-course-card_avatar &#123; float: left; width: 80px; height: 102px; margin-right: 20px;&#125;.yd-open-course-card_avatar img &#123; width: 100%; height: 100%; border-radius: 4px;&#125;.yd-open-course-card &#123; font-family: PingFang SC; padding: 12px; box-sizing: border-box; border: 1px solid rgba(153, 153, 153, 0.15); border-radius: 8px; height: 143px; min-width: 300px; max-width: 385px; cursor: pointer; float: left; margin-right: 5px;&#125;.yd-open-course-card_content_teacher_tag &#123; display: inline-block; height: 17px; font-weight: 600; font-size: 12px; line-height: 17px; color: #f4ad0b; background: rgba(244, 173, 11, 0.06); border: 0.5px solid rgba(244, 173, 11, 0.4); border-radius: 4px; padding: 2px 4px; margin-bottom: 10px;&#125;&lt;/style&gt; 修改前端创建 content.js javascript 12345678910111213141516171819202122232425import request from &#x27;@/utils/request&#x27;;export default &#123; getPageList(page, limit, searchObj) &#123; return request(&#123; url: `/service_video/content/getContentPageQuery/$&#123;page&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, data: searchObj &#125;); &#125;, // 查询所有分类的方法 getAllCategory() &#123; return request(&#123; url: &#x27;/service_video/category/getTreeCategory&#x27;, method: &#x27;get&#x27; &#125;); &#125;, // 根据作品id获取作品详情信息 geContentDetailById(contentId) &#123; return request(&#123; url: `/service_video/content/getContentDeatail/$&#123;contentId&#125;`, method: &#x27;get&#x27; &#125;); &#125;&#125; 在 pages 目录下的 video 文件夹下创建一个 _id.vue 组件如下图并且修改 index.vue 的内容, 修改内容如下 index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;/header&gt; &lt;section class=&quot;c-sort-box&quot;&gt; &lt;section class=&quot;c-s-dl&quot;&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;作品分类&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li v-for=&quot;(item,index) in oneCategoryList&quot; :key=&quot;index&quot; :class=&quot;&#123;active:oneIndex==index&#125;&quot;&gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchOne(item.id,index)&quot;&gt;&#123;&#123; item.title &#125;&#125; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li v-for=&quot;(item,index) in twoCategoryList&quot; :key=&quot;index&quot; :class=&quot;&#123;active:twoIndex==index&#125;&quot;&gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchTwo(item.id,index)&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;js-wrap&quot;&gt; &lt;section class=&quot;fr&quot;&gt; &lt;span class=&quot;c-ccc&quot;&gt; &lt;i class=&quot;c-master f-fM&quot;&gt;1&lt;/i&gt;/ &lt;i class=&quot;c-666 f-fM&quot;&gt;1&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;fl&quot;&gt; &lt;ol class=&quot;js-tap clearfix&quot;&gt; &lt;li :class=&quot;&#123;&#x27;current bg-orangered&#x27;:buyCountSort!=&#x27;&#x27;&#125;&quot;&gt; &lt;a title=&quot;销量&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchBuyCount()&quot;&gt;畅销 &lt;span :class=&quot;&#123;hide:buyCountSort==&#x27;&#x27;&#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;&#x27;current bg-orangered&#x27;:gmtCreateSort!=&#x27;&#x27;&#125;&quot;&gt; &lt;a title=&quot;最新&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchGmtCreate()&quot;&gt;最新 &lt;span :class=&quot;&#123;hide:gmtCreateSort==&#x27;&#x27;&#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;&#x27;current bg-orangered&#x27;:priceSort!=&#x27;&#x27;&#125;&quot;&gt; &lt;a title=&quot;价格&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchPrice()&quot;&gt;价格&amp;nbsp; &lt;span :class=&quot;&#123;hide:priceSort==&#x27;&#x27;&#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; &lt;div class=&quot;mt40&quot;&gt; &lt;!-- 无数据提示 开始 --&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;data.length == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据...&lt;/span&gt; &lt;/section&gt; &lt;article class=&quot;comm-video-list&quot; style=&quot;min-height: 450px;&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;item in data&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;video-img&quot;&gt; &lt;img :src=&quot;item.cover&quot; class=&quot;img-responsive&quot;&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+item.id&quot; class=&quot;comm-btn c-btn-1&quot;&gt;播放&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+item.id&quot; class=&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/a&gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-if=&quot;Number(item.price) === 0&quot;&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fr jgTag bg-orangered&quot; v-else&gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt; ￥&#123;&#123; item.price &#125;&#125;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; item.buyCount &#125;&#125; 人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; item.viewCount &#125;&#125; 人浏览&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;!-- 分页 --&gt; &lt;el-pagination style=&quot;padding: 30px 0; text-align: center&quot; background :current-page=&quot;page&quot; :page-size=&quot;limit&quot; layout=&quot;total, prev, pager, next, jumper &quot; :total=&quot;total&quot; @current-change=&quot;gotoPage&quot; /&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- 课程列表 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import content from &#x27;@/api/content&#x27;;export default &#123; data() &#123; // 定义变量与初始值 return &#123; // 数据列表 list: null, // 总记录数 total: 0, // 页码 page: 1, // 每页记录数 limit: 4, data: [], // 查询表单对象 searchObj: &#123;&#125;, // 一级分类列表 oneCategoryList: [], // 二级分类列表 twoCategoryList: [], // 记录一级选中状态角标 oneIndex: -1, // 记录二级选中状态角标 twoIndex: -1, // 畅销排序 buyCountSort: &quot;&quot;, // 日期排序 gmtCreateSort: &quot;&quot;, // 价格排序 priceSort: &quot;&quot; &#125; &#125;, // 加载数据(异步) async asyncData(&#123;params, error&#125;) &#123; let [request1Data, request2Data] = await Promise.all([ content.getPageList(1, 4, &#123;&#125;), content.getAllCategory() ]); return &#123; data: request1Data.data.rows, total: request1Data.data.total, oneCategoryList: request2Data.data.list, &#125; &#125;, methods: &#123; // 分页查询 gotoPage(page) &#123; this.page = page; content.getPageList(page, this.limit, this.searchObj).then(response =&gt; &#123; this.data = response.data.rows; this.total = response.data.total; &#125;); &#125;, // 点击某个一级分类，查询对应二级分类 searchOne(categoryParentId, index) &#123; // 把传递index值赋值给oneIndex,为了active样式生效 this.oneIndex = index; this.twoIndex = -1; this.searchObj.categoryId = &quot;&quot;; this.twoCategoryList = []; // 把一级分类点击id值，赋值给searchObj this.searchObj.categoryParentId = categoryParentId; // 点击某个一级分类进行条件查询; this.gotoPage(1); // 拿着点击一级分类id 和 所有一级分类id进行比较， // 如果id相同，从一级分类里面获取对应的二级分类 for (let i = 0; i &lt; this.oneCategoryList.length; i++) &#123; // 获取每个一级分类 let oneCategory = this.oneCategoryList[i]; // 比较id是否相同 if (categoryParentId === oneCategory.id) &#123; // 从一级分类里面获取对应的二级分类 this.twoCategoryList = oneCategory.children; &#125; &#125; &#125;, // 点击某个二级分类实现查询 searchTwo(categoryId, index) &#123; // 把index赋值,为了样式生效 this.twoIndex = index; // 把二级分类点击id值，赋值给searchObj this.searchObj.categoryId = categoryId; //点击某个二级分类进行条件查询 this.gotoPage(1); &#125;, // 根据销量排序 searchBuyCount() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &quot;1&quot;; this.gmtCreateSort = &quot;&quot;; this.priceSort = &quot;&quot;; // 把值赋值到searchObj this.searchObj.buyCountSort = this.buyCountSort; this.searchObj.gmtCreateSort = this.gmtCreateSort; this.searchObj.priceSort = this.priceSort; // 调用方法查询 this.gotoPage(1); &#125;, // 最新排序 searchGmtCreate() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &quot;&quot;; this.gmtCreateSort = &quot;1&quot;; this.priceSort = &quot;&quot;; // 把值赋值到searchObj this.searchObj.buyCountSort = this.buyCountSort; this.searchObj.gmtCreateSort = this.gmtCreateSort; this.searchObj.priceSort = this.priceSort; // 调用方法查询 this.gotoPage(1); &#125;, // 价格排序 searchPrice() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &quot;&quot;; this.gmtCreateSort = &quot;&quot;; this.priceSort = &quot;1&quot;; // 把值赋值到searchObj this.searchObj.buyCountSort = this.buyCountSort; this.searchObj.gmtCreateSort = this.gmtCreateSort; this.searchObj.priceSort = this.priceSort; // 调用方法查询 this.gotoPage(1); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/*如果需要修改 element-ui的样式前面需要加上如下前缀 ::v-deep*/::v-deep .el-pagination.is-background .el-pager li:not(.disabled).active &#123; background-color: orangered; color: #fff;&#125;.active &#123; background: orangered;&#125;.active a &#123; color: white;&#125;.active a:hover &#123; color: white;&#125;.hide &#123; display: none;&#125;.show &#123; display: block;&#125;&lt;/style&gt; 前面的章节当中已经讲解过了所以这里就直接上代码了, 如上是 index.vue 的内容 _id.vue 组件的内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;template&gt; &lt;div id=&quot;videoList&quot; class=&quot;bg-fa of&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;section class=&quot;path-wrap txtOf hLh30&quot;&gt; &lt;a href=&quot;#&quot; title class=&quot;c-999 fsize14&quot;&gt;首页&lt;/a&gt; \\ &lt;a href=&quot;/course&quot; title class=&quot;c-999 fsize14&quot;&gt;作品列表&lt;/a&gt; \\ &lt;span class=&quot;c-333 fsize14&quot;&gt;&#123;&#123; content.oneCategoryName &#125;&#125;&lt;/span&gt; \\ &lt;span class=&quot;c-333 fsize14&quot;&gt;&#123;&#123; content.twoCategoryName &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;div&gt; &lt;div class=&quot;content-box&quot;&gt; &lt;div class=&quot;fl&quot;&gt; &lt;img width=&quot;450&quot; height=&quot;250&quot; :src=&quot;content.cover&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;fl u-coursetitle&quot;&gt; &lt;h2&gt; &lt;span class=&quot;u-coursetitle_title&quot;&gt;&#123;&#123; content.title &#125;&#125;&lt;/span&gt; &lt;/h2&gt; &lt;div style=&quot;margin-top: 10px; &quot;&gt; &lt;div class=&quot;fl&quot;&gt;&#123;&#123; content.buyCount &#125;&#125;人学过&lt;/div&gt; &lt;div class=&quot;fl hot&quot;&gt; &lt;el-rate v-model=&quot;value&quot; disabled show-score text-color=&quot;#ff9900&quot; score-template=&quot;&#123;value&#125;&quot;&gt; &lt;/el-rate&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-if=&quot;Number(content.price) != 0&quot; style=&quot;font-size: 28px; margin-top: 30px;&quot;&gt; ¥ &#123;&#123; content.price &#125;&#125; &lt;/div&gt; &lt;div class=&quot;join&quot;&gt; &lt;a @click=&quot;createOrders&quot; class=&quot;learnbtn&quot; v-if=&quot;Number(content.price) != 0 &amp;&amp; isBuy == false&quot;&gt;&lt;span&gt;立即购买&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;j-do-trailer&quot; v-if=&quot;Number(content.price) === 0 || isBuy== true&quot;&gt;&lt;span&gt;立即学习&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mt20 c-infor-box&quot;&gt; &lt;article class=&quot;fl col-7&quot;&gt; &lt;section class=&quot;mr30&quot;&gt; &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt; &lt;el-tab-pane style=&quot;padding-left: 20px&quot; label=&quot;视频介绍&quot; name=&quot;first&quot;&gt; &lt;div&gt; &lt;h6 class=&quot;c-i-content c-infor-title&quot;&gt; &lt;span&gt;课程介绍&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;course-txt-body-wrap&quot;&gt; &lt;section class=&quot;course-txt-body&quot; style=&quot;padding: 20px;&quot;&gt; &lt;div v-html=&quot;content.description&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;视频目录&quot; name=&quot;second&quot;&gt; &lt;div&gt; &lt;div class=&quot;f-cb&quot;&gt; &lt;h2 class=&quot;u-ctit f-thide f-fl&quot;&gt;目录&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;m-chapterList f-pr&quot;&gt; &lt;div class=&quot;chapter&quot; v-for=&quot;(chapter,index) in chapterList&quot; :key=&quot;chapter.id&quot;&gt; &lt;div class=&quot;chapterhead&quot;&gt; &lt;span class=&quot;f-fl f-thide chaptertitle&quot;&gt;章节&#123;&#123; index + 1 &#125;&#125;:&lt;/span&gt; &lt;span class=&quot;f-fl f-thide chaptername&quot;&gt;&#123;&#123; chapter.title &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;section&quot; v-for=&quot;(video,i) in chapter.children&quot; :key=&quot;video.id&quot;&gt; &lt;!-- &lt;a :href=&quot;&#x27;/player/&#x27;+video.videoSourceId+&#x27;_&#x27;+contentId&quot; &gt; --&gt; &lt;a @click=&quot;playClick(video.videoSourceId+&#x27;_&#x27;+contentId,video.isFree,$event)&quot;&gt; &lt;span class=&quot;f-fl f-thide ks&quot;&gt;小节&#123;&#123; i + 1 &#125;&#125;&lt;/span&gt;&lt;span class=&quot;f-fl type-title&quot;&gt;视频&lt;/span&gt; &lt;span class=&quot;f-fl f-thide ksname&quot;&gt;&#123;&#123; video.title &#125;&#125;&lt;/span&gt; &lt;a class=&quot;f-fr ksjbtn j-hovershow&quot; style=&quot;display: none;&quot;&gt; &lt;span class=&quot;f-fr&quot; v-if=&quot;video.isFree === true&quot;&gt;可试看&lt;/span&gt; &lt;div class=&quot;f-fr ksjicon-look&quot;&gt;&lt;/div&gt; &lt;/a&gt; &lt;span class=&quot;f-fr ksinfo j-hoverhide&quot; style=&quot;display: block;&quot;&gt; &lt;span class=&quot;f-fr f-thide kstime&quot;&gt;&#123;&#123; video.duration &#125;&#125;&lt;/span&gt; &lt;span class=&quot;f-fr ksinfoicon ksinfoicon-2&quot; title=&quot;视频&quot;&gt;&lt;/span&gt; &lt;span class=&quot;f-fr canPreview&quot; v-if=&quot;video.isFree === true&quot;&gt;可试看&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/section&gt; &lt;/article&gt; &lt;aside class=&quot;fl col-3&quot;&gt; &lt;div class=&quot;i-box&quot;&gt; &lt;div&gt; &lt;section class=&quot;c-infor-tabTitle c-tab-title&quot;&gt; &lt;a title href=&quot;javascript:void(0)&quot;&gt;作者&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;stud-act-list&quot;&gt; &lt;ul style=&quot;height: auto;&quot;&gt; &lt;li&gt; &lt;div class=&quot;u-face&quot;&gt; &lt;a :href=&quot;&#x27;/author/&#x27;+content.authorId&quot;&gt; &lt;img :src=&quot;content.avatar&quot; width=&quot;50&quot; height=&quot;50&quot; alt&gt; &lt;/a&gt; &lt;/div&gt; &lt;section class=&quot;hLh30 txtOf&quot;&gt; &lt;a class=&quot;c-333 fsize16 fl&quot; href=&quot;#&quot;&gt;&#123;&#123; content.authorName &#125;&#125;&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;hLh20 txtOf&quot;&gt; &lt;span class=&quot;c-999&quot;&gt;&#123;&#123; content.intro &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import content from &quot;@/api/content&quot;;import order from &quot;@/api/order&quot;;import cookie from &#x27;js-cookie&#x27;;export default &#123; async asyncData(app) &#123; //在nuxt中如果没有做任何处理, 是不能直接获取到cookie node.js let content_id = app.params.id; return content.geContentDetailById(content_id, app).then(response =&gt; &#123; return &#123; contentId: content_id, content: response.data.content, chapterList: response.data.chapterVoList, isBuy: response.data.isBuyContent &#125; &#125;); &#125;, data() &#123; return &#123; content: &#x27;&#x27;, chapterList: &#x27;&#x27;, contentId: &#x27;&#x27;, activeName: &#x27;second&#x27;, value: 4.5, isBuy: false &#125;; &#125;, methods: &#123; playClick(videoId, isFree, e) &#123; if (isFree) &#123; // nuxt 中 使用到了jquery $(e.currentTarget).attr(&#x27;href&#x27;, &#x27;/player/&#x27; + videoId); $(e.currentTarget).trigger(&#x27;click&#x27;); &#125; else &#123; // 有没有登录 if (this.isLogin()) &#123; if (this.isBuy) &#123; $(e.currentTarget).attr(&#x27;href&#x27;, &#x27;/player/&#x27; + videoId); $(e.currentTarget).trigger(&#x27;click&#x27;); &#125; else &#123; this.$message.warning(&quot;购买后才能观看&quot;); &#125; &#125; else &#123; this.$message.warning(&quot;请先登录...&quot;); &#125; &#125; &#125;, handleClick(tab, event) &#123; this.activeName = tab.paneName; &#125;, // 生成订单 createOrders() &#123; if (this.isLogin()) &#123; order.createOrders(this.contentId) .then(response =&gt; &#123; // 获取返回订单号 // 生成订单之后，跳转订单显示页面 this.$router.push(&#123;path: &#x27;/order/&#x27; + response.data.orderId&#125;); &#125;) &#125; else &#123; this.$message.warning(&quot;请先登录...&quot;); return; &#125; &#125;, isLogin() &#123; let user = cookie.get(&#x27;portal_user&#x27;, &#123;domain: &#x27;localhost&#x27;&#125;); if (user) &#123; return true; &#125; else &#123; false; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&gt;&gt;&gt; .el-tabs__nav-scroll &#123; background: white; height: 40px;&#125;&gt;&gt;&gt; .el-tabs__nav:first-child &#123; margin-left: 15px;&#125;&gt;&gt;&gt; .el-tab-pane &#123; background: white; border: 1px solid #f0f0f0;&#125;&gt;&gt;&gt; .el-tab-pane:first-child &#123; padding-top: 20px;&#125;&gt;&gt;&gt; .el-rate__icon &#123; margin-right: -2px;&#125;&lt;/style&gt; 55-作品展示与播放-作品详情页后端创建 VO ContentWebVO.java java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/6/5 005 8:49 **/@Datapublic class ContentWebVO &#123; private String id; /** * 作品标题 */ private String title; /** * 销售价格 */ private BigDecimal price; /** * 合辑视频图 */ private Integer contentNum; /** * 封面图片路径 */ private String cover; /** * 销售数量 */ private Long buyCount; /** * 浏览数量 */ private Long viewCount; /** * 作品简介 */ private String description; /** * 作者ID */ private String authorId; /** * 作者姓名 */ private String authorName; /** * 作者简介 */ private String intro; /** * 作者头像 */ private String avatar; /** * 作品一级分类ID */ private String oneCategoryId; /** * 一级类别名称 */ private String oneCategoryName; /** * 二级分类ID */ private String twoCategoryId; /** * 二级分类名称 */ private String twoCategoryName;&#125; 接口准备修改 ContentController.java java 123456789101112/** * 根据作品id获取作品详情信息 */@ApiOperation(value = &quot;根据作品id获取作品详情信息&quot;)@GetMapping(&quot;/getContentDeatail/&#123;contentId&#125;&quot;)public ResponseResult getById(@PathVariable String contentId, HttpServletRequest request) &#123; // 查询作品信息和作者信息 ContentWebVO contentWebVo = contentService.selectContentDetailById(contentId); // 查询当前作品的章节信息 List&lt;ChapterVO&gt; chapterVoList = chapterService.getChapterContentVideo(contentId); return ResponseResult.ok().data(&quot;content&quot;, contentWebVo).data(&quot;chapterVoList&quot;, chapterVoList);&#125; 修改 ContentService.java java 12345678910111213141516/** * 获取作品信息 * * @param contentId * 作品Id * @return 作品信息 */ContentWebVO selectContentDetailById(String contentId);/** * 更新作品浏览数 * * @param id * 作品ID */void updatePageViewCount(String id); 修改 ContentServiceImpl.java java 123456789101112131415@Overridepublic ContentWebVO selectContentDetailById(String contentId) &#123; this.updatePageViewCount(contentId); return baseMapper.getContentDetailById(contentId);&#125;/** * 更新播放信息 */@Overridepublic void updatePageViewCount(String id) &#123; Content content = baseMapper.selectById(id); content.setViewCount(content.getViewCount() + 1); baseMapper.updateById(content);&#125; 修改 ContentMapper.java java 12345678/** * 获取作品信息 * * @param contentId * 作品ID * @return 作品信息 */ContentWebVO getContentDetailById(String contentId); 修改 ContentMapper.xml xml 12345678910111213141516171819202122232425&lt;select id=&quot;getContentDetailById&quot; resultType=&quot;top.it6666.common_utils.entity.ContentWebVO&quot;&gt; SELECT c.id, c.title, c.cover, CONVERT(c.price, DECIMAL(8, 2)) AS price, c.content_num AS contentNum, c.cover, c.buy_count AS buyCount, c.view_count AS viewCount, cd.description, t.id AS authorId, t.name AS authorName, t.intro, t.avatar, s1.id AS oneCategoryId, s1.title AS oneCategoryName, s2.id AS twoCategoryId, s2.title AS twoCategoryName FROM video_content c LEFT JOIN video_content_description cd ON c.id = cd.id LEFT JOIN video_author t ON c.author_id = t.id LEFT JOIN video_category s1 ON c.category_parent_id = s1.id LEFT JOIN video_category s2 ON c.category_id = s2.id WHERE c.id = #&#123;contentId&#125;&lt;/select&gt; 然后在紧接着修改 ChapterService.java java 12345678/** * 查询当前作品的章节信息 * * @param contentId * 作品ID * @return 章节信息 */List&lt;ChapterVO&gt; getChapterContentVideo(String contentId); 修改 ChapterServiceImpl.java java 123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic List&lt;ChapterVO&gt; getChapterContentVideo(String contentId) &#123; // 1.根据作品的id查询所有的作品章节 QueryWrapper&lt;Chapter&gt; chapterQueryWrapper = new QueryWrapper&lt;&gt;(); chapterQueryWrapper.eq(&quot;content_id&quot;, contentId); List&lt;Chapter&gt; chapterList = baseMapper.selectList(chapterQueryWrapper); // 2.根据作品的id查询所有的作品小节 QueryWrapper&lt;ContentVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;content_id&quot;, contentId); List&lt;ContentVideo&gt; contentVideoList = contentVideoService.list(queryWrapper); // 3.封装数据 List&lt;ChapterVO&gt; resList = new ArrayList&lt;&gt;(); // 遍历所有的章节信息 chapterList.forEach(chapter -&gt; &#123; // 把章节信息转成ChapterVO ChapterVO chapterVO = new ChapterVO(); BeanUtils.copyProperties(chapter, chapterVO); // chapterVO封装小节数据 List&lt;ContentVideoVO&gt; children = new ArrayList&lt;&gt;(); contentVideoList.forEach(contentVideo -&gt; &#123; if (contentVideo.getChapterId().equals(chapter.getId())) &#123; // 是当前章节的小节 ContentVideoVO contentVideoVO = new ContentVideoVO(); BeanUtils.copyProperties(contentVideo, contentVideoVO); children.add(contentVideoVO); &#125; &#125;); chapterVO.setChildren(children); resList.add(chapterVO); &#125;); return resList;&#125; 如上后端的内容已经写完了接下来看看前端, 如下图中的链接跳转在上一节的文章当中已经完成了所以在这里只是为了理逻辑, 列表页点击跳转到作品详情页, 是如下的位置进行跳转的 前端的内容其实我们在上一节当中已经写完了这里是只来说一下 video 文件夹下的 _id.vue 里面的结构只要分为那几块 分类信息 作品信息 作者信息 目录信息 56-作品展示与播放-播放器页面后端在返回页面当中, 要有 video_source_id, 修改 ContentVideoVO.java java 123456789/** * 视频sourcedId */private String videoSourceId;/** * 期间 */private Float duration; 新增根据视频 id 获取视频凭证 api 如下图修改 service_vod 微服务 java 123456789101112131415161718192021222324/** * 根据视频id获取视频凭证 */@ApiOperation(value = &quot;根据视频id获取视频凭证&quot;)@GetMapping(&quot;getPlayAuth/&#123;id&#125;&quot;)public ResponseResult getPlayAuth(@PathVariable String id) &#123; try &#123; // 创建初始化对象 DefaultAcsClient client = ALiYunVodSdkUtils.initVodClient(VodConstant.ACCESS_KEY_ID, VodConstant.ACCESS_KEY_SECRET); // 创建获取凭证request和response对象 GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); // 向request设置视频id request.setVideoId(id); // 调用方法得到凭证 GetVideoPlayAuthResponse response = client.getAcsResponse(request); return ResponseResult.ok().data(&quot;playAuth&quot;, response.getPlayAuth()); &#125; catch (Exception e) &#123; throw new BnTangException(20001, &quot;获取凭证失败&quot;); &#125;&#125; 修改前端创建 vod.js javascript 1234567891011import request from &#x27;@/utils/request&#x27;;export default &#123; // 请求播放凭证 getPlayAuth(vid) &#123; return request(&#123; url: `/service_vod/vod/getPlayAuth/$&#123;vid&#125;`, method: &#x27;get&#x27; &#125;); &#125;&#125; 在 layout 当中创建 video 布局页面 创建 video.vue 123456789101112&lt;template&gt; &lt;div class=&quot;video_body&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;nuxt/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在 pages 当中创建 player 文件夹在当中创建 _vid.vue 页面内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;template&gt; &lt;div&gt; &lt;!-- 阿里云视频播放器样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css&quot;&gt; &lt;!-- 阿里云视频播放器脚本 --&gt; &lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js&quot;/&gt; &lt;!-- 播放器页面布局 --&gt; &lt;div class=&quot;video_content&quot;&gt; &lt;!-- 左侧播放器 --&gt; &lt;div class=&quot;back_button&quot;&gt; &lt;!-- 视频上方返回链接 --&gt; &lt;a :href=&quot;&#x27;/video/&#x27;+contentId&quot;&gt; &lt;i class=&quot;el-icon-back&quot; style=&quot;font-size: 25px; color: white; position: absolute; left: 12px; top: 28px;&quot;/&gt;| &lt;span&gt;&#123;&#123; content.title &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 播放器信息 --&gt; &lt;div id=&quot;J_prismPlayer&quot; class=&quot;prism-player&quot;/&gt; &lt;/div&gt; &lt;!-- 右侧目录 --&gt; &lt;div class=&quot;catalogue&quot;&gt; &lt;!-- 顶部作品信息 --&gt; &lt;div class=&quot;videoPlay_right_top&quot;&gt; &lt;img :src=&quot;content.cover&quot;&gt; &lt;span&gt; &lt;p class=&quot;dan&quot;&gt;&#123;&#123; content.title &#125;&#125;&lt;/p&gt; &lt;span style=&quot;color:white&quot;&gt;购买人数：&lt;/span&gt; &lt;i class=&quot;pinfen_num&quot;&gt;&#123;&#123; content.buyCount &#125;&#125;&lt;/i&gt; &lt;/span&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;m-chapterList&quot;&gt; &lt;div v-for=&quot;(chapter,index) in chapterList&quot; :key=&quot;chapter.id&quot;&gt; &lt;div class=&quot;chapter&quot;&gt; &lt;span class=&quot;f-fl ch&quot;&gt;章节&lt;/span&gt; &lt;span class=&quot;f-fl f-thide chaptericon&quot;&gt;&lt;span&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;f-fl f-thide chaptername&quot;&gt;&#123;&#123; chapter.title &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;section&quot; :class=&quot;video.videoSourceId == vid?&#x27;video_active&#x27;:&#x27;&#x27;&quot; v-for=&quot;video in chapter.children&quot; :key=&quot;video.id&quot; @click=&quot;videoClick(video.videoSourceId,video.isFree)&quot;&gt; &lt;span class=&quot;f-fl f-thide ks&quot; style=&quot;color: rgb(153, 153, 153);&quot;&gt;&amp;nbsp;&lt;/span&gt; &lt;span class=&quot;f-fl ksw&quot; style=&quot;background: rgb(245, 247, 250);&quot;&gt; &lt;span class=&quot;u-clicon ksicon ksicon-20&quot; title=&quot;进行中&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;f-fl ksname&quot; style=&quot;color: rgb(153, 153, 153);&quot;&gt;&#123;&#123; video.title &#125;&#125;&lt;/span&gt; &lt;span class=&quot;f-fr ksinfo&quot;&gt;&lt;span class=&quot;f-fr ksinfoicon ksinfoicon-2&quot; title=&quot;视频&quot;&gt;&lt;/span&gt; &lt;span class=&quot;f-fr kstime&quot;&gt;&#123;&#123; video.duration &#125;&#125;&lt;/span&gt;&lt;span class=&quot;f-fr flag flag-10&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vod from &#x27;@/api/vod&#x27;import content from &quot;@/api/content&quot;;import &quot;~/assets/css/video.css&quot;;export default &#123; // 应用video布局 layout: &#x27;video&#x27;, async asyncData(&#123;params, error&#125;) &#123; // 传入了两个参数,使用_分隔 拆分参数 let arr = params.vid.split(&quot;_&quot;); let vid = arr[0]; let contentId = arr[1]; let [request1Data, request2Data] = await Promise.all([ vod.getPlayAuth(vid), content.geContentDetailById(contentId) ]); return &#123; vid: vid, playAuth: request1Data.data.playAuth, content: request2Data.data.content, chapterList: request2Data.data.chapterVoList &#125; &#125;, data() &#123; return &#123; vid: &#x27;&#x27;, contentId: &#x27;&#x27;, aliPlayer: &#x27;&#x27; &#125; &#125;, methods: &#123; videoClick(vid) &#123; this.vid = vid; vod.getPlayAuth(vid).then(response =&gt; &#123; this.playAuth = response.data.playAuth; this.aliPlayer.replayByVidAndPlayAuth(vid, this.playAuth); &#125;); &#125; &#125;, mounted() &#123; // 页面渲染之后 created this.aliPlayer = new Aliplayer(&#123; id: &#x27;J_prismPlayer&#x27;, // 视频id vid: this.vid, // 播放凭证 playauth: this.playAuth, // 如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项 encryptType: &#x27;1&#x27;, width: &#x27;1500px&#x27;, height: &#x27;815px&#x27;, // 以下可选设置 清晰度排序 qualitySort: &#x27;asc&#x27;, // 返回音频还是视频 mediaType: &#x27;video&#x27;, // 自动播放 autoplay: false, // 直播 isLive: false, // 循环播放 rePlay: false, preload: true, // 控制条的显示方式：鼠标悬停 controlBarVisibility: &#x27;hover&#x27;, // 播放器类型：html5 useH5Prism: true, &#125;, function (player) &#123; console.log(&#x27;播放器创建成功&#x27;); &#125;); &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 安装 jquery在当前项目中的命令行窗口中输入如下指令进行安装 sh 1npm install jquery 安装好了还需要配置一下配置方式如下所示 javascript 1const webpack = require(&#x27;webpack&#x27;); javascript 12345plugins: [ new webpack.ProvidePlugin(&#123; &#x27;$&#x27; : &#x27;jquery&#x27; &#125;)] 跳转到播放器页面, 如上安装 jquery 主要是为了在跳转的时候添加一些逻辑不单单只是跳转, 还可能是有一些登录 ,支付的校验等等所以就没有使用跳转标签来跳转了 57-支付操作-准备工作创建数据库表订单表12345678910111213141516171819CREATE TABLE `pay_order` ( `id` CHAR ( 19 ) NOT NULL DEFAULT &#x27;主键&#x27;, `order_no` VARCHAR ( 20 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;订单号&#x27;, `content_id` VARCHAR ( 19 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;作品id&#x27;, `content_title` VARCHAR ( 100 ) DEFAULT NULL COMMENT &#x27;作品名称&#x27;, `content_cover` VARCHAR ( 255 ) DEFAULT NULL COMMENT &#x27;作品封面&#x27;, `author_name` VARCHAR ( 20 ) DEFAULT NULL COMMENT &#x27;作者名称&#x27;, `user_id` VARCHAR ( 19 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户id&#x27;, `nickname` VARCHAR ( 50 ) DEFAULT NULL COMMENT &#x27;用户昵称&#x27;, `mobile` VARCHAR ( 11 ) DEFAULT NULL COMMENT &#x27;用户手机&#x27;, `total_fee` DECIMAL ( 10, 2 ) DEFAULT &#x27;0.01&#x27; COMMENT &#x27;订单金额（分）&#x27;, `pay_type` TINYINT ( 3 ) DEFAULT NULL COMMENT &#x27;支付类型（1：微信 2：支付宝）&#x27;, `status` TINYINT ( 3 ) DEFAULT NULL COMMENT &#x27;订单状态（0：未支付 1：已支付）&#x27;, `is_deleted` TINYINT ( 1 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, PRIMARY KEY ( `id` ), UNIQUE KEY `ux_order_no` ( `order_no` ), KEY `idx_content_id` ( `content_id` ),KEY `idx_user_id` ( `user_id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;订单&#x27;; 支付日志表12345678910111213CREATE TABLE `pay_log` ( `id` CHAR ( 19 ) NOT NULL DEFAULT &#x27;主键&#x27;, `order_no` VARCHAR ( 20 ) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;订单号&#x27;, `pay_time` datetime DEFAULT NULL COMMENT &#x27;支付完成时间&#x27;, `total_fee` DECIMAL ( 10, 2 ) DEFAULT &#x27;0.01&#x27; COMMENT &#x27;支付金额（分）&#x27;, `transaction_id` VARCHAR ( 30 ) DEFAULT NULL COMMENT &#x27;交易流水号&#x27;, `trade_state` CHAR ( 20 ) DEFAULT NULL COMMENT &#x27;交易状态&#x27;, `pay_type` TINYINT ( 3 ) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;支付类型（1：微信 2：支付宝）&#x27;, `attr` text COMMENT &#x27;其他属性&#x27;, `is_deleted` TINYINT ( 1 ) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;逻辑删除 1（true）已删除， 0（false）未删除&#x27;, PRIMARY KEY ( `id` ),UNIQUE KEY `uk_order_no` ( `order_no` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4 COMMENT = &#x27;支付日志表&#x27;; 创建支付微服务生成相关代码创建 service_pay 支付微服务 代码生成器 java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class CodeGenerator &#123; @Test public void main() &#123; // 1、创建代码生成器 AutoGenerator autoGenerator = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // 配置输出路径 gc.setOutputDir(&quot;D:\\\\Develop\\\\IdeaPro\\\\video_parent\\\\service\\\\service_pay\\\\src\\\\main\\\\java&quot;); gc.setAuthor(&quot;BNTang&quot;); // 生成后是否打开资源管理器 gc.setOpen(false); // 重新生成时文件是否覆盖 gc.setFileOverride(false); // mp生成service层代码，默认接口名称第一个字母有 I gc.setControllerName(&quot;%sController&quot;); gc.setServiceName(&quot;%sService&quot;); gc.setServiceImplName(&quot;%sServiceImpl&quot;); gc.setMapperName(&quot;%sMapper&quot;); gc.setXmlName(&quot;%sMapper&quot;); // 主键策略 gc.setIdType(IdType.ID_WORKER_STR); // 定义生成的实体类中日期类型 gc.setDateType(DateType.ONLY_DATE); // 开启Swagger2模式 gc.setSwagger2(true); autoGenerator.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;root&quot;); dsc.setDbType(DbType.MYSQL); autoGenerator.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); // 模块名 pc.setModuleName(&quot;service_pay&quot;); pc.setParent(&quot;top.it6666&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); autoGenerator.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;pay_log&quot;, &quot;pay_order&quot;); // 数据库表映射到实体的命名策略 驼峰命名 strategy.setNaming(NamingStrategy.underline_to_camel); // 生成实体时去掉表前缀 strategy.setTablePrefix(&quot;_&quot;); // 数据库表字段映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setEntityLombokModel(true); // restful api风格控制器 strategy.setRestControllerStyle(true); // url中驼峰转连字符 strategy.setControllerMappingHyphenStyle(true); autoGenerator.setStrategy(strategy); // 6、执行 autoGenerator.execute(); &#125;&#125; 修改 service_pay 微服务当中的 pom.xml 添加 pom 依赖 xml 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alipay --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.11.8.ALL&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 紧接着添加启动类 java 12345678910111213/** * @author BNTang */@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;top.it6666&quot;&#125;)@MapperScan(&quot;top.it6666.service_pay.mapper&quot;)@EnableDiscoveryClient@EnableFeignClientspublic class PayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PayApplication.class, args); &#125;&#125; 创建 application.yml yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445server: port: 8008logging: pattern: console: &quot;%clr(%5p) %clr(-)&#123;faint&#125; %clr(%-80.80logger&#123;79&#125;)&#123;cyan&#125; %clr(:) %m%n&quot;spring: application: name: service-pay profiles: active: dev datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/video_db?serverTimezone=GMT%2B8 username: root password: root hikari: connection-test-query: SELECT 1 connection-timeout: 60000 idle-timeout: 500000 max-lifetime: 540000 maximum-pool-size: 12 minimum-idle: 10 pool-name: HikariPool jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8088mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: top/it6666/service_pay/mapper/xml/*.xmlfeign: sentinel: enabled: true 修改 gateway 添加我们刚创建的支付模块的服务转发规则如下图 yaml 1234- id: service-pay uri: lb://service-pay predicates: - Path=/service_pay/** 58-支付操作-订单接口远程数据准备在 service_video 工程 ContentController 当中创建根据 作品id 获取作品信息的请求 java 123456789/** * 根据作品id查询作品信息 */@ApiOperation(value = &quot;根据作品id查询作品信息&quot;)@PostMapping(&quot;/getContentInfoOrder/&#123;contentId&#125;&quot;)public ContentWebVO getContentInfoOrder(@PathVariable String contentId) &#123; // 查询作品信息和作者信息 return contentService.selectContentDetailById(contentId);&#125; 在 service_user 工程 UserController 当中创建根据 用户id 获取用户信息的请求 java 12345678/** * 根据用户id获取用户信息 */@ApiOperation(value = &quot;根据用户id获取用户信息&quot;)@PostMapping(&quot;/getUserInfoOrderById/&#123;userId&#125;&quot;)public User getUserInfoOrderById(@PathVariable String userId) &#123; return userService.getById(userId);&#125; 在 service_pay 工程当中创建 FeignClient 远程调用接口 创建 ContentClient.java 接口 java 1234567891011121314151617181920/** * @author BNTang * @version 1.0 * @project video_parent * @description 作品内容远程调用Feign客户端 * @since Created in 2021/6/6 006 8:59 **/@Component@FeignClient(name = &quot;service-video&quot;)public interface ContentClient &#123; /** * 根据作品id查询课程信息 * * @param contentId * 作品Id * @return 课程信息 */ @PostMapping(&quot;/service_video/content/getContentInfoOrder/&#123;contentId&#125;&quot;) ContentWebVO getContentInfoOrder(@PathVariable(&quot;contentId&quot;) String contentId);&#125; 在创建第二个 Feign 调用客户端的时候发现需要使用到 service_user 微服务当中的一个 User.java 实体类, 将 User.java 实体类抽取到 common_utils 工程当中去如下图 移动 mybatis-plus 的依赖原本是在 common_base 当中移动到父工程当中也就是 common 的 pom.xml 当中如下图 xml 12345&lt;!--mybatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 如上的步骤完成了之后我们就可以创建 UserClient.java 接口了内容如下放置的位置和上图中的那个 Feign 位置是一样的 java 1234567891011121314151617181920/** * @author BNTang * @version 1.0 * @project video_parent * @description 门户系统用户Feign调用客户端 * @since Created in 2021/6/6 006 9:02 **/@Component@FeignClient(name = &quot;service-user&quot;)public interface UserClient &#123; /** * 根据用户id获取用户信息 * * @param userId * 用户Id * @return 用户信息 */ @PostMapping(value = &quot;/service_user/user/getUserInfoOrderById/&#123;userId&#125;&quot;) User getUserInfoOrderById(@PathVariable(&quot;userId&quot;) String userId);&#125; 添加工具类在 common_utils 工程当中添加 UUIDUtil.java 工具类内容如下 1234567891011121314151617181920212223242526272829303132333435363738/** * @author BNTang * @version 1.0 * @project video_parent * @description UUID工具类 * @since Created in 2021/6/6 006 9:20 **/public class UUIDUtil &#123; /** * 生成指定位数的随机字符串 (纯数字) * */ public static String getRandomNumber(Integer number) &#123; return RandomStringUtils.randomNumeric(number); &#125; /** * 生成随机[a-z]字符串，包含大小写 */ public static String getRandomString(Integer number) &#123; return RandomStringUtils.randomAlphabetic(number); &#125; /** * 生成从ASCII 32到126组成的随机字符串 */ public static String getRandomAscii(Integer number) &#123; return RandomStringUtils.randomAscii(number); &#125; /** * 生成没有 &quot;-&quot; 的uuid随机字符串 (包含字母和数字) */ public static String getUuid() &#123; // replace(&quot;-&quot;,&quot;&quot;) : 把 &quot;-&quot; 该为空字符串 &quot;&quot; return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); &#125;&#125; 在 PayOrderController 当中创建根据 作品id 和 用户id 创建订单请求 12345678910111213141516171819202122232425/** * &lt;p&gt; * 订单 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-06-05 */@RestController@RequestMapping(&quot;/service_pay/pay-order&quot;)@Api(tags = &quot;订单组&quot;)@RequiredArgsConstructorpublic class PayOrderController &#123; private final PayOrderService orderService; /** * 根据作品id和用户id创建订单，返回订单id */ @ApiOperation(value = &quot;根据作品id和用户id创建订单，返回订单id&quot;) @PostMapping(&quot;createOrder/&#123;contentId&#125;&quot;) public ResponseResult save(@PathVariable String contentId, HttpServletRequest request) &#123; return ResponseResult.ok().data(&quot;orderId&quot;, orderService.saveOrder(contentId, JwtUtil.getUserIdByJwtToken(request))); &#125;&#125; 修改 PayOrderService.java 123456789101112131415161718192021/** * &lt;p&gt; * 订单 服务类 * &lt;/p&gt; * * @author BNTang * @since 2021-06-05 */public interface PayOrderService extends IService&lt;PayOrder&gt; &#123; /** * 根据作品id和用户id创建订单，返回订单id * * @param contentId * 作品ID * @param userId * 用户Id * @return 订单号 */ String saveOrder(String contentId, String userId);&#125; 修改 PayOrderServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * &lt;p&gt; * 订单 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-06-05 */@Service@RequiredArgsConstructorpublic class PayOrderServiceImpl extends ServiceImpl&lt;PayOrderMapper, PayOrder&gt; implements PayOrderService &#123; private final UserClient userClient; private final ContentClient contentClient; @Override public String saveOrder(String contentId, String userId) &#123; // 通过远程调用根据用户id获取用户信息 User userInfo = userClient.getUserInfoOrderById(userId); // 通过远程调用根据作品id获取作品信息 ContentWebVO contentInfo = contentClient.getContentInfoOrder(contentId); // 创建Order对象，向order对象里面设置需要的数据 PayOrder order = new PayOrder(); // 订单号 order.setOrderNo(UUIDUtil.getRandomNumber(16)); // 课程id order.setContentId(contentId); order.setContentTitle(contentInfo.getTitle()); order.setContentCover(contentInfo.getCover()); order.setAuthorName(contentInfo.getAuthorName()); order.setTotalFee(contentInfo.getPrice()); order.setUserId(userId); order.setMobile(userInfo.getMobile()); order.setNickname(userInfo.getNickname()); // 订单状态（0：未支付 1：已支付） order.setStatus(0); // 支付类型 ，支付宝2 order.setPayType(2); baseMapper.insert(order); // 返回订单号 return order.getOrderNo(); &#125;&#125; 在 PayOrderController 当中创建根据 订单id 查询订单信息请求 12345678/** * 根据订单id查询订单信息 */@ApiOperation(value = &quot;根据订单id查询订单信息&quot;)@GetMapping(&quot;/getOrderInfo/&#123;orderNo&#125;&quot;)public ResponseResult getOrderInfo(@PathVariable String orderNo) &#123; return ResponseResult.ok().data(&quot;item&quot;, orderService.getOrderByOrderNo(orderNo));&#125; 修改 PayOrderService.java 12345678/** * 根据订单id查询订单信息 * * @param orderNo * 订单Id * @return 订单信息 */PayOrder getOrderByOrderNo(String orderNo); 修改 PayOrderServiceImpl.java 123456@Overridepublic PayOrder getOrderByOrderNo(String orderNo) &#123; QueryWrapper&lt;PayOrder&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;order_no&quot;, orderNo); return this.getOne(queryWrapper);&#125; 在 PayOrderController 当中创建根据 用户id 和 作品id 查询该用户是否已经购买该作品请求 1234567891011/** * 根据 `用户id` 和 `作品id` 查询该用户是否已经购买该作品请求 */@ApiOperation(value = &quot;根据 `用户id` 和 `作品id` 查询该用户是否已经购买该作品请求&quot;)@GetMapping(&quot;/isBuyContent/&#123;userid&#125;/&#123;contentId&#125;&quot;)public boolean isBuyContent(@PathVariable String userid, @PathVariable String contentId) &#123; // 订单状态 是1表示支付成功 int count = orderService .count(new QueryWrapper&lt;PayOrder&gt;().eq(&quot;user_id&quot;, userid).eq(&quot;content_id&quot;, contentId).eq(&quot;status&quot;, 1)); return count &gt; 0;&#125; 59-支付操作-前端处理添加查询该课程有没有支付服务器获取作品信息请求 api 修改，首先把对应的 Feign 客户端写完在来修改对应的控制器层，因为这个业务就直接写在 Controller 当中了，没有创建对应的接口方法和在对应的实现类当中完成了，创建 OrderClient.java java 12345678910111213141516171819202122/** * @author BNTang * @version 1.0 * @project video_parent * @description 订单微服务 Feign 客户端调用 * @since Created in 2021/6/6 006 9:53 **/@Component@FeignClient(name = &quot;service-pay&quot;)public interface OrderClient &#123; /** * 根据 `用户id` 和 `作品id` 查询该用户是否已经购买该作品请求 * * @param userid * 用户id * @param contentId * 作品id * @return 是否购买过该作品 */ @GetMapping(&quot;/service_pay/pay-order/isBuyContent/&#123;userid&#125;/&#123;contentId&#125;&quot;) boolean isBuyContent(@PathVariable String userid, @PathVariable String contentId);&#125; 如上完成了之后就可以修改控制器层了修改 ContentController.java java 12@Resourceprivate OrderClient orderClient; java 12345678910111213141516171819202122/** * 根据作品id获取作品详情信息 */@ApiOperation(value = &quot;根据作品id获取作品详情信息&quot;)@GetMapping(&quot;/getContentDeatail/&#123;contentId&#125;&quot;)public ResponseResult getById(@PathVariable String contentId, HttpServletRequest request) &#123; // 查询作品信息和作者信息 ContentWebVO contentWebVo = contentService.selectContentDetailById(contentId); // 查询当前作品的章节信息 List&lt;ChapterVO&gt; chapterVoList = chapterService.getChapterContentVideo(contentId); String uid = JwtUtil.getUserIdByJwtToken(request); boolean isBuy = false; if (!StringUtils.isEmpty(uid)) &#123; // 查询是否已经付费过了 isBuy = orderClient.isBuyContent(uid, contentId); &#125; return ResponseResult.ok().data(&quot;content&quot;, contentWebVo).data(&quot;chapterVoList&quot;, chapterVoList) .data(&quot;isBuyContent&quot;, isBuy);&#125; 前端处理 安装 cookie-universal-nuxt sh 1npm install cookie-universal-nuxt 配置 cookie-universal-nuxt 修改 nuxt.config.js 123modules: [ &#x27;cookie-universal-nuxt&#x27;, [&#x27;cookie-universal-nuxt&#x27;, &#123;parseJSON: true&#125;],], 详情页请求 处理播放状态 如上的代码呢，前面的文章当中已经加入进去了所以不在贴出来了，创建 order.js javascript 123456789101112131415161718192021222324252627import request from &#x27;@/utils/request&#x27;;export default &#123; // 生成订单 createOrders(contentId) &#123; return request(&#123; url: &#x27;/service_pay/pay-order/createOrder/&#x27; + contentId, method: &#x27;post&#x27; &#125;); &#125;, // 根据 `订单id` 查询订单信息 getOrdersInfo(orderId) &#123; return request(&#123; url: &#x27;/service_pay/pay-order/getOrderInfo/&#x27; + orderId, method: &#x27;get&#x27; &#125;); &#125;, // 支付接口 aliPay(orderNo) &#123; return request(&#123; url: &#x27;/service_pay/pay-log/aliPay/&#x27; + orderNo, method: &#x27;get&#x27; &#125;); &#125;&#125; 创建订单点击 创建订单页面在 pages 下创建 order 文件夹在该文件夹中创建 _oid.vue 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;template&gt; &lt;div class=&quot;order&quot;&gt; &lt;div class=&quot;um-order-ux-order-v2-ct-top&quot;&gt; &lt;div class=&quot;um-order-ux-order-v2-ct-top-title&quot;&gt; &lt;h1&gt;确认订单信息&lt;/h1&gt; &lt;h4&gt;请在2小时内完成支付，否则订单会被自动取消&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-account f-cb&quot;&gt; &lt;div class=&quot;um-order-ux-order-account_avatar f-fl&quot;&gt; &lt;img :src=&quot;loginInfo.avatar&quot;&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-account_info f-fl&quot;&gt; &lt;div class=&quot;um-order-ux-order-account_info_nickName&quot;&gt;购买帐号：&#123;&#123; loginInfo.nickname &#125;&#125;&lt;/div&gt; &lt;!--Regular if16--&gt; &lt;div class=&quot;um-order-ux-order-account_info_tips&quot;&gt;注意：购买后不支持退款、转让，请确认开课时间或有效期后再提交订单&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-v2-pay-method&quot;&gt; &lt;div class=&quot;um-order-ux-order-v2-pay-method_head&quot;&gt;支付方式&lt;/div&gt; &lt;div class=&quot;um-order-ux-order-v2-pay-method_body&quot;&gt; &lt;div class=&quot;order-v2-pay_current f-cb&quot;&gt; &lt;span class=&quot;order-v2-pay_current_icon current_icon_alipay f-fl&quot;&gt;&lt;/span&gt; &lt;span class=&quot;order-v2-pay_current_type f-fl&quot;&gt;支付宝&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-school-list&quot;&gt; &lt;div class=&quot;um-order-ux-order-school-list_title&quot;&gt;购买课程&lt;/div&gt; &lt;div class=&quot;um-order-ux-order-school-list_list&quot;&gt; &lt;div class=&quot;um-order-ux-order-school&quot;&gt; &lt;div class=&quot;um-order-ux-order-school_courselist&quot;&gt; &lt;div class=&quot;um-order-ux-order-course&quot;&gt; &lt;div class=&quot;um-order-ux-order-course_card f-cb&quot;&gt; &lt;div class=&quot;um-order-ux-order-course_card_img f-fl&quot;&gt; &lt;a class=&quot;&quot;&gt; &lt;img width=&quot;150px&quot; height=&quot;80px&quot; :src=&quot;order.contentCover&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-course_card_body f-fl&quot;&gt; &lt;a class=&quot;title&quot;&gt; &lt;span&gt;&#123;&#123; order.contentTitle &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;div class=&quot;time&quot;&gt;永久可看&lt;/div&gt; &lt;div class=&quot;promotion&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-course_card_price f-fr&quot;&gt;￥&#123;&#123; order.totalFee &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-v2-ct-bottom um-order-ux-order-v2-ct-bottom_fixed&quot; style=&quot;left: 471.5px;&quot;&gt; &lt;!--Regular if47--&gt; &lt;div class=&quot;um-order-ux-order-v2-go-pay f-cb f-pr&quot;&gt; &lt;form action=&quot;/pay/orderRedirectPage.htm&quot; name=&quot;payForm&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;orderUrl&quot;&gt; &lt;/form&gt; &lt;div class=&quot;um-order-ux-order-v2-go-pay_protocol f-pa&quot;&gt; 提交订单则表示您同意 &lt;span class=&quot;um-order-ux-order-v2-go-pay_protocol_btn&quot;&gt;《BNTang 用户服务协议》&lt;/span&gt;、 &lt;span class=&quot;um-order-ux-order-v2-go-pay_protocol_btn&quot;&gt;《BNTang 售后政策》&lt;/span&gt;等 &lt;/div&gt; &lt;div class=&quot;um-order-ux-order-v2-go-pay_content f-fr&quot;&gt; &lt;div class=&quot;um-order-ux-order-v2-go-pay_content_price&quot;&gt; &lt;span class=&quot;v2-go-pay_content_price_title&quot;&gt;实付:&lt;/span&gt; &lt;span class=&quot;v2-go-pay_content_price_account&quot;&gt; &lt;span class=&quot;v2-go-pay_content_price_account_icon&quot;&gt;￥&lt;/span&gt;&#123;&#123; order.totalFee &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;a class=&quot;um-order-ux-order-v2-go-pay_content_btn&quot; @click=&quot;payClick&quot;&gt;立即支付&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#x27;assets/css/order.css&#x27;import cookie from &quot;js-cookie&quot;;import order from &quot;@/api/order&quot;;export default &#123; layout: &#x27;default&#x27;, asyncData(&#123;params, error&#125;) &#123; return order.getOrdersInfo(params.oid).then(response =&gt; &#123; return &#123; order: response.data.item &#125; &#125;); &#125;, created() &#123; this.showInfo(); &#125;, data() &#123; return &#123; loginInfo: &#123; avatar: &#x27;&#x27;, nickname: &#x27;&#x27; &#125; &#125; &#125;, methods: &#123; showInfo() &#123; let jsonStr = cookie.get(&quot;portal_user&quot;); if (jsonStr) &#123; this.loginInfo = JSON.parse(jsonStr); &#125; &#125;, payClick() &#123; order.aliPay(this.order.orderNo).then(response =&gt; &#123; // 支付的时候, 支付宝会给我们返回支付页面 $(&#x27;body&#x27;).html(response.data.form); &#125;); &#125; &#125;&#125;&lt;/script&gt; 订单页加载数据 60-支付操作-支付与支付日志接口Java 中支付宝准备工作支付宝加密处理与回调方式 加密处理 网站以 POST 请求的方式提交参数给支付宝接口，在支付宝端进行支付处理 POST 请求方式一定程度下保证了安全性，即在 url 上看不到参数，但可以在浏览器开发者工具中可以看到参数，为防止篡改，则可以采用一些加密协议，如：HTTPS、加签名、加密手段 (MD5 加盐、base64、DES、sha1) 等 在加密中又可以分为对称加密 (base64、des 等) 与非对称加密 (RSA 公钥与私钥的互换) 在支付宝中主要使用加签名和 RSA 非对称加密 回调在支付宝接口中，把支付的结果通知给网站 (成功 &#x2F; 失败) 以便更新订单的状态信息, 两种回调方式 同步回调 当 A 网站以 POST 请求方式将参数提交给支付宝接口，支付宝会同步返回通知给 A 网站 同步通知实际上是：本地浏览器的重定向操作，告知 A 网站支付成功还是失败，跳转到指定结果页面 &#x2F; 不做订单处理 因为有可能用户刚支付完, 不等待, 就关闭掉页面, 此方法可能调用不到 异步回调 为了安全性考虑，一般需要进行订单状态的更改时，使用异步通知 此回调是支付宝服务器发送过来的请求 支付宝服务器使用 httpclient 技术调用网站的接口进行通知，网站解析报文，判断到底是支付成功还是支付失败 异步通知包含补偿机制，即：支付宝把结果异步通知给 A 网站，若 A 网站未及时响应给支付宝，则支付宝会进行补偿重发 要返回 success 后, 支付宝才不会继续发送 总结 同步回调: 整个支付流程完毕，使用同步方式将参数重定向给商户平台，一般场景用于展示结果 异步回调: 第三方支付接口发一个后台通知给商户平台，一般场景用户修改订单信息 支付宝开发环境使用支付宝沙箱https://open.alipay.com/platform/home.htm 初次访问需要进行认证，选择自研开发者，自行入驻 找到开发服务中的沙箱，进入到沙箱环境中，配置相应的信息 下载支付宝官方的签名验签工具，下载地址：https://docs.open.alipay.com/291/105971 安装完成后, 进入到该应用当中生成密钥，密钥长度选择 RSA2，密钥格式选择 PKCS8 (Java 适用) 保存应用私钥, 代码当中需要填写应用 应用私钥 复制应用公钥上传到沙盒环境中, 使用应用公钥换取支付宝公钥 加密方式在支付领域，数据安全肯定是首要的任务，加密种类可分为：单向加密、对称加密、非对称加密 最安全的肯定是 RSA：公钥与私钥的互换，效率不如 单向加密 和 对称加密高，但安全性很好，要想破解，必须知道公钥和私钥两把密钥，属于非对称加密 单向加密如 MD5、SHA 等不可逆【不能解密，只能加密】主要用来验证数据传输的过程中，是否被篡改过 对称加密 一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文 明文 ←→ 密钥 ←→ 密文【可以加密，又可以解密】 常用对称加密方案 DES、AES、Base64 非对称加密 在支付领域一般都使用 RSA 非对称加密 在通信双方，如果使用非对称加密，一般遵从这样的原则： 公钥加密，私钥解密。同时，一般一个密钥加密，另一个密钥就可以解密 因为公钥是公开的，如果用来解密，那么就很容易被人解密消息。因此，私钥也可以认为是个人身份的证明 配置文件准备修改 service_pay 工程当中的 application.yml 12345678910111213pay: alibaba: # appid APPID: 2021000116684996 # 私有秘钥 privateKey: MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDK5cQ70nCqc5tmqHmBetBaDqj0VKo3s5cJMlCKWVE5ijeQdD7QBUEWoH+IFPSLqIK675njKsC+5WZOgOsqru4Ofh4s3pw7Pi598K0qEIjMxtRSm9P0q4c/CcvDpqApHcqO5NaLY1q7TWxm0RG3Hd7wf9ZNIxezvVbWOrSJiGmS76gDMPQKisyc7wZnxPHzBmFEp1oWY0e4MKlii2BBMmJrIx4vm8g1ufUksD4ymlp8kgP8vArEvdVNo1F2HVXTJ5g1YKWnp5dQqEO3rkAOsChMr7R4YLpXg+q9topCFXJiXh0RR3NnNGKfnGkNOt0WoF2uELz4zgtt0hbwzRCk1vsrAgMBAAECggEAcPbL8qKPp9cFxno2bCh8qCdRWfdpbenHRY+F2AEyf968YOjXr+m8+2QQnStNnBQN9RZBj4DWH3KJK1wLkpAial89Xa3zPei46dV+E9Vw1NI+lF+9+pMlkataj2vN8BZuGHDAIosGkRHiMLxmKJWw8iW6oufO4nugRVYZ/hi87tkR4IYm7mz1HGKbK0osuhCoeXfzT5wLhC7o/1EbQEMj+m+/iHhMhszuqu7rl6jKdwsXSNdeEK7d7IL0btLJ1SUTku8u4WMstTn5zd1F3d2TRcsJBJJv8fiBoWzbnzMsYsAV7sv1KkaZ0awMvRQm3ngzaWnR4wfXUjcPOsBkfjRwgQKBgQDlgeZ+SVvR7sEz9bSLEXdS2hOcmTqegawgkuqpps1eIGiejxuv7HQ2M+0OKWN1kHkhhZD/xsMJEhW2zVB+AMrPRG31fz7oASX4NkVr+2OXIvzn7md5O9DybMZQ4dzL7HFn++QoU3xQT2WBsx9SLUBJIW9RIAtM1dSjilzjHZ0zSQKBgQDiUYaTseOvy9ELp6D801IVXHxp3HgBDT8fshb1AgSr2eKPZbxJAv1qIcd2tg7cKt2Rq27MEnzpkFtAKyKLxMl/+YQoxePJdqOyq4MR9mzVKpu9G0PRGhF23xCv1WzS/BhtIp7t+RaBnQM4j7Qgh9TQOu1znU8ar3aCQulrcoIG0wKBgDaYbiJAhS0tZJxdqLMkVoRJCD1KXh1yr2WYTWZKHbR0dS6y0F1LHGIAfDXQNq6yzX3h7hpKR/8SZEP2F13CBnzDxHyP5oD+NPAUyPLk/E3prsvldIvsZMomgg6fjAyelGOuEhpdscbQ/E6cM6kyxoYfBAICY23FuC2nLm2Aj/KxAoGAFT6h62tffDkdvoJV0mXj5q1v4GAZw7+ClW8aSJWP6rHhWqSqMBBfyX6yQqqEapZ7hhkZpX52y1YJutRRwd0PLTw287zfzSGd7D+9ZgpD3R7Kz82naBGSYh4+asMWHBgeEuCVGrGvMyuSCdUzi3o0t/dQIvI5Yr/l2AR/9N4i5pECgYADoJF6TQbk6w/GxQt9bl7NXv6UjiPslEpeBJOQz6+njXvf/ByDgGM//dpUK5VTUo7dyzBnSefVvr63PdhNjwS4FBcjTXTWSuyhvXG84XMM7he2R4OlbkDdYLe3byDUT5Go1K9h3juXahiejexiwcTKOhZnk/5aFr/Cvtdm69cKMw== # 支付宝公有密钥 publvicKey: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAgvMKvBii086mbtIhCAa8fMYGchJMrosUP6gCUKEFYz27BHGyGY5Rbmakl+l6mk2UilOuqNNqdy/evOLD05j46ro0QXo8q0IG7/0KW7ndd344JhlfUJP5OaT1bI6gwy2lalXMK605/DsjyK9mWWj5Wfxuyjz26mjFTd6OWXUMD0MF/F77sMb3o0kF0MeJP7rQYivYunaPvP985PO4zwYlnwGC9FX7jIpGRS3wrYG20Jcq0nLlzyTaqSNvP2Fk0z6jsFvo7loSAtrIa9ux+/zcXsrQquUidEoRxeb5X2tCDkfFgrQVM6YmAxj80Q2VksiOvk4sZhkdoc0273wnKlgfDQIDAQAB # 支付宝服务地址 serverUrl: https://openapi.alipaydev.com/gateway.do # 回调地址, 注意这里服务器回调一定要公网ip returnUrl: http://it6666.viphk.ngrok.org/callback/returnUrl notyfyUrl: http://it6666.viphk.ngrok.org/callback/notifyUrl APPID privateKey publvicKey serverUrl 创建 common 包在该包中创建 config 包和 properties 包，在每个包中创建对应的类分别如下 创建 AliPayProperties.java 123456789101112131415161718192021222324252627282930313233/** * @author BNTang * @version 1.0 * @project video_parent * @description * @since Created in 2021/6/6 006 18:14 **/@Data@Component@ConfigurationProperties(prefix = &quot;pay.alibaba&quot;)public class AliPayProperties &#123; private String appId; /** * 私钥 */ private String privateKey; /** * 公钥 */ private String publvicKey; /** * 支付宝服务地址 */ private String serverUrl; /** * 回调地址 */ private String returnUrl; /** * 异步回调 */ private String notyfyUrl;&#125; 创建 AliPayApiConfig.java 1234567891011121314151617181920212223/** * @author BNTang * @version 1.0 * @project video_parent * @description 阿里支付Api配置 * @since Created in 2021/6/6 006 18:08 **/@Configuration@RequiredArgsConstructorpublic class AliPayApiConfig &#123; private final AliPayProperties aliPayProperties; private static final String JSON = &quot;json&quot;; private static final String RSA2 = &quot;RSA2&quot;; private static final String CHARSET = &quot;UTF-8&quot;; /** * 获取阿里支付客户端 */ public AlipayClient getAliPayClient() &#123; return new DefaultAlipayClient(aliPayProperties.getServerUrl(), aliPayProperties.getAppId(), aliPayProperties.getPrivateKey(), JSON, CHARSET, aliPayProperties.getPublvicKey(), RSA2); &#125;&#125; 内网穿透http://www.ngrok.cc 什么是内网穿透 通常个人电脑无论是连接 WIFI 上网还是用网线上网，都是属于局域网里边的，外网无法直接访问到你的电脑 内网穿透可以让你的局域网中的电脑实现外网访问功能, 针对上面这句话中出现的内网和外网 支付接口业务支付接口PayLogController.java 1234567891011121314151617181920212223242526/** * &lt;p&gt; * 支付日志表 前端控制器 * &lt;/p&gt; * * @author BNTang * @since 2021-06-05 */@RestController@RequiredArgsConstructor@RequestMapping(&quot;/service_pay/pay-log&quot;)public class PayLogController &#123; private final PayLogService payService; /** * 订单支付 * * @param orderNo * 订单号 * @return 支付页面 */ @GetMapping(&quot;/aliPay/&#123;orderNo&#125;&quot;) public ResponseResult aliPay(@PathVariable String orderNo) &#123; return ResponseResult.ok().data(&quot;form&quot;, payService.aliPay(orderNo)); &#125;&#125; PayLogService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * &lt;p&gt; * 支付日志表 服务实现类 * &lt;/p&gt; * * @author BNTang * @since 2021-06-05 */@Service@Slf4j@RequiredArgsConstructorpublic class PayLogServiceImpl extends ServiceImpl&lt;PayLogMapper, PayLog&gt; implements PayLogService &#123; /** * 编码 */ private static final String CHARSET = &quot;UTF-8&quot;; /** * 交易多长时间后关闭 */ private static final String EXPIRE = &quot;30m&quot;; private final AliPayProperties aliPayProperties; private final AliPayApiConfig aliPayApiConfig; private final PayOrderService payOrderService; @Override public String aliPay(String orderNo) &#123; // 1 根据订单号查询订单信息 QueryWrapper&lt;PayOrder&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); PayOrder order = payOrderService.getOne(wrapper); // 支付内容参数 AlipayTradePagePayModel model = new AlipayTradePagePayModel(); model.setOutTradeNo(order.getOrderNo()); // 销售产品码 电脑网站支付固定为 FAST_INSTANT_TRADE_PAY model.setProductCode(&quot;FAST_INSTANT_TRADE_PAY&quot;); // 商品金额 model.setTotalAmount(order.getTotalFee().toString()); // 商品标题 model.setSubject(order.getContentTitle()); // 商品描述 model.setBody(&quot;支付宝支付，共&quot; + order.getTotalFee() + &quot;元&quot;); // 设置订单最晚付款时间 过期交易将关闭 model.setTimeoutExpress(EXPIRE); // 构建请求 AlipayTradePagePayRequest request = new AlipayTradePagePayRequest(); request.setReturnUrl(aliPayProperties.getReturnUrl()); request.setNotifyUrl(aliPayProperties.getNotyfyUrl()); request.setBizModel(model); // 发起请求 try &#123; String form = aliPayApiConfig.getAliPayClient().pageExecute(request).getBody(); HttpServletResponse response = ServletUtils.getResponse(); response.setContentType(&quot;text/html;charset=&quot; + CHARSET); return form; &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); throw new BnTangException(20001, &quot;支付宝电脑网站支付失败&quot;); &#125; &#125;&#125; 回调接口创建 AliPayCallBackUrl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * @author BNTang * @version 1.0 * @project video_parent * @description 支付宝回调控制器 * @since Created in 2021/6/6 006 18:27 **/@Controller@RequestMapping(&quot;/callback&quot;)@Api(tags = &quot;支付&quot;)@RequiredArgsConstructorpublic class AliPayCallBackUrl &#123; /** * 编码 */ private static final String CHARSET = &quot;UTF-8&quot;; /** * 支付日志 */ private final PayLogService payLogService; /** * 订单 */ private final PayOrderService payOrderService; /** * 配置 */ private final AliPayProperties aliPayProperties; /** * 只有付款成功才会跳转到这里且只跳转一次 浏览器调用 重定向形式,不做跟订单相关的事 页面跳转 */ @ApiOperation(value = &quot;只有付款成功才会跳转到这里且只跳转一次 浏览器调用 重定向形式&quot;) @GetMapping(&quot;/returnUrl&quot;) public String returnUrl() &#123; HttpServletResponse response = ServletUtils.getResponse(); HttpServletRequest request = ServletUtils.getRequest(); response.setContentType(&quot;text/html;charset=&quot; + CHARSET); try &#123; // 获取支付宝GET过来反馈信息 boolean signVerified = checkSignature(request); if (signVerified) &#123; // 跳转到作品详情页 哪一个作品? // 商户订单号 String outTradeNo = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(StandardCharsets.ISO_8859_1), CHARSET); // 获取订单 PayOrder payOrder = payOrderService.getOrderByOrderNo(outTradeNo); // 获取作品id String url = &quot;http://localhost:3000/video/&quot; + payOrder.getContentId(); return &quot;redirect:&quot; + url; &#125; &#125; catch (AlipayApiException | IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 服务器通知 : 1. ip地址一定是公网的，私有地址支付宝无法通知到客户端 2. 请求方式是POST请求 */ @PostMapping(&quot;/notifyUrl&quot;) public void notifyUrl() &#123; // 支付宝调用 return success 如果没有返回 还会继续调用 HttpServletResponse response = ServletUtils.getResponse(); HttpServletRequest request = ServletUtils.getRequest(); try &#123; PrintWriter out = response.getWriter(); boolean signVerified = this.checkSignature(request); if (signVerified) &#123; // 以下信息是支付定在请求当中写入信息 // 商户订单号 String outTradeNo = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(StandardCharsets.ISO_8859_1), CHARSET); // 支付宝交易号 String transactionId = new String(request.getParameter(&quot;trade_no&quot;).getBytes(StandardCharsets.ISO_8859_1), CHARSET); // 交易状态 String tradeStatus = new String(request.getParameter(&quot;trade_status&quot;).getBytes(StandardCharsets.ISO_8859_1), CHARSET); // 更新订单 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;out_trade_no&quot;, outTradeNo); map.put(&quot;trade_state&quot;, tradeStatus); map.put(&quot;transaction_id&quot;, transactionId); if (&quot;TRADE_FINISHED&quot;.equals(tradeStatus)) &#123; // 判断该笔订单是否在商户网站中已经做过处理 // 如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细， // 并执行商户的业务程序 // 如果有做过处理，不执行商户的业务程序 PayOrder payOrder = payOrderService.getOrderByOrderNo(outTradeNo); if (payOrder.getStatus() != 1) &#123; payLogService.updateOrdersStatus(map); &#125; &#125; else if (&quot;TRADE_SUCCESS&quot;.equals(tradeStatus)) &#123; payLogService.updateOrdersStatus(map); &#125; out.println(&quot;success&quot;); &#125; else &#123; out.println(&quot;fail&quot;); &#125; &#125; catch (AlipayApiException | IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 校验签名 */ private boolean checkSignature(HttpServletRequest request) throws AlipayApiException &#123; Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); requestParams.keySet().forEach(name -&gt; &#123; String[] values = requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; &#125; // 乱码解决，这段代码在出现乱码时使用 // valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); params.put(name, valueStr); &#125;); return AlipaySignature.rsaCheckV1(params, aliPayProperties.getPublvicKey(), CHARSET, &quot;RSA2&quot;); &#125;&#125; 修改 PayLogService.java 1234567/** * 更新订单状态 * * @param map * 订单属性Map */void updateOrdersStatus(HashMap&lt;String, String&gt; map); 修改 PayLogServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void updateOrdersStatus(HashMap&lt;String, String&gt; map) &#123; // 从map获取订单号 String orderNo = map.get(&quot;out_trade_no&quot;); // 根据订单号查询订单信息 QueryWrapper&lt;PayOrder&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); PayOrder order = payOrderService.getOne(wrapper); // 更新订单表订单状态 if (order.getStatus() == 1) &#123; return; &#125; // 1代表已经支付 order.setStatus(1); payOrderService.updateById(order); // 向支付表添加支付记录 PayLog payLog = new PayLog(); // 订单号 payLog.setOrderNo(orderNo); // 订单完成时间 payLog.setPayTime(new Date()); // 支付类型 1微信 payLog.setPayType(2); // 总金额(分) payLog.setTotalFee(order.getTotalFee()); // 支付状态 payLog.setTradeState(map.get(&quot;trade_state&quot;)); // 流水号 payLog.setTransactionId(map.get(&quot;transaction_id&quot;)); payLog.setAttr(JSONObject.toJSONString(map)); baseMapper.insert(payLog);&#125; 在 common_utils 工程当中创建 ServletUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author BNTang * @version 1.0 * @project video_parent * @description servlet工具类 * @since Created in 2021/6/6 006 18:25 **/public class ServletUtils &#123; /** * 获取RequestAttributes对象 */ public static ServletRequestAttributes getRequestAttributes() &#123; RequestAttributes attributes = RequestContextHolder.getRequestAttributes(); return (ServletRequestAttributes)attributes; &#125; /** * 获取 HttpServletRequest 对象 */ public static HttpServletRequest getRequest() &#123; return getRequestAttributes().getRequest(); &#125; /** * 获取response对象 */ public static HttpServletResponse getResponse() &#123; return getRequestAttributes().getResponse(); &#125; /** * 获取session对象 */ public static HttpSession getSession() &#123; return getRequest().getSession(); &#125; /** * 把字符串打印到客户端 */ public static String sendString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 支付宝账户与密码 账户：&#99;&#120;&#115;&#105;&#x6d;&#114;&#x36;&#52;&#x39;&#55;&#64;&#x73;&#x61;&#x6e;&#100;&#x62;&#x6f;&#120;&#46;&#99;&#x6f;&#109; 密码：111111","categories":[],"tags":[]},{"title":"uniAPP开发 全教程","slug":"uniAPP开发-全教程","date":"2022-09-01T02:00:09.000Z","updated":"2022-09-01T02:00:23.878Z","comments":true,"path":"2022/09/01/uniAPP开发-全教程/","link":"","permalink":"http://example.com/2022/09/01/uniAPP%E5%BC%80%E5%8F%91-%E5%85%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"uniAPP开发 全教程一、(项目创建、tabbar配置、运行)简介： uni-app 是一个使用 Vue.js开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;头条&#x2F;QQ&#x2F;钉钉&#x2F;淘宝）、快应用等多个平台。 官网：https://uniapp.dcloud.io/ 创建第一个 uni-app项目1、开发者需先下载安装 HBuilderX下载地址: https://www.dcloud.io/hbuilderx.html 2、在HBuilderX 点击工具栏里的文件 - &gt;新建 - &gt;项目： 选择uni-app，输入工程名，如：test，点击创建，即可成功创建uni-app 项目目录 创建页面 导入静态资源包（图片） 页面tabbar配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; &quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages &#123; &quot;path&quot;: &quot;pages/index/index&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;首页&quot; &#125; &#125;, &#123; &quot;path&quot;: &quot;pages/news/news&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;动态&quot; &#125; &#125;, &#123; &quot;path&quot;: &quot;pages/msg/msg&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;消息&quot; &#125; &#125; ,&#123; &quot;path&quot; : &quot;pages/my/my&quot;, &quot;style&quot; : &#123; &quot;navigationBarTitleText&quot;: &quot;我的&quot; &#125; &#125; ], &quot;globalStyle&quot;: &#123; &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#F8F8F8&quot;, &quot;backgroundColor&quot;: &quot;#F8F8F8&quot; &#125;, &quot;tabBar&quot;:&#123; &quot;color&quot;:&quot;#333333&quot;, &quot;selectedColor&quot;:&quot;#FC5C82&quot;, &quot;backgroundColor&quot;:&quot;#FFFFFF&quot;, &quot;borderStyle&quot;:&quot;black&quot;, &quot;list&quot;:[&#123; &quot;pagePath&quot;:&quot;pages/index/index&quot;, &quot;text&quot;:&quot;首页&quot;, &quot;iconPath&quot;:&quot;static/tabbar/index.png&quot;, &quot;selectedIconPath&quot;:&quot;static/tabbar/indexed.png&quot; &#125;,&#123; &quot;pagePath&quot;:&quot;pages/news/news&quot;, &quot;text&quot;:&quot;动态&quot;, &quot;iconPath&quot;:&quot;static/tabbar/news.png&quot;, &quot;selectedIconPath&quot;:&quot;static/tabbar/newsed.png&quot; &#125;,&#123; &quot;pagePath&quot;:&quot;pages/msg/msg&quot;, &quot;text&quot;:&quot;消息&quot;, &quot;iconPath&quot;:&quot;static/tabbar/paper.png&quot;, &quot;selectedIconPath&quot;:&quot;static/tabbar/papered.png&quot; &#125;,&#123; &quot;pagePath&quot;:&quot;pages/my/my&quot;, &quot;text&quot;:&quot;我的&quot;, &quot;iconPath&quot;:&quot;static/tabbar/home.png&quot;, &quot;selectedIconPath&quot;:&quot;static/tabbar/homeed.png&quot; &#125;] &#125;&#125; 运行 运行效果图 二、(微信开发者工具运行项目，icon字体使用，组件) 上一篇文章已经运行起了一个uni-app项目的小demo，但是运行在Chrome浏览器的H5页面，那在微信开发者工具中如何实时模拟查看该项目呢？ 1.在微信开发者工具中运行配置小程序IDE相关路径说明：只有配置了才能在微信小程序运开发者工具中运行成功 2. 开启小程序IDE服务端口的设置—&gt;安全设置—&gt;安全 （开启） 3. 修改 manifest.json配置文件，添加自己的小程序AppId: 4. 进入test项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，生成对应的微信小程序项目，即可在微信开发者工具里面体验了。 5. 运行效果 6. 组件 1）基础组件，与微信小程序相同;2）自定义组件，根据需要通过基础组件进行组合；3）uni-ui，是DCloud提供的基于vue组件的、flex布局的、无dom的跨全端扩展ui框架；4）插件市场，提供了更多扩展组件、模板，包括前端组件和原生扩展组件，具体见插件市场; 7.基础组件12345&lt;view&gt; &lt;icon type=&quot;success&quot; size=&quot;26&quot;/&gt; &lt;button type=&quot;primary&quot;&gt;页面主操作 Normal&lt;/button&gt; &lt;progress percent=&quot;20&quot; show-info stroke-width=&quot;3&quot; /&gt;&lt;/view&gt; 8. 字体库的引入1、拷贝common目录到项目中，icon.css在common中，并修改引入的字体路径2、拷贝static目录到项目中，字体文件在static目录中。 在mainjs中引入iconfont.css 12// 引入全局cssimport &#x27;./static/2002icon/iconfont.css&#x27; 在组件中页面中使用： 1&lt;text class=&quot;iconfont icon-jinru&quot;&gt;&lt;/text&gt; 9. 自定义组件根目录下创建components目录，创建list.vue组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;view v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot; class=&#x27;list&#x27;&gt; &lt;view class=&#x27;title-icon&#x27;&gt; &lt;image :src=&#x27;item.imgSrc&#x27;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&#x27;right bottom&#x27;&gt; &lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;text class=&quot;iconfont icon-jinru&quot;&gt;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;list&quot;, data()&#123; return&#123; &#125; &#125;, //属性 props: &#123; list: &#123; type: Array, value: &quot;&quot; &#125; &#125;, created() &#123; console.log(999, this.list) &#125;&#125;&lt;/script&gt;&lt;style&gt; .list &#123; display: flex; height: 112rpx; line-height: 112rpx;&#125;.list .title-icon &#123; width: 48rpx; flex-grow: 0; margin-right: 24rpx; position: relative; &#125;.list .title-icon image &#123; width: 48rpx; height: 48rpx; position: absolute; top: 50%; transform: translateY(-50%);&#125;.list .right &#123; display: flex; flex-grow: 1; justify-content: space-between; position: relative; line-height: 112rpx;&#125;.list .bottom::after &#123; content: &#x27;&#x27;; height: 1px; width: 100%; display: block; position: absolute; bottom: 0; left: 0; background-color: #E8ECED; transform: scaleY(0.5);&#125;.list .right text &#123; font-size: 34rpx; color: rgba(53,53,54,1);&#125;&lt;/style&gt; 父组件我的页面my.vue，引入自定义组件list.vue，并传参 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;view class=&quot;person-ctn&quot;&gt; &lt;list v-bind:list=&quot;list&quot;&gt;&lt;/list&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import list from &quot;../../components/list.vue&quot;;export default &#123; components: &#123; list, &#125;, data() &#123; return &#123; list: [ &#123; title: &#x27;我的推荐&#x27;, imgSrc:require(&quot;../../static/tabbar/paper.png&quot;), path: &#x27;/pages/myRecommend/myRecommend&#x27; &#125;, &#123; title: &#x27;推广同盟&#x27;, imgSrc:require(&quot;../../static/tabbar/news.png&quot;), path: &#x27;/pages/promote/promote&#x27; &#125;, &#123; title: &#x27;资金明细&#x27;, imgSrc:require(&quot;../../static/tabbar/home.png&quot;), path: &#x27;/pages/capital/capital&#x27; &#125;, &#123; title: &#x27;设置&#x27;, imgSrc:require(&quot;../../static/tabbar/index.png&quot;), path: &#x27;/pages/setting/setting&#x27; &#125;, ], &#125; &#125;, methods: &#123; &#125;&#125;&lt;/script&gt;&lt;style&gt; .person-ctn &#123; padding: 0 32rpx; &#125;&lt;/style&gt; 最终效果： 10、uni-ui的使用 1）uni-ui 是全端兼容的基于flex布局的ui库；2）可以使用 npm 的安装使用方式，也可下载相关组件直接使用；3）uni-ui不支持使用 Vue.use() 的方式安装4）uni-ui 依赖 scss，若是 HBuilderX 中创建的 uni-app项目，需要在 HBuilderX 中安装 scss 插件；如果是使用 cli 创建的 uni-app 项目，需要在项目下npm安装node-sass 和 sass-loader 1. 初始化项目在 HBuilderX 中新建 uni-app 项目，进入项目目录，执行： 1npm init -y 2. 安装 uni-ui1npm install @dcloudio/uni-ui 3. 使用 uni-uiindex.vue引入组件，在template中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;view class=&quot;homework-ctn&quot;&gt; &lt;uni-card :title=&#x27;title&#x27; :isFull=&quot;isFull&quot; :note=&quot;note&quot; :thumbnail=&quot;thumbnail&quot; :extra=&quot;extra&quot;&gt; helloword &lt;/uni-card&gt; &lt;uni-pagination show-icon=false total=100 pageSize=10 current=2 prev-text=&quot;上一页&quot; next-text=&quot;下一页&quot; &gt;&lt;/uni-pagination&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import &#123;uniCard, uniPagination&#125; from &#x27;@dcloudio/uni-ui&#x27; // 也可使用此方式引入组件 import uniBadge from &#x27;@dcloudio/uni-ui/lib/uni-badge/uni-badge.vue&#x27; export default &#123; components: &#123; uniCard, uniPagination &#125;, data() &#123; return &#123; title: &#x27;聊天&#x27;, extra: &#x27;快快学习uniapp&#x27;, note: &#x27;1910a班&#x27;, thumbnail: require(&#x27;../../static/tabbar/index.png&#x27;), isFull: true &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .content &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; &#125; .logo &#123; height: 200rpx; width: 200rpx; margin-top: 200rpx; margin-left: auto; margin-right: auto; margin-bottom: 50rpx; &#125; .text-area &#123; display: flex; justify-content: center; &#125; .title &#123; font-size: 36rpx; color: #8f8f94; &#125;&lt;/style&gt; 按需引入 12import uniCard from &quot;../../uni-ui/uni-card/uni-card.vue&quot;import uniPagination from &quot;@/uni-ui/uni-pagination/uni-pagination.vue&quot; 4.运行报错后引入Hbuilderx没有安装编译sass插件点击 工具 —&gt; 插件安装 安装新插件—-&gt;前往插件市场安装最终效果： 三、（全局模块util.js、全局变量、vuex）1. 公用模块1.1 定义一个专用的模块，用来组织和管理这些全局的变量，在需要的页面引入。在 uni-app 项目根目录下创建 common 目录，然后在 common 目录下新建 util.js 用于定义公用的方法。 12345678const baseUrl = &#x27;https://ceshi2.dishait.cn/api/v1&#x27;; const nowTime = Date.now || function () &#123; return new Date().getTime(); &#125;; export default &#123; baseUrl, nowTime, &#125; 1.2 接下来在 pages&#x2F;index&#x2F;index.vue 中引用该模块1234567891011121314&lt;script&gt; import helper from &#x27;../../common/util.js&#x27;; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log(&#x27;nowTime:&#x27; + utils.nowTime()); &#125;, methods: &#123;&#125;, &#125; &lt;/script&gt; 小结： 优点：这种方式维护起来比较方便； 缺点：需要每次都引入； 2. 挂载 Vue.prototype 将一些使用频率较高的常量或者方法，直接扩展到 Vue.prototype 上，每个 Vue 对象都会“继承”下来。 2.1 在 main.js 中挂载属性&#x2F;方法1234Vue.prototype.websiteUrl = &#x27;https://ceshi2.dishait.cn/api/v1&#x27;; Vue.prototype.nowTime = Date.nowTime || function () &#123; return new Date().getTime(); &#125;; 2.2 在 pages&#x2F;index&#x2F;index.vue 中调用123456789101112&lt;script&gt; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log(&#x27;now:&#x27; + this.nowTime()); &#125;, methods: &#123;&#125;， &#125; &lt;/script&gt; 这种方式，只需要在 main.js 中定义好即可在每个页面中直接调用。 注意： 1、每个页面中不要在出现重复的属性或方法名。2、建议在 Vue.prototype 上挂载的属性或方法，可以加一个统一的前缀。比如 $baseUrl，在阅读代码时也容易与当前页面的内容区分开。 3. Vuex Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 首先安装vuexcnpm install vuex -S 3.1 在 uni-app 项目根目录下新建 store 目录，在 store 目录下创建 index.js 定义状态值1234567891011121314151617181920212223242526272829import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; login: false, token: &#x27;&#x27;, avatarUrl: &#x27;&#x27;, userName: &#x27;&#x27; &#125;, mutations: &#123; login(state, provider) &#123; console.log(state) console.log(provider) state.login = true; state.token = provider.token; state.userName = provider.userName; state.avatarUrl = provider.avatarUrl; &#125;, logout(state) &#123; state.login = false; state.token = &#x27;&#x27;; state.userName = &#x27;&#x27;; state.avatarUrl = &#x27;&#x27;; &#125; &#125; &#125;) module.exports=store 3.2 在 main.js 挂载 Vuex123import store from &#x27;./store&#x27; Vue.prototype.$store = store 3.3 在 pages&#x2F;index&#x2F;index.vue 使用123456789101112131415&lt;script&gt; import &#123; mapState, mapMutations &#125; from &#x27;vuex&#x27;; export default &#123; computed: &#123; ...mapState([&#x27;token&#x27;, &#x27;userId&#x27;, &#x27;userName&#x27;]) &#125;, methods: &#123; ...mapMutations([&#x27;logout&#x27;]) &#125; &#125; &lt;/script&gt; 四、(uni.requet()、网络模块封装)1. uni-app网络请求uni-app题拱了uni.requet()方法，发起网络请求： 1234567891011121314uni.request(&#123; url: &#x27;https://ceshi2.dishait.cn/api/v1/list&#x27;, //仅为示例，并非真实接口地址。 data: &#123; text: &#x27;uni.request&#x27; &#125;, header: &#123; &#x27;custom-header&#x27;: &#x27;hello&#x27; //自定义请求头信息 &#125;, success: (res) =&gt; &#123; console.log(res.data); this.text = &#x27;request success&#x27;; &#125;&#125;); 注意： 在各个小程序平台运行时，网络相关的 API 在使用前需要配置域名白名单。 data 数据说明 最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String。转换规则如下： 对于 GET 方法，会将数据转换为 query string。例如{ name: ‘name’, age: 18 } 转换后的结果是name&#x3D;name&amp;age&#x3D;18。 对于 POST 方法且 header[‘content-type’] 为application&#x2F;json的数据，会进行 JSON 序列化，是默认值。 对于 POST 方法且header[‘content-type’]为 application&#x2F;x-www-form-urlencoded 的数据，会将数据转换为 query string。 2. uni.request()未封装VUE组件中的使用12345678910111213141516171819202122232425262728293031323334getList:function()&#123; var _self=this; var token = uni.getStorageSync(_self.sessionKey); uni.request(&#123; url: &#x27;https://ceshi2.dishait.cn/api/v1&#x27;, method: &#x27;GET&#x27;, data: &#123; token : token, timestamp : timestamp &#125;, success: res =&gt; &#123; if (res.data.code == &quot;401&quot;) &#123;//登录失效 //弹框提示 uni.showToast(&#123; title: res.data.msg, mask: false, duration: 1500 &#125;); &#125; else if (res.data.code == &quot;0&quot;) &#123; var data = res.data.data; _self.onlineNum = data.onlineNum; _self.machineNum = data.machineNum; &#125;else &#123; console.log(&quot;未处理的结果码&quot;); &#125; &#125;, fail: (e) =&gt; &#123; console.log(&quot;getMachineNum fail:&quot; + JSON.stringify(e)); &#125;, complete: () =&gt; &#123;&#125; &#125;);&#125;, 返回结果： 123456789101112131415161718192021222324&#123; &quot;data&quot;: &#123; &quot;code&quot;: &quot;0&quot;, &quot;msg&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;machineNum&quot;: 124, &quot;onlineNum&quot;: 1, &#125; &#125;, &quot;header&quot;: &#123; &quot;Server&quot;: &quot;nginx/1.14.0&quot;, &quot;Date&quot;: &quot;Thu, 11 Apr 2019 03:08:20 GMT&quot;, &quot;Content-Type&quot;: &quot;application/json;charset=utf-8;&quot;, &quot;Transfer-Encoding&quot;: &quot;chunked&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;X-Powered-By&quot;: &quot;PHP/7.1.16&quot; &#125;, &quot;statusCode&quot;: 200, &quot;cookies&quot;: [], &quot;errMsg&quot;: &quot;request:ok&quot;&#125; 3.uniapp封装网络请求1. 我们先通过Promise进行一次简单封装,新建request.js文件： 1234567891011121314151617181920//options参数我们后面会说function service(options = &#123;&#125;) &#123;return new Promise((resolved, rejected) =&gt; &#123;uni.request(&#123; url: options.url, //仅为示例，并非真实接口地址。 data: options.data, header: &#123; &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;token&#x27;: `$&#123;token&#125;` //权限token &#125;, success: (res) =&gt; &#123; rejected(res.data); &#125;.fail = (err) =&gt; &#123; rejected(err) &#125;&#125;);&#125;&#125;export default service; 2. 在common目录下新建config.js放置我们的多环境变量，方便后期切换环境 123456789101112export default &#123; // api请求前缀 // webUrl : 开发环境前缀, webUrl:&#x27;https://ceshi2.dishait.cn/api/v1&#x27;, //testUrl : 测试环境前缀 testUrl:&#x27;https://ceshi3.dishait.cn/api/v1&#x27;, //proUrl : 生产环境前缀 proUrl:&#x27;https://ceshi.dishait.cn/api/v1&#x27;, // websocket地址 websocketUrl:&quot;wss://ceshi2.dishait.cn/wss&quot;,&#125; 现在目录如下: 1234567891011121314┌─common│ ├─config.js //请求│ ├─request.js //请求┌─pages│ ├─index│ │ └─index.vue //页面文件├─static├─store│ ├─index.js //vuex├─main.js├─App.vue├─manifest.json└─pages.json 3. 接下来我们对requst.js进行一次优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//把配置项单独处理import $C from &#x27;@/common/config.js&#x27;; // 引入baseUrlimport $store from &#x27;@/store/index.js&#x27;;//vuexexport default &#123; //定义默认请求参数 common:&#123; method: &#x27;GET&#x27;, header:&#123; &quot;content-type&quot;:&quot;application/json&quot; &#125;, data:&#123;&#125; &#125;, request(options = &#123;&#125;)&#123; options.url = $C.webUrl + options.url options.method = options.method || this.common.method options.header = options.header || this.common.header // 验证权限token if(options.token)&#123; options.header.token = $store.state.token if(!options.header.token)&#123; return uni.showToast(&#123; title: &#x27;非法token,请重新登录&#x27;, icon: &#x27;none&#x27; &#125;); &#125; &#125; return new Promise((res,rej)=&gt;&#123; uni.request(&#123; ...options, success: (result) =&gt; &#123; // 返回原始数据 // console.log(result); if(options.native)&#123; return res(result) &#125; // 请求服务端失败 if (result.statusCode !== 200 &amp;&amp; !options.notoast) &#123; uni.showToast(&#123; title:result.data.msg || &#x27;请求失败&#x27;, icon: &#x27;none&#x27; &#125;); return rej(result.data) &#125; // 成功 res(result.data.data) &#125;, fail:(error)=&gt;&#123; uni.showToast(&#123; title: error.errMsg || &#x27;请求失败&#x27;, icon: &#x27;none&#x27; &#125;); return rej() &#125; &#125;); &#125;) &#125;, // 单独封装 get 方式请求 get(url,data = &#123;&#125;,options = &#123;&#125;)&#123; options.url = url options.data = data options.method = &#x27;GET&#x27; return this.request(options) &#125;, // 单独封装 post 方式请求 post(url,data = &#123;&#125;,options = &#123;&#125;)&#123; options.url = url options.data = data options.method = &#x27;POST&#x27; return this.request(options) &#125;, // 单独封装 文件上传 方式请求 ,不需要则可以暂时不封装 upload(url,options = &#123;&#125;)&#123; options.url = $C.webUrl + url options.header = options.header || &#123;&#125; // 验证权限token if(options.token)&#123; options.header.token = $store.state.token if(!options.header.token)&#123; return uni.showToast(&#123; title: &#x27;非法token,请重新登录&#x27;, icon: &#x27;none&#x27; &#125;); &#125; &#125; return new Promise((res,rej)=&gt;&#123; uni.uploadFile(&#123; ...options, success: (uploadFileRes) =&gt; &#123; if(uploadFileRes.statusCode !== 200)&#123; return uni.showToast(&#123; title: &#x27;上传图片失败&#x27;, icon: &#x27;none&#x27; &#125;); &#125; let data = JSON.parse(uploadFileRes.data) res(data) &#125;, fail:(err)=&gt;&#123; rej(err) &#125; &#125;); &#125;) &#125;&#125; 4. 在main.js总，导入request.js ,并挂载到Vue原型上。 1234// 引入请求库import $H from &#x27;./common/request.js&#x27;;Vue.prototype.$H = $H 5.组件使用，login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;view&gt; &lt;view class=&quot;text-center&quot; style=&quot;padding-top: 130rpx;padding-bottom: 70rpx;font-size: 55rpx;&quot;&gt;账号密码登录&lt;/view&gt; &lt;view class=&quot;px-2&quot;&gt; &lt;template&gt; &lt;view class=&quot;mb-2&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; placeholder=&quot;昵称/手机号/邮箱&quot; class=&quot;border-bottom p-2&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;mb-2 flex align-stretch&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入密码&quot; class=&quot;border-bottom p-2 flex-1&quot;/&gt; &lt;view class=&quot;border-bottom flex align-center justify-center font text-muted&quot; style=&quot;width: 150rpx;&quot;&gt;忘记密码？&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;/view&gt; &lt;view class=&quot;py-2 px-3&quot;&gt; &lt;button class=&quot;text-white&quot; style=&quot;border-radius: 50rpx;border: 0;&quot; type=&quot;primary&quot; :disabled=&quot;disabled&quot; :class=&quot;disabled ? &#x27;bg-main-disabled&#x27;:&#x27;bg-main&#x27;&quot; @click=&quot;submit&quot; :loading=&quot;loading&quot;&gt; 登录 &lt;/button&gt; &lt;/view&gt; &lt;view class=&quot;flex align-center justify-center pt-2 pb-4&quot;&gt; &lt;view class=&quot;text-primary font-sm&quot; @click=&quot;changeStatus&quot;&gt; &#123;&#123;status?&#x27;账号密码登录&#x27;:&#x27;验证码登陆&#x27;&#125;&#125; &lt;/view&gt; &lt;text class=&quot;text-muted mx-2&quot;&gt;|&lt;/text&gt; &lt;view class=&quot;text-primary font-sm&quot;&gt;登录遇到问题&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;flex align-center justify-center&quot;&gt; &lt;view style=&quot;height: 1rpx;background-color: #dddddd;width: 100rpx;&quot;&gt;&lt;/view&gt; &lt;view class=&quot;mx-2 text-muted&quot;&gt;社交账号登录&lt;/view&gt; &lt;view style=&quot;height: 1rpx;background-color: #dddddd;width: 100rpx;&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;flex align-center justify-center text-muted&quot;&gt; 注册即代表同意&lt;text class=&quot;text-primary&quot;&gt;《xxx社区协议》&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; &#125;, data() &#123; return &#123; username:&quot;&quot;, password:&quot;&quot; &#125; &#125;, methods: &#123; // 提交 submit()&#123; let data =&#123; username:this.username, password:this.password &#125; // 提交后端 this.$H.post(url,data).then(res=&gt;&#123; console.log(res); // 修改vuex的state,持久化存储 this.$store.commit(&#x27;login&#x27;,res) uni.showToast(&#123; title: &#x27;登录成功&#x27;, icon: &#x27;none&#x27; &#125;); &#125;).catch(err=&gt;&#123; // 登录失败 console.log(&#x27;登陆失败&#x27;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 最终效果： 五、（页面跳转、本地数据缓存）uniapp页面跳转方式 1. uni.navigateTo(object) 保留当前页面，跳转到新页面，使用uni.navigateBack()可以返回到原页面。 navigator 组件跳转： 123456789101112131415161718192021222324252627// 跳转到 /pages/info/index.vue页面，注意此页面不可以是tabBar页面&lt;navigator url=&quot;/pages/info/index?key=100&amp;key2=300&quot; open-type=&quot;navigate&quot;&gt; &lt;view class=&quot;uni-link-item&quot;&gt;点我跳转&lt;/view&gt;&lt;/navigator&gt;// /pages/info/index.vue页面接受参数export default &#123; onLoad: function (option) &#123; //option为object类型，会序列化上个页面传递的参数 console.log(option.key); //打印出上个页面传递的参数。 console.log(option.key2); //打印出上个页面传递的参数。 &#125;&#125;// 在起始页面跳转到../components/test.vue页面并传递item=&#123;name:&quot;kity&quot;,id:1&#125; 参数,注意url有长度限制，过长会导致参数传递失败，可用encodeURIComponent方式解决。&lt;navigator :url=&quot;&#x27;/pages/info/index?item=&#x27;+ encodeURIComponent(JSON.stringify(item))&quot; open-type=&quot;navigate&quot;&gt; 点我跳转&lt;/navigator&gt;export default &#123; // 接受参数 onLoad: function (option) &#123; //解码后，并转换成对象 const item = JSON.parse(decodeURIComponent(option.item)); &#125; &#125; @tap事件调用API跳转转 1234567891011121314//在起始页面跳转到../components/test.vue页面并传递参数uni.navigateTo(&#123; url: &#x27;../components/test?id=1&amp;name=uniapp&#x27;&#125;);// 在test.vue页面接受参数export default &#123; onLoad: function (option) &#123; //option为object类型，会序列化上个页面传递的参数 console.log(option.id); //打印出上个页面传递的参数。 console.log(option.name); //打印出上个页面传递的参数。 &#125;&#125; 2. uni.redirectTo(object) 在当前页面打开，关闭当前页面，跳转到应用内的某个页面。不可以使用uni.navigateBack()可以返回到原页面。 3. uni.reLaunch(object) 关闭所有页面，打开到应用内的某个页面。不可以使用uni.navigateBack()可以返回到原页面。 4. uni.switchTab(object) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。 1234567891011121314151617181920212223pages.json&#123; &quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;pages/other/other&quot;, &quot;text&quot;: &quot;其他&quot; &#125;] &#125;&#125;other.vueuni.switchTab(&#123; url: &#x27;/pages/index/index&#x27;&#125;); 5. uni.navigateBack(object) 返回上一个页面 1234567891011121314151617181920// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码// 此处是A页面uni.navigateTo(&#123; url: &#x27;B?id=1&#x27;&#125;);// 此处是B页面uni.navigateTo(&#123; url: &#x27;C?id=1&#x27;&#125;);// 在C页面内 navigateBack，将返回A页面uni.navigateBack(&#123; delta: 2&#125;);//如上 A--&gt;B--&gt;C , C返回A 6. uni.preloadPage(object) 预加载页面，是一种性能优化技术。被预载的页面，在打开时速度更快。 支持性不好，慎用 1234预加载 /pages/test/test 对应的js文件，不执行页面预渲染逻辑uni.preloadPage(&#123;url: &quot;/pages/test/test&quot;&#125;); 示例 1234uni.preloadPage(&#123;url: &quot;/pages/test/test&quot;&#125;); // 预加载 /pages/test/test 页面（仅触发onLoad，onReady)uni.navigateTo(&#123;url: &quot;/pages/test/test&quot;&#125;); // url匹配，跳转预加载页面（仅触发onShow)uni.navigateTo(&#123;url: &quot;/pages/test/test?a=b&quot;&#125;); // url不匹配，正常打开新页面 想看更多请进入官网：https://uniapp.dcloud.io/api/router?id=navigateto 本地数据缓存 1. uni.setStorage(object) 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 12345678uni.setStorage(&#123; key: &#x27;storage_key&#x27;, data: &#x27;hello&#x27;, success: function () &#123; console.log(&#x27;success&#x27;); &#125;&#125;); 2. uni.setStorageSync(KEY,DATA) 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 123456try &#123; uni.setStorageSync(&#x27;storage_key&#x27;, &#x27;hello&#x27;);&#125; catch (e) &#123; // error&#125; 3. uni.getStorageSync(KEY) 从本地缓存中同步获取指定 key 对应的内容。 12345678910try &#123; const value = uni.getStorageSync(&#x27;storage_key&#x27;); if (value) &#123; console.log(value); &#125;&#125; catch (e) &#123; // error&#125; 4. uni.removeStorageSync(KEY) 从本地缓存中同步移除指定 key。 5. uni.clearStorageSync()123456try &#123; uni.removeStorageSync(&#x27;storage_key&#x27;);&#125; catch (e) &#123; // error&#125; 同步清理本地数据缓存。 123456try &#123; uni.clearStorageSync();&#125; catch (e) &#123; // error&#125; 六、（常用事件、生命周期）uniapp的生命周期1. 应用级生命周期App.vue内定义的钩子函数就是应用生命周期钩子函数首次加载页面是触发 2. 页面级生命周期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;template&gt; &lt;view ref=&quot;ref&quot; class=&quot;test-container&quot;&gt; &lt;text&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;button @click=&quot;addMsg&quot;&gt;点击&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState, mapMutations &#125; from &#x27;vuex&#x27;; var key = 0; export default &#123; data() &#123; return &#123; message: 1 &#125; &#125;, computed: &#123; &#125;, methods: &#123; addMsg() &#123; this.message++ &#125; &#125;, beforeCreate() &#123; console.group(&#x27;beforeCreate 组件创建之前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, onLoad() &#123; console.group(&#x27;onLoad 状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, onShow() &#123; console.group(&#x27;onShow 状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, onReady() &#123; console.group(&#x27;onReady 状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, onUnload() &#123; console.group(&#x27;onUnload 状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot; , &quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125;, created() &#123; console.group(&#x27;created 组件创建完毕状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeMount() &#123; console.group(&#x27;beforeMount 组件挂载之前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + (this.$el)); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, mounted() &#123; console.group(&#x27;mounted 组件挂载完毕状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeUpdate() &#123; console.group(&#x27;beforeUpdate 组件更新之前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, updated() &#123; console.group(&#x27;updated 组件更新完毕状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, beforeDestroy() &#123; console.group(&#x27;beforeDestroy 组件销毁之前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message); &#125;, destroyed() &#123; console.group(&#x27;destroyed 组件销毁完毕状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;,&quot;message: &quot; + this.message) &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; .test-container &#123; width: 100%; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; box-sizing: border-box; padding: 0upx 40upx; button &#123; margin-top: 100upx; &#125; &#125;&lt;/style&gt; 首次进入页面时：点击按钮修改数据时： 总结Page页面生命周期函数执行顺序 beforeCreate &#x3D;&gt; onLoad &#x3D;&gt; onShow &#x3D;&gt; created &#x3D;&gt; beforeMount &#x3D;&gt; onReady &#x3D;&gt; mounted 刷新数据后 beforeUpdate &#x3D;&gt; updated 七、（下拉刷新、上拉加载）下拉刷新定义 onPullDownRefresh 处理函数（和onLoad等生命周期函数同级），监听该页面用户下拉刷新事件。 需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh。 在组件中使用下拉刷新： 上拉加载 onReachBottom页面滚动到底部的事件（不是scroll-view滚到底），常用于上拉加载下一页数据。如使用scroll-view导致页面级没有滚动，则触底事件不会被触发 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;view class=&quot;box&quot;&gt; &lt;view v-for=&quot;(item, index) in newsList&quot; class=&quot;newslist&quot;&gt; &lt;view class=&quot;item&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;loading&quot;&gt;&#123;&#123;loadingText&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;var _self, page = 1, timer = null;export default &#123; data()&#123; return&#123; newsList:[], loadingText:&#x27;加载中...&#x27; &#125; &#125;, //页面加载 onLoad()&#123; _self = this; //获取首页数据 this.getnewsList() &#125;, // 下拉刷新,初始化第一页数据 onPullDownRefresh()&#123; this.getnewsList(); &#125;, //页面滚动到底部的事件 onReachBottom()&#123; if(timer != null)&#123; clearTimeout(timer); &#125; timer = setTimeout(function()&#123; //加载更多数据 _self.getmorenews(); &#125;, 1000); &#125;, methods:&#123; getmorenews()&#123; if(_self.loadingText != &#x27;&#x27; &amp;&amp; _self.loadingText != &#x27;加载更多&#x27;)&#123; return false; &#125; _self.loadingText = &#x27;加载中...&#x27;; //在当前页面显示导航条加载动画。 uni.showNavigationBarLoading(); uni.request(&#123; url: &#x27;https://ceshi2.dishait.cn/api/v1/postclass/1/post/&#x27;+page, method: &#x27;GET&#x27;, success: function(res)&#123; _self.loadingText = &#x27;&#x27;; if(res.data == null)&#123; //在当前页面隐藏导航条加载动画。 uni.hideNavigationBarLoading(); _self.loadingText = &#x27;已加载全部&#x27;; return false; &#125; page++; console.log(res); _self.newsList = _self.newsList.concat(res.data.data.list); _self.loadingText = &#x27;加载更多&#x27;; uni.hideNavigationBarLoading(); &#125; &#125;); &#125;, getnewsList()&#123; page = 1; uni.showNavigationBarLoading(); uni.request(&#123; url: `https://ceshi2.dishait.cn/api/v1/postclass/1/post/$&#123;page&#125;`, method: &#x27;GET&#x27;, success: function(res)&#123; console.log(res) page++; _self.newsList = res.data.data.list; uni.hideNavigationBarLoading(); uni.stopPullDownRefresh(); _self.loadingText = &#x27;加载更多&#x27;; &#125; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .box&#123; width: 100vw; height: 100vh; &#125; .item&#123; width: 100vw; height: 200rpx; border: 1rpx solid gray; text-align: center; line-height: 200rpx; &#125; .loading&#123; text-align: center; color: #8F8F94; &#125;&lt;/style&gt; 效果如图： 八、小程序打包发布1、在项目的manifest.json中选择小程序,配置AppID 2、在微信小程序后台配置线上合法域名登陆微信公众平台–&gt;开发—-&gt;开发设置—&gt;服务器域名添加项目用到的域名\\3. 打包，HbuilderX 发行—&gt;小程序 填写小程序名，和APPId，点击发行。(这里的小程序名字是无意义的，但是要有，具体的小程序名字是在微信公众平台配置的。)接下来会在项目根目录下生产unpackage—&gt;dist—build—mp-weixin目录小程序开发者工具会自动启动点击开发者工具右上角 上传 填写版本号，备注，点击上传。此控制台报错，上传失败改： 这样每次编译系统自动会生成sitemap.json然后重新点击上传。提示上传成功(每个包不能超过2M，整个程序不能超过12M) 登陆微信小程序公众平台 提交审核通过后 ，点击前往发布。上线完毕","categories":[],"tags":[]},{"title":"从零玩转第三方登录之QQ登录","slug":"从零玩转第三方登录之QQ登录","date":"2022-09-01T01:59:17.000Z","updated":"2022-09-01T01:59:25.512Z","comments":true,"path":"2022/09/01/从零玩转第三方登录之QQ登录/","link":"","permalink":"http://example.com/2022/09/01/%E4%BB%8E%E9%9B%B6%E7%8E%A9%E8%BD%AC%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E4%B9%8BQQ%E7%99%BB%E5%BD%95/","excerpt":"","text":"从零玩转第三方登录之QQ登录前言在真正开始对接之前，我们先来聊一聊后台的方案设计。既然是对接第三方登录，那就免不了如何将用户信息保存。首先需要明确一点的是，用户在第三方登录成功之后，我们能拿到的仅仅是一个代表用户唯一身份的ID（微博是真实uid，QQ是加密的openID）以及用来识别身份的accessToken，当然还有昵称、头像、性别等有限资料，对接第三方登录的关键就是如何确定用户是合法登录，如果确定这次登录的和上次登录的是同一个人并且不是假冒的。其实这个并不用我们特别操心，就以微博登录为例，用户登录成功之后会回调一个code给我们，然后我们再拿code去微博那换取 accessToken ，如果这个code是用户乱填的，那这一关肯定过不了，所以，前面的担心有点多余，哈哈。 1. 认识Oauth2.0现在很多网站都要不管是为了引流也好，为了用户方便也好一般都有第三方账号登陆的需求，今天以QQ登陆为例，来实现一个最简单的第三方登陆。目前主流的第三方登录都是依赖的Oauth2.0实现的，最常见的就是在各种中小型网站或者App中的QQ登录，微信登录等等。所以我建议想要学习和实现第三方登录同学去了解下这个协议。 必须要域名并且进行备案比如我的域名： https://lianlihe.com因为腾讯有一个域名认证机制啥的。。。。。。 2.实名认证QQ登录我们对接的是QQ互联，地址：https://connect.qq.com ,首先需要注册成为开发者并实名认证，需要手持身份证照片，具体就不讲了。 2.1、进行申请开发者身份2.2 创建应用进入应用管理页面创建应用，根据实际需要是创建网站应用还是移动应用，我这里是网站应用： 提交成功完步后等待客服审核即可 这是我网站的基本接口信息 QQ登陆流程 请求参数 创建springboot工程依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!-- qq登陆集成 开始 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpasyncclient&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--json转换工具--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--QQSDK--&gt;&lt;dependency&gt; &lt;groupId&gt;net.gplatform&lt;/groupId&gt; &lt;artifactId&gt;Sdk4J&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;&lt;!-- qq登陆集成 结束 --&gt;&lt;!-- 模板 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 其它配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ***&lt;已自动折叠&gt;*** 创建http请求工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311import com.alibaba.fastjson.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.ssl.SSLContextBuilder;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;import java.security.GeneralSecurityException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class HttpsUtils &#123; private static PoolingHttpClientConnectionManager connMgr; private static RequestConfig requestConfig; private static final int MAX_TIMEOUT = 7000; private static final Logger logger = LoggerFactory.getLogger(HttpsUtils.class); static &#123; // 设置连接池 connMgr = new PoolingHttpClientConnectionManager(); // 设置连接池大小 connMgr.setMaxTotal(100); connMgr.setDefaultMaxPerRoute(connMgr.getMaxTotal()); // Validate connections after 1 sec of inactivity connMgr.setValidateAfterInactivity(1000); RequestConfig.Builder configBuilder = RequestConfig.custom(); // 设置连接超时 configBuilder.setConnectTimeout(MAX_TIMEOUT); // 设置读取超时 configBuilder.setSocketTimeout(MAX_TIMEOUT); // 设置从连接池获取连接实例的超时 configBuilder.setConnectionRequestTimeout(MAX_TIMEOUT); requestConfig = configBuilder.build(); &#125; /** * 发送 GET 请求（HTTP），不带输入数据 * * @param url * @return */ public static String doGet(String url) &#123; return doGet(url, new HashMap&lt;String, Object&gt;()); &#125; /** * 发送 GET 请求（HTTP），K-V形式 * * @param url * @param params * @return */ public static String doGet(String url, Map&lt;String, Object&gt; params) &#123; String apiUrl = url; StringBuffer param = new StringBuffer(); int i = 0; for (String key : params.keySet()) &#123; if (i == 0) param.append(&quot;?&quot;); else param.append(&quot;&amp;&quot;); param.append(key).append(&quot;=&quot;).append(params.get(key)); i++; &#125; apiUrl += param; String result = null; HttpClient httpClient = null; if (apiUrl.startsWith(&quot;https&quot;)) &#123; httpClient = HttpClients.custom().setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr).setDefaultRequestConfig(requestConfig).build(); &#125; else &#123; httpClient = HttpClients.createDefault(); &#125; try &#123; HttpGet httpGet = new HttpGet(apiUrl); HttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); if (entity != null) &#123; InputStream instream = entity.getContent(); result = new BufferedReader(new InputStreamReader(instream)).lines().collect(Collectors.joining(System.lineSeparator())); &#125; &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; return result; &#125; /** * 发送 POST 请求（HTTP），不带输入数据 * * @param apiUrl * @return */ public static String doPost(String apiUrl) &#123; return doPost(apiUrl, new HashMap&lt;String, Object&gt;()); &#125; /** * 发送 POST 请求，K-V形式 * * @param apiUrl API接口URL * @param params 参数map * @return */ public static String doPost(String apiUrl, Map&lt;String, Object&gt; params) &#123; CloseableHttpClient httpClient = null; if (apiUrl.startsWith(&quot;https&quot;)) &#123; httpClient = HttpClients.custom().setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr).setDefaultRequestConfig(requestConfig).build(); &#125; else &#123; httpClient = HttpClients.createDefault(); &#125; String httpStr = null; HttpPost httpPost = new HttpPost(apiUrl); CloseableHttpResponse response = null; try &#123; httpPost.setConfig(requestConfig); List&lt;NameValuePair&gt; pairList = new ArrayList&lt;&gt;(params.size()); for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) &#123; NameValuePair pair = new BasicNameValuePair(entry.getKey(), entry.getValue().toString()); pairList.add(pair); &#125; httpPost.setEntity(new UrlEncodedFormEntity(pairList, Charset.forName(&quot;UTF-8&quot;))); response = httpClient.execute(httpPost); HttpEntity entity = response.getEntity(); httpStr = EntityUtils.toString(entity, &quot;UTF-8&quot;); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; finally &#123; if (response != null) &#123; try &#123; EntityUtils.consume(response.getEntity()); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; &#125; &#125; return httpStr; &#125; /** * 发送 POST 请求，JSON形式 * * @param apiUrl * @param json json对象 * @return */ public static String doPost(String apiUrl, Object json) &#123; CloseableHttpClient httpClient = null; if (apiUrl.startsWith(&quot;https&quot;)) &#123; httpClient = HttpClients.custom().setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr).setDefaultRequestConfig(requestConfig).build(); &#125; else &#123; httpClient = HttpClients.createDefault(); &#125; String httpStr = null; HttpPost httpPost = new HttpPost(apiUrl); CloseableHttpResponse response = null; try &#123; httpPost.setConfig(requestConfig); StringEntity stringEntity = new StringEntity(json.toString(), &quot;UTF-8&quot;);// 解决中文乱码问题 stringEntity.setContentEncoding(&quot;UTF-8&quot;); stringEntity.setContentType(&quot;application/json&quot;); httpPost.setEntity(stringEntity); response = httpClient.execute(httpPost); HttpEntity entity = response.getEntity(); httpStr = EntityUtils.toString(entity, &quot;UTF-8&quot;); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; finally &#123; if (response != null) &#123; try &#123; EntityUtils.consume(response.getEntity()); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; &#125; &#125; return httpStr; &#125; /** * 创建SSL安全连接 * * @return */ private static SSLConnectionSocketFactory createSSLConnSocketFactory() &#123; SSLConnectionSocketFactory sslsf = null; try &#123; SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() &#123; @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;).build(); sslsf = new SSLConnectionSocketFactory(sslContext, new HostnameVerifier() &#123; @Override public boolean verify(String arg0, SSLSession arg1) &#123; return true; &#125; &#125;); &#125; catch (GeneralSecurityException e) &#123; logger.error(e.getMessage()); &#125; return sslsf; &#125; /*gitHub开始*/ /** * 发送get请求，利用java代码发送请求 * @param url * @return * @throws Exception */ public static String doGetHub(String url) throws Exception&#123; CloseableHttpClient httpclient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(url); // 发送了一个http请求 CloseableHttpResponse response = httpclient.execute(httpGet); // 如果响应200成功,解析响应结果 if(response.getStatusLine().getStatusCode()==200)&#123; // 获取响应的内容 HttpEntity responseEntity = response.getEntity(); return EntityUtils.toString(responseEntity); &#125; return null; &#125; /** * 将字符串转换成map * @param responseEntity * @return */ public static Map&lt;String,String&gt; getMap(String responseEntity) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 以&amp;来解析字符串 String[] result = responseEntity.split(&quot;\\\\&amp;&quot;); for (String str : result) &#123; // 以=来解析字符串 String[] split = str.split(&quot;=&quot;); // 将字符串存入map中 if (split.length == 1) &#123; map.put(split[0], null); &#125; else &#123; map.put(split[0], split[1]); &#125; &#125; return map; &#125; /** * 通过json获得map * @param responseEntity * @return */ public static Map&lt;String,String&gt; getMapByJson(String responseEntity) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 阿里巴巴fastjson 将json转换成map JSONObject jsonObject = JSONObject.parseObject(responseEntity); for (Map.Entry&lt;String, Object&gt; entry : jsonObject.entrySet()) &#123; String key = entry.getKey(); // 将obj转换成string String value = String.valueOf(entry.getValue()) ; map.put(key, value); &#125; return map; &#125; /*gitHub结束*/ &#125; ***&lt;已自动折叠&gt;*** 创建跨域配置类 以防万一出现跨域问题123456789101112131415161718192021222324import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsAutoConfig &#123; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); // 表示什么域名跨域 *表示全部都跨域 corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 注入进去 urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); CorsFilter corsFilter = new CorsFilter(urlBasedCorsConfigurationSource); return corsFilter; &#125;&#125; 创建Logincontroller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.google.gson.Gson;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import top.yangbuyi.QQ.OAuthProperties;import top.yangbuyi.QQ.vo.QQDTO;import top.yangbuyi.QQ.vo.QQOpenidDTO;import top.yangbuyi.common.HttpsUtils;import javax.management.RuntimeErrorException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.websocket.server.PathParam;import java.io.IOException;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.UUID;@Controller@Slf4j@RequestMapping(&quot;api&quot;)public class loginController &#123; /** * 认证参数 */ @Autowired private OAuthProperties oauth; /** * 调用QQ登陆接口 * 流程： 先调用接口获取code，在根据code获取access_token,在根据token获取对应的用户信息 * @param response */ @GetMapping(&quot;/login/oauth&quot;) public void loginQQ( HttpServletResponse response) &#123; // 重定向访问QQ登录服务器 try &#123; response.sendRedirect(oauth.getQQ().getCode_callback_uri() + //获取code码地址 &quot;?client_id=&quot; + oauth.getQQ().getClient_id() //appid +&quot;&amp;state=&quot; + UUID.randomUUID() + //这个说是防攻击的，就给个随机uuid吧 &quot;&amp;redirect_uri=&quot; + oauth.getQQ().getRedirect_uri() +//这个很重要，这个是回调地址，即就收腾讯返回的code码 &quot;&amp;response_type=code&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 在qq平台设置的回调地址 * * 接收回调地址带过来的code码 * * @param code * @param request * @return */ @GetMapping(&quot;/oauth2&quot;) public String authorizeQQ(String code, HttpServletRequest request) &#123; HashMap&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;code&quot;, code); params.put(&quot;grant_type&quot;, &quot;authorization_code&quot;); params.put(&quot;redirect_uri&quot;, oauth.getQQ().getRedirect_uri()); params.put(&quot;client_id&quot;, oauth.getQQ().getClient_id()); params.put(&quot;client_secret&quot;, oauth.getQQ().getClient_secret()); // 获取腾讯access token Map&lt;String, String&gt; reulsts = getAccess_token(params); System.out.println(&quot;遍历拿到的数据:&quot;); for (Map.Entry&lt;String, String&gt; entry : reulsts.entrySet()) &#123; System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue()); &#125; System.out.println(&quot;遍历完毕&quot;); //到这里access_token已经处理好了 //下一步获取openid，只有拿到openid才能拿到用户信息 String openidContent = HttpsUtils.doGet(oauth.getQQ().getOpenid_callback_uri() + &quot;?access_token=&quot; + reulsts.get(&quot;access_token&quot;)); // callback( &#123;&quot;client_id&quot;:&quot;101887062&quot;,&quot;openid&quot;:&quot;74DD1353321FD56375F34422D833848D&quot;&#125; ); System.out.println(&quot;openidContent: &quot; + openidContent); //接下来对openid进行处理 //截取需要的那部分json字符串 String openid = openidContent.substring(openidContent.indexOf(&quot;&#123;&quot;), openidContent.indexOf(&quot;&#125;&quot;) + 1); // json 转 对象 Gson gson = new Gson(); //将返回的openid转换成DTO QQOpenidDTO qqOpenidDTO = gson.fromJson(openid, QQOpenidDTO.class); // 封装参数 请求用户信息数据 params.clear(); //设置access_token params.put(&quot;access_token&quot;, reulsts.get(&quot;access_token&quot;)); //设置openid params.put(&quot;openid&quot;, qqOpenidDTO.getOpenid()); //设置appid params.put(&quot;oauth_consumer_key&quot;, qqOpenidDTO.getClient_id()); //获取用户信息 String userInfo = HttpsUtils.doGet(oauth.getQQ().getUser_info_callback_uri(), params); QQDTO qqDTO = gson.fromJson(userInfo, QQDTO.class); // （正常情况下，在开发时候用openid作为用户名，再自己定义个密码就可以了） try &#123; /* 组装数据 */ HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;user&quot;, qqDTO); map.put(&quot;qqOpenidDTO&quot;, qqOpenidDTO); request.setAttribute(&quot;map&quot;, map); log.info(&quot;user数据:&#123;&#125;&quot; + qqDTO); log.info(&quot;qqOpenidDTO数据:&#123;&#125;&quot; + qqOpenidDTO); return &quot;home&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;login&quot;; &#125; &#125; /** * 获取腾讯 access_token * * @return */ public Map&lt;String, String&gt; getAccess_token(HashMap&lt;String, Object&gt; params) &#123; // 认证地址 //获取access_token如：access_token=9724892714FDF1E3ED5A4C6D074AF9CB&amp;expires_in=7776000&amp;refresh_token=9E0DE422742ACCAB629A54B3BFEC61FF String result = HttpsUtils.doGet(oauth.getQQ().getAccess_token_callback_uri(), params); //对拿到的数据进行切割字符串 String[] strings = result.split(&quot;&amp;&quot;); //切割好后放进map Map&lt;String, String&gt; reulsts = new HashMap&lt;&gt;(); for (String str : strings) &#123; String[] split = str.split(&quot;=&quot;); if (split.length &gt; 1) &#123; reulsts.put(split[0], split[1]); &#125; &#125; return reulsts; &#125;&#125; ***&lt;已自动折叠&gt;*** 创建QQ参数实体类创建 OAuthProperties 用于配合yml配置文件动态获取参数1234567891011121314151617181920212223import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * 获取Code码 **/@Component//对应application.yml中，oauth下参数@ConfigurationProperties(prefix = &quot;oauth&quot;)public class OAuthProperties &#123; //获取applicaiton.yml下qq下所有的参数 private QQProperties qq = new QQProperties(); public QQProperties getQQ() &#123; return qq; &#125; public void setQQ(QQProperties qq) &#123; this.qq = qq; &#125;&#125; 创建 QQProperties 用于请求qq的参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546import lombok.Data;import org.springframework.stereotype.Component;/** * 集成第三方登陆 QQ 参数 **/@Data@Componentpublic class QQProperties &#123; /** * 你的appid */ private String client_id; /** * #你的appkey */ private String client_secret; /** * 你接收响应code码地址 */ private String redirect_uri; /** * 腾讯获取code码地址 */ private String code_callback_uri; /** * 腾讯获取access_token地址 */ private String access_token_callback_uri; /** * 腾讯获取openid地址 */ private String openid_callback_uri; /** * 腾讯获取用户信息地址 */ private String user_info_callback_uri; /** * 要回调到哪个网站 */ private String redirect_url_index_yby; private String redirect_url_login_yby; &#125; ***&lt;已自动折叠&gt;*** 创建 QQOpenidDTO 用于获取 access_token、openid12345678910import lombok.Data;public class QQOpenidDTO &#123; private String openid; private String client_id; &#125; 创建QQDTO 接收QQ返回来的json参数1234567891011121314151617181920212223import lombok.Data;@Datapublic class QQDTO &#123; private String ret; //返回码 private String msg; //如果ret&lt;0，会有相应的错误信息提示，返回数据全部用UTF-8编码。 private String nickname; //用户在QQ空间的昵称。 private String figureurl; //大小为30×30像素的QQ空间头像URL。 private String figureurl_1; //大小为50×50像素的QQ空间头像URL。 private String figureurl_2; //大小为100×100像素的QQ空间头像URL。 private String figureurl_qq_1; //大小为40×40像素的QQ头像URL。 private String figureurl_qq_2; //大小为100×100像素的QQ头像URL。需要注意，不是所有的用户都拥有QQ的100x100的头像，但40x40像素则是一定会有。 private String gender; //性别。 如果获取不到则默认返回&quot;男&quot; private Integer gendertype; // 性别 数字 private String is_yellow_vip; //标识用户是否为黄钻用户（0：不是；1：是）。 private String vip; //标识用户是否为黄钻用户（0：不是；1：是） private String yellow_vip_level; //黄钻等级 private String level; //黄钻等级 private String is_yellow_year_vip; //标识是否为年费黄钻用户（0：不是； 1：是） private String province; // 省 private String city; // 市&#125; ***&lt;已自动折叠&gt;*** 示例 创建前端请求跳转 controller12345678910111213141516@Controller@Slf4jpublic class RequestController &#123; @RequestMapping(&quot;login&quot;) public String login() &#123; System.out.println(&quot;登陆进来啦&quot;); return &quot;login&quot;; &#125; @RequestMapping(&quot;home&quot;) public String home() &#123; return &quot;home&quot;; &#125;&#125; 创建前端页面 login.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 登录地址 action=&quot;/api/login/oauth&quot;--&gt;&lt;form action=&quot;/api/login/oauth&quot;&gt; &lt;input type=&quot;submit&quot; style=&quot;background: red;size: 25px&quot; value=&quot;登陆&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; home.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;&quot;&gt; &lt;label class=&quot;&quot;&gt;登陆成功&lt;/label&gt; &lt;div class=&quot;&quot;&gt; &lt;p th:text=&quot;&#x27;openID :&#x27; + $&#123;map.qqOpenidDTO.openid&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;&#x27;用户名称 :&#x27; + $&#123;map.user.nickname&#125;&quot;&gt;&lt;/p&gt; 用户头像: &lt;img th:src=&quot;$&#123;map.user.figureurl_qq_1&#125;&quot; alt=&quot;&quot;&gt; &lt;br&gt; &lt;img th:src=&quot;$&#123;map.user.figureurl_qq_1&#125;&quot; alt=&quot;&quot;&gt; &lt;img th:src=&quot;$&#123;map.user.figureurl_qq_2&#125;&quot; alt=&quot;&quot;&gt; 性别: &lt;p th:text=&quot;$&#123;map.user.gender&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;map.user.vip&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;map.user.yellow_vip_level&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;map.user.is_yellow_year_vip&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;map.user.province&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;map.user.city&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--参数列表:--&gt;&lt;!--private String ret; //返回码--&gt;&lt;!--private String msg; //如果ret&lt;0，会有相应的错误信息提示，返回数据全部用UTF-8编码。--&gt;&lt;!--private String nickname; //用户在QQ空间的昵称。--&gt;&lt;!--private String figureurl; //大小为30×30像素的QQ空间头像URL。--&gt;&lt;!--private String figureurl_1; //大小为50×50像素的QQ空间头像URL。--&gt;&lt;!--private String figureurl_2; //大小为100×100像素的QQ空间头像URL。--&gt;&lt;!--private String figureurl_qq_1; //大小为40×40像素的QQ头像URL。--&gt;&lt;!--private String figureurl_qq_2; //大小为100×100像素的QQ头像URL。需要注意，不是所有的用户都拥有QQ的100x100的头像，但40x40像素则是一定会有。--&gt;&lt;!--private String gender; //性别。 如果获取不到则默认返回&quot;男&quot;--&gt;&lt;!--private Integer gendertype; // 性别 数字--&gt;&lt;!--private String is_yellow_vip; //标识用户是否为黄钻用户（0：不是；1：是）。--&gt;&lt;!--private String vip; //标识用户是否为黄钻用户（0：不是；1：是）--&gt;&lt;!--private String yellow_vip_level; //黄钻等级--&gt;&lt;!--private String level; //黄钻等级--&gt;&lt;!--private String is_yellow_year_vip; //标识是否为年费黄钻用户（0：不是； 1：是）--&gt;&lt;!--private String province; // 省--&gt;&lt;!--private String city; // 市--&gt;&lt;/body&gt;&lt;/html&gt; ***&lt;已自动折叠&gt;*** 启动注意事项必须要打包到服务器启动QQ才能回调 项目部署方案一: 点击package 打包 修改application.yml 中的端口为 80运行 Java程序 1java -jar qqlogindemo-0.0.1-SNAPSHOT.jar 启动成功 访问 login 页面 点击登录 》 QQ扫码或者密码登录 》 登录成功 跳转到 home","categories":[],"tags":[]},{"title":"nacos数据源配置","slug":"nacos数据源配置","date":"2022-09-01T01:42:02.000Z","updated":"2022-09-01T01:42:08.858Z","comments":true,"path":"2022/09/01/nacos数据源配置/","link":"","permalink":"http://example.com/2022/09/01/nacos%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/","excerpt":"","text":"nacos设置数据源mysqlnacos配置 将其中数据源类型，url，用户名密码等改成mysql相关 123456789101112spring.datasource.platform=mysql### Count of DB:db.num=1### Connect URL of DB:db.url.0=jdbc:mysql://192.168.5.1:3306/db1?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=root 更改mysql允许远程用户访问1234567891011#登录mysqlmysql -u root -p#切换数据库mysql&gt; use mysql;#更改root用户，允许通过root用户远程访问mysql&gt;update user set host = ’%’ where user = ’root’;#设置所有db均可通过root访问mysql&gt; grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27;#刷新赋予的权限mysql&gt;flush privileges; 增加windows入站规则 因mysql安装在win10上，如果不想关闭防火墙，那么设置一个防火墙入站规则，使得远程可以访问本机的3306端口 控制面板&gt;防火墙&gt;高级设置&gt;增加入站规则&gt;选择端口类型并填写端口&gt;选择tcp连接&gt;保存","categories":[],"tags":[]},{"title":"Xshell使用public_key进行登录","slug":"Xshell使用public-key进行登录","date":"2022-08-20T03:23:44.000Z","updated":"2022-08-20T03:23:49.706Z","comments":true,"path":"2022/08/20/Xshell使用public-key进行登录/","link":"","permalink":"http://example.com/2022/08/20/Xshell%E4%BD%BF%E7%94%A8public-key%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95/","excerpt":"","text":"Xshell使用public_key进行登录基于Xshell使用密钥(public key)登录ssh Augensternnnn 生成密钥打开Xshell，点击 工具 -&gt; 新建用户密钥生成向导 密钥类型 选择“RSA”公钥加密算法；密钥长度 选择 “2048”位密钥长度 填写密钥名称和密码，进行下一步 复制公钥里面的内容，并保存为文件以备用 放置公钥(Public Key)到服务器~&#x2F;.ssh&#x2F;authorized_key文件中打开云服务器的控制台，创建密钥对 导入已有的密钥对 将密钥添加到主机 重启服务器 打开XShell，连接服务器并输入密钥 选择 用户身份验证，并填写方法 选择：public key，并填写用户名，选择用户密钥（密码为自己之前设置的）","categories":[],"tags":[]},{"title":"腾讯云购买域名备案流程","slug":"腾讯云购买域名备案流程","date":"2022-08-20T03:23:10.000Z","updated":"2022-08-20T03:23:18.247Z","comments":true,"path":"2022/08/20/腾讯云购买域名备案流程/","link":"","permalink":"http://example.com/2022/08/20/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88%E6%B5%81%E7%A8%8B/","excerpt":"","text":"腾讯云购买域名备案流程理解： 1、注册国外域名，但暂时不启用，或作为投资储备，则不需要进行备案；. 2、注册国外域名，绑定国内的服务器空间，则必须进行备案；. 3、注册国外域名，绑定国外的服务器空间，则无需进行备案。. 搜索域名 国内域名需要备案 国外域名不需要备案 搜索自己需要购买的域名有没有被注册掉 选择域名购买的年份 填完付款即可 域名备案 扫码填写信息 一般腾讯会审核2-3天 会打电话来核对你填写的备案信息 确认都无误之后会送到通信管理局审核大概20天左右会审核完成 备案完成之后 进入控制台 解析点进去之后 @代表不需要输入www都能放入 比如我的域名是lilinzhi www.lilinzhi.com可以访问 lilinzhi.com也可以访问 www 公网ip","categories":[],"tags":[]},{"title":"阿里云域名购买和备案流程","slug":"阿里云域名购买和备案流程","date":"2022-08-20T03:22:43.000Z","updated":"2022-08-20T03:22:53.080Z","comments":true,"path":"2022/08/20/阿里云域名购买和备案流程/","link":"","permalink":"http://example.com/2022/08/20/%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0%E5%92%8C%E5%A4%87%E6%A1%88%E6%B5%81%E7%A8%8B/","excerpt":"","text":"阿里云域名购买和备案流程搜索域名进行购买之后 域名实名认证通过后 等待2-3填，才能备案 打开控制台，查看实名认证的进度 点击域名 备案 开始备案 个人申请&#x2F;企业申请 这里以个人申请为例 主办者信息与身份证信息保持一致 地区： 身份证的地区 证件类型：居民身份证 顶级域名不用写www 网站基本信息","categories":[],"tags":[]},{"title":"权限管理系统3","slug":"权限管理系统3","date":"2022-08-20T01:03:10.000Z","updated":"2022-08-20T01:03:43.737Z","comments":true,"path":"2022/08/20/权限管理系统3/","link":"","permalink":"http://example.com/2022/08/20/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3/","excerpt":"","text":"26 角色管理-设置角色权限主要对角色设置对应的权限 弹出页面的效果 form表单 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 设定角色start--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;setRolePermissionModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; &gt;添加角色对应的权限&lt;/h4&gt; &lt;/div&gt; &lt;form id=&quot;addRolePermissionForm&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;addRolePermision_roleId&quot; class=&quot;form-control&quot; name=&quot;id&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;角色名称：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;addRolePermision_name&quot; class=&quot;form-control&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;!-- 角色列表--&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;选择权限：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;label th:each=&quot;permisison : $&#123;permissions&#125;&quot; style=&quot;margin-right: 10px&quot;&gt; &lt;input th:id=&quot;&#x27;pid_&#x27;+$&#123;permisison.id&#125;&quot; name=&quot;permissions[]&quot; type=&quot;checkbox&quot; class=&quot;checkbox-child&quot; th:value=&quot;$&#123;permisison.id&#125;&quot;&gt; &lt;span th:text=&quot;$&#123;permisison.title&#125;&quot;&gt;&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; data-method=&#x27;addRolePermissionSave&#x27; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 设定角色end--&gt; 保存操作： 1234567891011121314151617181920212223242526272829303132333435363738addRolePermissionSave:function()&#123; //添加角色的权限 var addRolePermissionParamObj = $(&quot;#addRolePermissionForm&quot;).serializeObject(); console.log(addRolePermissionParamObj); /** * &#123; * id: &quot;18&quot; permissionId:[1,2] &#125; */ var paramObj = &#123;&quot;roleId&quot;:addRolePermissionParamObj.id,&quot;permissionIds&quot;:addRolePermissionParamObj.permissions&#125;; $.ajax(&#123; type: &quot;post&quot;, url: &quot;/role/addRolePermission&quot;, dataType : &quot;json&quot;, data: JSON.stringify(paramObj), contentType:&#x27;application/json;charset=utf-8&#x27;, success: function (data) &#123; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, action:function()&#123; $(&#x27;#setRolePermissionModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#roleTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125; &#125; &#125; &#125;); &#125; &#125; &#125;); &#125; 后台代码: RoleController.java 12345678910111213141516@RequestMapping(&quot;/role/addRolePermission&quot;) @ResponseBody public MzResult addRolePermission(@RequestBody Map paramMap)&#123; MzResult mzResult = new MzResult(); String roleId = (String)paramMap.get(&quot;roleId&quot;); List permissionIds = (List) paramMap.get(&quot;permissionIds&quot;); try &#123; //添加角色对应的权限 roleService.addRolePermission(roleId,permissionIds); return mzResult; &#125;catch (Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存权限失败&quot;); &#125; &#125; RoleServiceImpl.java 1234567891011121314151617@Override @Transactional public void addRolePermission(String roleId, List permissionIds) &#123; List rolePermissionList = new ArrayList(); for (Object permissionId : permissionIds) &#123; Map mp = new HashMap(); mp.put(&quot;roleId&quot;,roleId); mp.put(&quot;permissionId&quot;,permissionId); rolePermissionList.add(mp); &#125; //先删除角色对应的权限 roleMapper.deleteRolePermission(Long.parseLong(roleId)); //添加角色对应的权限 roleMapper.addRolePermission(rolePermissionList); &#125; RoleMapper.java 12345@Delete(&quot;delete from t_role_permission where roleid = #&#123;roleid&#125;&quot;) void deleteRolePermission(long parseLong); //添加角色对应的权限 void addRolePermission(List rolePermissionList); RoleMapper.xml 12345678910111213&lt;!-- 添加角色的权限--&gt; &lt;insert id=&quot;addRolePermission&quot; parameterType=&quot;java.util.List&quot;&gt; insert into t_role_permission(roleid,permissionid) values &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; (#&#123;item.roleId&#125;,#&#123;item.permissionId&#125;) &lt;/foreach&gt; &lt;/insert&gt; &lt;!-- 删除中间表权限--&gt; &lt;delete id=&quot;deleteRolePermission&quot; parameterType=&quot;java.lang.Long&quot;&gt; delete from t_role_permission where roleid = #&#123;roleid&#125; &lt;/delete&gt; 27 角色管理-删除角色删除功能: 1234567891011121314151617181920212223242526272829303132333435363738394041424344 function del(id)&#123; //发送ajax请求删除数据 $.get(&quot;/role/deleteRole&quot;,&#123;&quot;id&quot;:id&#125;,function(res)&#123; if(res.isSuccess)&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;删除角色成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, &#125; &#125; &#125;); $(&quot;#roleTable&quot;).bootstrapTable(&#x27;refresh&#x27;) &#125; &#125;); &#125;RoleController.java //添加角色 @RequestMapping(&quot;/role/deleteRole&quot;) @ResponseBody public MzResult deleteRole(Long id)&#123; System.out.println(&quot;删除角色....&quot;+id); MzResult ajaxResult = new MzResult(); try &#123; roleService.deleteRole(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return new MzResult(&quot;删除失败&quot;); &#125; return ajaxResult; &#125;RoleServiceImpl.java @Transactional public void deleteRole(Long id) &#123; roleMapper.deleteRole(id); &#125; RoleMapper.java @Delete(&quot;delete from t_role where id=#&#123;id&#125;&quot;) void deleteRole(Long id); 28 角色管理-用户设定角色我们从模板里面可以看出 在设定角色的时候，需要查询所有的角色出来。 12345678910111213&lt;!-- 角色列表--&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;label for=&quot;recipient-name&quot; class=&quot;control-label&quot;&gt;选择权限：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;label th:each=&quot;role : $&#123;roles&#125;&quot; style=&quot;margin-right: 10px&quot;&gt; &lt;input name=&quot;roles[]&quot; type=&quot;checkbox&quot; class=&quot;checkbox-child&quot; th:id=&quot;&#x27;rid_&#x27;+$&#123;role.id&#125;&quot; th:value=&quot;$&#123;role.id&#125;&quot;&gt; &lt;span th:text=&quot;$&#123;role.name&#125;&quot;&gt;&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; 所以我们需要在 一进入页面的时候，就查询角色 1234567891011121314UserController.java @GetMapping(&quot;/index&quot;) public String index(String menuid, Model model)&#123; model.addAttribute(&quot;menuid&quot;,menuid); List&lt;Role&gt; roles = roleService.queryAll(); model.addAttribute(&quot;roles&quot;,roles); //用户首页 return &quot;views/user/user_list&quot;; &#125;UserMapper.java @Select(&quot;select * from t_role&quot;) List&lt;Role&gt; queryAll(); 效果图： 保存用户角色: 1234567891011121314151617181920212223242526272829303132333435363738addUserRoleSave()&#123; //保存用户的角色 var addRoleParamObj = $(&quot;#addUserRoleForm&quot;).serializeObject(); console.log(addRoleParamObj); /** * &#123; * id: &quot;18&quot; roles:[1,2] &#125; */ var paramObj = &#123;&quot;userId&quot;:addRoleParamObj.id,&quot;roleIds&quot;:addRoleParamObj.roles&#125;; $.ajax(&#123; type: &quot;post&quot;, url: &quot;/user/addUserRole&quot;, dataType : &quot;json&quot;, data: JSON.stringify(paramObj), contentType:&#x27;application/json;charset=utf-8&#x27;, success: function (data) &#123; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, action:function()&#123; $(&#x27;#addUserRoleModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#userTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125; &#125; &#125; &#125;); &#125; &#125; &#125;); &#125; 后台java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950UserController.java--------------------------------------------------------------------------------------@PostMapping(&quot;/addUserRole&quot;) @ApiOperation(&quot;添加用户角色接口&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;paramMap&quot;, value = &quot;如:&#123;userId:1,[1,2,3,4]]&#125;&quot;) &#125;) @ResponseBody public MzResult addUserRole(@RequestBody Map paramMap)&#123; MzResult mzResult = new MzResult(); String userId = (String)paramMap.get(&quot;userId&quot;); List roleIds = (List) paramMap.get(&quot;roleIds&quot;); System.out.println(userId); System.out.println(roleIds); try &#123; //添加用户对应的角色 roleService.addUserRole(userId,roleIds); return mzResult; &#125;catch (Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存角色失败&quot;); &#125; &#125;--------------------------------------------------------------------------------- RoleServiceImpl.java @Transactional @Override public void addUserRole(String userId, List roleIds) &#123; List userRolesList = new ArrayList(); for (Object roleId : roleIds) &#123; Map mp = new HashMap(); mp.put(&quot;userId&quot;,userId); mp.put(&quot;roleId&quot;,roleId); userRolesList.add(mp); &#125; //先删除用户角色 roleMapper.deleteUserRole(Long.parseLong(userId)); //添加用户角色 roleMapper.addUserRole(userRolesList); &#125; ------------------------------------------------------------------- ROleMapper.java //删除用户角色 @Delete(&quot;delete from t_user_role where userid = #&#123;userId&#125;&quot;) void deleteUserRole(Long userId); //添加用户角色 void addUserRole(List userRoles); RoleMapper.xml 12345678&lt;!-- 添加用户的角色--&gt; &lt;insert id=&quot;addUserRole&quot; parameterType=&quot;java.util.List&quot;&gt; insert into t_user_role(userid,roleid) values &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; (#&#123;item.userId&#125;,#&#123;item.roleId&#125;) &lt;/foreach&gt; &lt;/insert&gt; 29 权限管理-权限列表同样原理 ，引入权限模块 permission_list.html 新增PermissionController.java类 123456789101112131415@Controllerpublic class PermissionController &#123; @Autowired private IPermissionService permissionService; @PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/permission/index&quot;) public String index(Model model)&#123; List&lt;Permission&gt; allPermisisons = permissionService.findAllPermisisons(); model.addAttribute(&quot;permissions&quot;,allPermisisons); //返回菜单页面 return &quot;views/permission/permission_list&quot;; &#125;&#125; 效果图: 30 权限管理-添加页面按钮权限点击新增的时候，弹出对话框 123456789101112131415161718192021222324252627282930313233343536373839404142saveBtnPermisison:function()&#123; //保存页面按钮权限 var addBtnPermissionFormObj = $(&quot;#addBtnPermissionForm&quot;).serializeObject(); console.log(addBtnPermissionFormObj) /** * name: &quot;test:add&quot; pid: &quot;33&quot; ptitle: &quot;test子菜单1&quot; title: &quot;测试新增&quot; */ var sendObj = &#123; name:addBtnPermissionFormObj.name, pid:addBtnPermissionFormObj.pid, title:addBtnPermissionFormObj.title &#125; $.ajax(&#123; type: &quot;post&quot;, url: &quot;/permission/addBtnPermisison&quot;, dataType : &quot;json&quot;, data: JSON.stringify(sendObj), contentType:&#x27;application/json;charset=utf-8&#x27;, success: function (data) &#123; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, action:function()&#123; $(&#x27;#AddBtnPermissionModal&#x27;).modal(&#x27;hide&#x27;); window.location.href=&quot;/permission/index&quot;; &#125; &#125; &#125; &#125;); &#125; &#125; &#125;); &#125; java代码 12345678910111213141516PermissionController.java@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/permission/addBtnPermisison&quot;) @ResponseBody public MzResult addBtnPermission(@RequestBody Permission permission)&#123; MzResult ajaxResult = new MzResult(); try&#123; //&#123;name:xxx,pid:xxx,title:xxx&#125; permissionService.addBtnPermisison(permission); return ajaxResult; &#125;catch(Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存失败&quot;); &#125; &#125; PermissisonMapper.java 12@Insert(&quot;insert into t_permission (name,title,pid) values(#&#123;name&#125;,#&#123;title&#125;,#&#123;pid&#125;)&quot;) void addBtnPermission(Permission permission); 效果图: 31 权限管理-删除权限功能删除前台功能 123456789101112131415161718192021222324252627function del(row) &#123; if(!row.pid)&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;只能删除按钮权限!!&#x27;, type: &#x27;red&#x27;, buttons: &#123; close: &#123; text: &#x27;谢谢&#x27; &#125; &#125; &#125;); return; &#125; $.ajax(&#123; type: &quot;post&quot;, url: &quot;/permission/deletePermisison&quot;, data: &#123;&quot;id&quot;:row.id&#125;, success: function (data) &#123; if (data.isSuccess) &#123; window.location.href=&quot;/permission/index&quot;; &#125; &#125; &#125;); &#125; 删除后台功能 PermissionController.java 1234567891011121314@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/permission/deletePermisison&quot;) @ResponseBody public MzResult deletePermisison(Long id)&#123; MzResult ajaxResult = new MzResult(); try&#123; //删除权限 通过权限id permissionService.deletePermisisonByPid(id); return ajaxResult; &#125;catch(Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存失败&quot;); &#125; &#125; PermissionServiceImpl.java 123456789101112131415/** * 删除权限 */ @Override @Transactional(rollbackFor=RuntimeException.class) public void deletePermisisonByPid(Long id) &#123; try &#123; //删除中间表数据 permissionMapper.deleteRolePermisisonByPid(id); //删除权限表数据 permissionMapper.deletePermisisonByPid(id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; PermissionMapper.java 12345@Delete(&quot;delete from t_permission where id=#&#123;id&#125;&quot;)void deletePermisisonByPid(Long id);@Delete(&quot;delete from t_role_permission where permissionid=#&#123;id&#125;&quot;)void deleteRolePermisisonByPid(Long id); 32权限管理-修改权限修改权限，这里修改的权限，只能修改 按钮的权限，父级权限不能修改，因为父级权限是 左侧菜单。 所以修改的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//修改的表单 &lt;!-- 修改子级菜单form start--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;EditBtnPermissionModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; &gt;修改页面按钮权限&lt;/h4&gt; &lt;/div&gt; &lt;form id=&quot;editBtnPermissionForm&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;!-- 按钮权限--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;!-- 页面权限id--&gt; &lt;input type=&quot;hidden&quot; class=&quot;form-control&quot; name=&quot;id&quot; id=&quot;e_id&quot;&gt; &lt;label for=&quot;a_btnTitle&quot; class=&quot;control-label&quot;&gt;页面按钮权限名称：&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;如:用户新增&quot; class=&quot;form-control&quot; name=&quot;title&quot; id=&quot;e_btnTitle&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;页面按钮权限值：&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;如:user:add&quot; class=&quot;form-control&quot; name=&quot;name&quot; id=&quot;e_name&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; data-method=&#x27;editSaveBtnPermisison&#x27; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 修改子级菜单form end--&gt;function update(row) &#123; if(!row.pid)&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;只能修改按钮权限!!&#x27;, type: &#x27;red&#x27;, buttons: &#123; close: &#123; text: &#x27;谢谢&#x27; &#125; &#125; &#125;); return; &#125; $(&#x27;#EditBtnPermissionModal&#x27;).modal(&#123; show: true, backdrop:&#x27;static&#x27; &#125;); $(&quot;#e_id&quot;).val(row.id); $(&quot;#e_btnTitle&quot;).val(row.title); $(&quot;#e_name&quot;).val(row.name); &#125; 后台的java代码 PermissionController.java 1234567891011121314@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/permission/editBtnPermisison&quot;) @ResponseBody public MzResult editBtnPermisison(@RequestBody Permission permission)&#123; MzResult ajaxResult = new MzResult(); try&#123; //&#123;name:xxx,pid:xxx,title:xxx&#125; permissionService.editBtnPermisison(permission); return ajaxResult; &#125;catch(Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存失败&quot;); &#125; &#125; PermissionMapper.java 12@Update(&quot;update t_permission set name=#&#123;name&#125;,title=#&#123;title&#125; where id=#&#123;id&#125;&quot;)void editBtnPermisison(Permission permission); 33 菜单权限控制不同的人 登录进入系统 看到的菜单内容不一样 取消测试列表菜单 列表菜单不会展示测试列表菜单 34 菜单权限控制比如 用户列表的 新增功能 需要管理员权限 才能新增.在按钮前面添加 权限控制 123&lt;button sec:authorize= &quot;hasRole(&#x27;管理员&#x27;) &amp;&amp; hasAuthority(&#x27;user:add&#x27;)&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-method=&quot;add&quot; &gt; &lt;i class=&quot;mdi mdi-plus&quot;&gt;&lt;/i&gt;新增 &lt;/button&gt; 在角色维护里面 去掉用户新增 重新登录 查看页面上 没有新增按钮 js里面控制权限 12345if ([[$&#123;#authorization.expression(&#x27;hasRole(&#x27;&#x27;ROLE_管理员&#x27;&#x27;)&#x27;)&#125;]] &amp;&amp; [[$&#123;#authorization.expression(&#x27;hasAuthority(&#x27;&#x27;user:edit&#x27;&#x27;)&#x27;)&#125;]]) &#123; var c = &#x27;&lt;a class=&quot;btn btn-xs btn-default&quot; href=&quot;#!&quot; onclick=\\&#x27;edit(&quot;&#x27; + row.id + &#x27;&quot;)\\&#x27; title=&quot;编辑&quot; data-toggle=&quot;tooltip&quot;&gt;&lt;i class=&quot;mdi mdi-pencil&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#x27;; var e = &#x27;&lt;div class=&quot;btn btn-xs btn-default&quot; href=&quot;#!&quot; onclick=&quot;del(\\&#x27;&#x27;+row.id+&#x27;\\&#x27;)&quot; title=&quot;删除&quot; data-toggle=&quot;tooltip&quot;&gt;&lt;i class=&quot;mdi mdi-window-close&quot;&gt;&lt;/i&gt;&lt;div/&gt; &#x27;; return c+e; &#125; 35 项目结束语(1)谢谢大家的学习，如果有不懂的地方,及时联系我 答疑； 您的付出永远和您薪水成正比. 行动起来吧! 答疑qq: 3427562614 (2)如果有地方讲的不好，千万不要喷，可以找我聊聊, 一起学习 共进步 ； (3)学习项目实战找我们, 专注于 单体 前后端分离 分布式项目 小程序 安卓APP 商业项目定制 项目调试 项目实战辅导 等等","categories":[],"tags":[]},{"title":"权限管理系统2","slug":"权限管理系统2","date":"2022-08-20T00:49:55.000Z","updated":"2022-08-20T01:05:31.877Z","comments":true,"path":"2022/08/20/权限管理系统2/","link":"","permalink":"http://example.com/2022/08/20/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F2/","excerpt":"","text":"14 权限系统显示头像我们可以看到 在include页面里面 有个图片的请求，这个请求就是展示图片的 1&lt;img class=&quot;img-avatar img-avatar-48 m-r-10&quot; th:src=&quot;@&#123;&#x27;/showimage/&#x27;+$&#123;#authentication.principal.loginUser.headImg&#125;&#125;&quot; alt=&quot;灵魂码仔club&quot; /&gt; 需要在后台的时候，提供获取图片的方法。 1$&#123;#authentication.principal.loginUser.headImg&#125; 这个代码是直接获取登录认证用户的头像 配置上传文件路径: 1mz.upload.path=D:\\\\workspace\\\\mz_auth\\\\src\\\\main\\\\resources\\\\static\\\\upload 新增FileUpload类: 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class FileUpload &#123; @Autowired private IUserService userService; @Value(&quot;$&#123;mz.upload.path&#125;&quot;) private String uploadPath; @RequestMapping(value = &quot;/showimage/&#123;image_name&#125;&quot;) public String showphoto(@PathVariable(&quot;image_name&quot;) String image_name,HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.setDateHeader(&quot;Expires&quot;, 0); response.setHeader(&quot;Cache-Control&quot;, &quot;no-store, no-cache, must-revalidate&quot;); response.addHeader(&quot;Cache-Control&quot;, &quot;post-check=0, pre-check=0&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setContentType(&quot;image/jpeg&quot;); // 获得的系统的根目录 File fileParent = new File(File.separator); // 获得/usr/CBeann目录 System.out.println(&quot;读取头像:&quot;+image_name); File file = null ; ServletOutputStream out = response.getOutputStream(); try &#123; file = new File(uploadPath +&quot;\\\\&quot;+ image_name); IOUtils.copy(new FileInputStream(file),out); out.flush(); &#125; finally &#123; out.close(); &#125; return null; &#125;&#125; 最终效果: 15 用户管理-用户列表用户的列表功能引入用户页面模板: user_list.html 点击左侧菜单的时候，跳转到user_list.html页面 UserController.java类 123456 @GetMapping(&quot;/index&quot;) public String index(String menuid, Model model)&#123; model.addAttribute(&quot;menuid&quot;,menuid); //用户首页 return &quot;views/user/user_list&quot;;&#125; 用户列表数据展示用户列表数组展示 这个功能使用一个组件 bootstrapTable组件 前台说明: 从页面模板中 看出来 请求方式 是get 方式 ，请求的路径是&#x2F;user&#x2F;listpage，传递的参数 1234567queryParams : function(params) &#123;//上传服务器的参数var temp = &#123; offset :params.offset + 0,// SQL语句起始索引 page : params.limit, // 每页显示数量 username:params.username, email:params.email&#125; 后台UserController数据操作: 12345@GetMapping(&quot;/user/listpage&quot;)@ResponseBodypublic PageList listpage(UserQuery userQuery)&#123; return userService.listpage(userQuery);&#125; 新增一个PageList。这个是分页对象 1234567@Datapublic class PageList &#123; //总共的条数 private Long total; //每一页显示的数据 private List rows = new ArrayList();&#125; Service层和Mapper层 UserMapper层 1234//查询总的条数Long queryTotal(UserQuery userQuery);//分页查询数据List&lt;User&gt; queryData(UserQuery userQuery); IUserService层 12//分页方法 PageList listpage(UserQuery userQuery); UserServiceImpl层 1234567891011@Overridepublic PageList listpage(UserQuery userQuery) &#123; PageList pageList = new PageList(); //查询总的条数 Long total = userMapper.queryTotal(userQuery); List&lt;User&gt; users = userMapper.queryData(userQuery); pageList.setTotal(total); pageList.setRows(users); //分页查询的数据 return pageList;&#125; UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mz.auth.mapper.UserMapper&quot;&gt; &lt;sql id=&quot;whereSql&quot;&gt; &lt;where&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; and username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; and email like concat(&#x27;%&#x27;,#&#123;email&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;type != null and type != &#x27;&#x27;&quot;&gt; and type =#&#123;type&#125; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; &lt;!--分页--&gt; &lt;select id=&quot;queryTotal&quot; parameterType=&quot;UserQuery&quot; resultType=&quot;java.lang.Long&quot;&gt; select count(*) from t_user &lt;include refid=&quot;whereSql&quot;&gt;&lt;/include&gt; &lt;/select&gt; &lt;select id=&quot;queryData&quot; parameterType=&quot;UserQuery&quot; resultMap=&quot;UserMap&quot;&gt; select * from t_user &lt;include refid=&quot;whereSql&quot;&gt;&lt;/include&gt; order by id desc limit #&#123;offset&#125;,#&#123;pageSize&#125; &lt;/select&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;result property=&quot;tel&quot; column=&quot;tel&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;headImg&quot; column=&quot;headImg&quot;&gt;&lt;/result&gt; &lt;result property=&quot;createTime&quot; column=&quot;createTime&quot;&gt;&lt;/result&gt; &lt;result property=&quot;type&quot; column=&quot;type&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;roles&quot; column=&quot;id&quot; select=&quot;getRoleByUserId&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getRoleByUserId&quot; parameterType=&quot;java.lang.Long&quot; resultType=&quot;Role&quot;&gt; select r.* from t_user_role ur join t_role r on ur.roleid = r.id where ur.userid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 高级查询： 12345678910111213141516search:function()&#123; //获取用户名参数信息 以及email邮箱 var username = $(&quot;#q_username&quot;).val(); var email = $(&quot;#q_email&quot;).val(); var param = &#123; query:&#123; username:username, email:email &#125; &#125; //调用表格的刷新方法 $(&quot;#userTable&quot;).bootstrapTable(&#x27;refresh&#x27;,param) &#125;, 16 用户管理-用户的新增当我们点击新增按钮的时候.弹出一个对话框，对话框里面编辑用户信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!-- 新增表单start--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;userAddModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;exampleModalLabel&quot;&gt;新增用户&lt;/h4&gt; &lt;/div&gt; &lt;form id=&quot;userAddForm&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-name&quot; class=&quot;control-label&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; id=&quot;recipient-name&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-email&quot; class=&quot;control-label&quot;&gt;邮箱：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;email&quot; id=&quot;recipient-email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-tel&quot; class=&quot;control-label&quot;&gt;电话号码：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;tel&quot; id=&quot;recipient-tel&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-password&quot; class=&quot;control-label&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; id=&quot;recipient-password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-confirmPassword&quot; class=&quot;control-label&quot;&gt;确认密码：&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;confirmPassword&quot; id=&quot;recipient-confirmPassword&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;性别:&lt;/label&gt; &lt;div class=&quot;clearfix&quot;&gt; &lt;label class=&quot;coder-radio radio-inline radio-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;&lt;span&gt;女&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;coder-radio radio-inline radio-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; checked&gt;&lt;span&gt;男&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 头像上传--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input id=&quot;file-pic&quot; name=&quot;file&quot; type=&quot;file&quot; value=&quot;上传&quot; multiple/&gt; &lt;p class=&quot;help-block&quot;&gt;支持jpg、jpeg、png、gif,txt,&quot;docx&quot;,&quot;zip&quot;,&quot;xlsx&quot;格式，大小没限制&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; data-method=&#x27;save&#x27; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 新增表单结束--&gt; 弹出对话框模板: 1234567add:function()&#123; $(&#x27;#userAddModal&#x27;).modal(&#123; show: true, backdrop:&#x27;static&#x27; &#125;);&#125; 保存js代码 12345678910111213141516171819202122232425262728293031323334save:function()&#123; //提交表单 var bootstrapValidator = $(&#x27;#userAddForm&#x27;).data(&#x27;bootstrapValidator&#x27;); var formParamObj = $(&quot;#userAddForm&quot;).serializeObject(); console.log(formParamObj); bootstrapValidator.validate(); if (bootstrapValidator.isValid()) &#123; //验证通过 $.ajax(&#123; url: &quot;/user/addUser&quot;, async: false, type: &quot;POST&quot;, data: formParamObj, success: function (data) &#123; userId = data; //不上传图片时，不触发bootstrap 上传插件的初始化方法。仅将表单里面的（除图片以外的）内容提交， if ($(&quot;#file-pic&quot;).val() != &quot;&quot;) &#123; $(&#x27;#file-pic&#x27;).fileinput(&#x27;upload&#x27;); //触发插件开始上传。 &#125; if (data.isSuccess) &#123; alert(&quot;init ok&quot;); $(&#x27;#userAddModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#userTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125; else if (&quot;403&quot; == data) &#123; alert(&quot;你无权访问&quot;); $(&#x27;#userAddModal&#x27;).modal(&#x27;hide&#x27;); &#125; &#125; &#125;); &#125; &#125; 表单验证功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//验证规则 $(&#x27;#userAddForm,#userEditForm&#x27;).bootstrapValidator(&#123; live: &#x27;enabled&#x27;,//字段值有变化就触发验证 disabled,submitted 当点击提交时验证并展示错误信息 message: &#x27;信息不合法&#x27;, feedbackIcons: &#123; valid: &#x27;glyphicon glyphicon-ok&#x27;, invalid: &#x27;glyphicon glyphicon-remove&#x27;, validating: &#x27;glyphicon glyphicon-refresh&#x27; &#125;, fields: &#123; username: &#123; message: &#x27;用户名不合法&#x27;, validators: &#123; notEmpty: &#123; message: &#x27;用户名必须填写,不能为空&#x27; &#125;, stringLength: &#123; min: 6, max: 30, message: &#x27;长度必须是6到30个字符&#x27; &#125;, regexp: &#123; regexp: /^[a-zA-Z0-9_\\.]+$/, message: &#x27;用户名必须有字母数字下划线组成&#x27; &#125; &#125; &#125;, tel: &#123; message: &#x27;电话不合法&#x27;, validators: &#123; notEmpty: &#123; message: &#x27;电话号码,不能为空&#x27; &#125;, stringLength: &#123; min: 11, max: 11, message: &#x27;长度必须是11位&#x27; &#125;, regexp: &#123; regexp: /^1\\d&#123;10&#125;$/, message: &#x27;手机号格式错误&#x27; &#125; &#125; &#125;, email: &#123; validators: &#123; notEmpty: &#123; message: &#x27;邮箱不能空&#x27; &#125;, emailAddress: &#123; message: &#x27;输入邮箱不合格&#x27; &#125; &#125; &#125;, password: &#123; validators: &#123; notEmpty: &#123; message: &#x27;密码不能为空&#x27; &#125; &#125; &#125;, confirmPassword: &#123; validators: &#123; notEmpty: &#123; message: &#x27;确认密码不能为空&#x27; &#125;, identical: &#123; field: &#x27;password&#x27;, message: &#x27;两次密码不一样哟111....&#x27; &#125;, different: &#123; field: &#x27;username&#x27;, message: &#x27;密码不能和用户名相同&#x27; &#125; &#125; &#125; &#125; &#125;); 保存代码:Mapper UserMapper.java 12//更新用户头像 void updateUserHeadImg(User user); IUserService.java 1234/** * 更新用户头像 */ void updateUserHeadImg(User user); UserServiceImpl.java 123public void updateUserHeadImg(User user) &#123; userMapper.updateUserHeadImg(user); &#125; UserMapper.xml 1234&lt;!-- 更新头像--&gt; &lt;update id=&quot;updateUserHeadImg&quot; parameterType=&quot;User&quot;&gt; update t_user set headImg=#&#123;headImg&#125; where id=#&#123;id&#125; &lt;/update&gt; 17 用户管理-头像上传实现该功能需要先实现上面的用户新增。 上传核心方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//上传 $(&#x27;#file-pic&#x27;).fileinput(&#123; //初始化上传文件框 language: &quot;zh&quot;,//配置语言 showUpload : false, //显示整体上传的按钮 showRemove : true,//显示整体删除的按钮 uploadAsync: true,//默认异步上传 uploadLabel: &quot;上传&quot;,//设置整体上传按钮的汉字 removeLabel: &quot;移除&quot;,//设置整体删除按钮的汉字 uploadClass: &quot;btn btn-primary&quot;,//设置上传按钮样式 showCaption: true,//是否显示标题 dropZoneEnabled: false,//是否显示拖拽区域 uploadUrl: &#x27;/file/uploadFile&#x27;,//这个是配置上传调取的后台地址，本项目是SSM搭建的 maxFileSize : 9999,//文件大小限制 maxFileCount: 9999,//允许最大上传数，可以多个， enctype: &#x27;multipart/form-data&#x27;, allowedFileExtensions : [&quot;jpg&quot;, &quot;png&quot;,&quot;gif&quot;,&quot;docx&quot;,&quot;zip&quot;,&quot;xlsx&quot;,&quot;txt&quot;],/*上传文件格式限制*/ msgFilesTooMany: &quot;选择上传的文件数量(&#123;n&#125;) 超过允许的最大数值&#123;m&#125;！&quot;, showBrowse: true, browseOnZoneClick: true, slugCallback : function(filename) &#123; return filename.replace(&#x27;(&#x27;, &#x27;_&#x27;).replace(&#x27;]&#x27;, &#x27;_&#x27;); &#125;, uploadExtraData: function(previewId, index) &#123; //额外参数的关键点 //&#123; id: userId &#125; return &#123; id: userId &#125;; &#125; &#125;);$(&#x27;#file-pic&#x27;).on(&quot;fileuploaded&quot;, function(event, data, previewId, index) &#123; var response = data.response; console.log(response); if(response.isSuccess)&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, &#125; &#125; &#125;); $(&#x27;#userAddModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#userTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125;else&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;操作失败&#x27;, type: &#x27;red&#x27;, buttons: &#123; omg: &#123; text: &#x27;重试&#x27;, btnClass: &#x27;btn-red&#x27;, &#125; &#125; &#125;); &#125; &#125;); 18用户管理-用户修改修改的表单 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 修改表单start--&gt; &lt;div class=&quot;modal fade&quot; id=&quot;userEditModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;exampleModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; &gt;修改用户&lt;/h4&gt; &lt;/div&gt; &lt;form id=&quot;userEditForm&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;e_id&quot; class=&quot;form-control&quot; name=&quot;id&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-name&quot; class=&quot;control-label&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;e_username&quot; class=&quot;form-control&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-email&quot; class=&quot;control-label&quot;&gt;邮箱：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;e_email&quot; class=&quot;form-control&quot; name=&quot;email&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-tel&quot; class=&quot;control-label&quot;&gt;电话号码：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;e_tel&quot; class=&quot;form-control&quot; name=&quot;tel&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label&quot;&gt;性别:&lt;/label&gt; &lt;div class=&quot;clearfix&quot;&gt; &lt;label class=&quot;coder-radio radio-inline radio-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;&lt;span&gt;女&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;coder-radio radio-inline radio-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; checked&gt;&lt;span&gt;男&lt;/span&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; data-method=&#x27;editSave&#x27; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 修改表单end--&gt; 修改保存方法 123456789101112131415161718192021222324252627282930313233343536373839editSave:function()&#123; //提交表单 var bootstrapValidator = $(&#x27;#userEditForm&#x27;).data(&#x27;bootstrapValidator&#x27;); var formParamObj = $(&quot;#userEditForm&quot;).serializeObject(); bootstrapValidator.validate(); if (bootstrapValidator.isValid()) &#123; //验证通过 $.ajax(&#123; url: &quot;/user/editSaveUser&quot;, async: false, type: &quot;POST&quot;, data: formParamObj, success: function (data) &#123; userId = data; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;修改成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, &#125; &#125; &#125;); $(&#x27;#userEditModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#userTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125; else if (&quot;403&quot; == data) &#123; alert(&quot;你无权访问&quot;); $(&#x27;#userEditModal&#x27;).modal(&#x27;hide&#x27;); &#125; &#125; &#125;); &#125; &#125; 修改后台代码 UserController.java 123456789101112@PostMapping(&quot;/editSaveUser&quot;) @ResponseBody public MzResult editSaveUser(User user)&#123; System.out.println(&quot;修改用户....&quot;+user); try &#123; userService.editSaveUser(user); return new MzResult(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new MzResult(&quot;修改失败&quot;); &#125; UserMapper.xml 123456&lt;!-- 修改用户editSaveUser--&gt; &lt;update id=&quot;editSaveUser&quot; parameterType=&quot;User&quot;&gt; update t_user set username=#&#123;username&#125;,email=#&#123;email&#125;,sex=#&#123;sex&#125;,tel=#&#123;tel&#125; where id =#&#123;id&#125; &lt;/update&gt; 19 用户管理-用户删除前台删除操作 12345678910111213141516171819function del(id)&#123; //发送ajax请求删除数据 $.get(&quot;/user/deleteUser&quot;,&#123;&quot;id&quot;:id&#125;,function(res)&#123; if(res.isSuccess)&#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;删除成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, &#125; &#125; &#125;); $(&quot;#userTable&quot;).bootstrapTable(&#x27;refresh&#x27;) &#125; &#125;); &#125; 后台添加删除方法 Controller方法 12345678910111213@GetMapping(&quot;/deleteUser&quot;) @ResponseBody public MzResult deleteUser(@RequestParam(required = true) Long id)&#123; MzResult ajaxResult = new MzResult(); try &#123; userService.deleteUser(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return new MzResult(&quot;删除失败&quot;); &#125; return ajaxResult; &#125; Mapper方法 UserMapper.java 12@Delete(&quot;delete from t_user where id=#&#123;id&#125;&quot;) void deleteUser(Long id); 20 菜单管理-菜单列表菜单列表展示这里使用树形表格 ，引入menu_list.html页面 在页面中，有个代码 var menus &#x3D; [[${menus}]]; 这个代码就是后台传过来的菜单数据… 后台添加MenuController.java 类 1234567@RequestMapping(&quot;/menu/index&quot;) public String index(Model model)&#123; List&lt;Menu&gt; menus = menuService.queryAllMenu(); model.addAttribute(&quot;menus&quot;,menus); //返回菜单页面 return &quot;views/menu/menu_list&quot;; &#125; MenuMapper.java 12345/** * 查询所有的菜单 * @return */ List&lt;Menu&gt; queryAllMenu(); MenuMapper.xml 1234567891011121314151617&lt;!-- 菜单维护--&gt; &lt;select id=&quot;queryAllMenu&quot; resultMap=&quot;menuMap&quot;&gt; select t.id,t.name,t.url,t.pid,t.icon,p.id pid,p.name pname from t_menu t left join t_permission p on p.menuid = t.id &lt;/select&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;Menu&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;url&quot; column=&quot;url&quot;&gt;&lt;/result&gt; &lt;result property=&quot;pid&quot; column=&quot;pid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;icon&quot; column=&quot;icon&quot;&gt;&lt;/result&gt; &lt;association property=&quot;permission&quot; javaType=&quot;Permission&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;pid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;name&quot; column=&quot;pname&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 21 菜单管理-菜单列表菜单列表展示这里使用树形表格 ，引入menu_list.html页面 在页面中，有个代码 var menus &#x3D; [[${menus}]]; 这个代码就是后台传过来的菜单数据… 后台添加MenuController.java 类 1234567@RequestMapping(&quot;/menu/index&quot;) public String index(Model model)&#123; List&lt;Menu&gt; menus = menuService.queryAllMenu(); model.addAttribute(&quot;menus&quot;,menus); //返回菜单页面 return &quot;views/menu/menu_list&quot;; &#125; MenuMapper.java 12345/** * 查询所有的菜单 * @return */ List&lt;Menu&gt; queryAllMenu(); MenuMapper.xml 1234567891011121314151617&lt;!-- 菜单维护--&gt; &lt;select id=&quot;queryAllMenu&quot; resultMap=&quot;menuMap&quot;&gt; select t.id,t.name,t.url,t.pid,t.icon,p.id pid,p.name pname from t_menu t left join t_permission p on p.menuid = t.id &lt;/select&gt; &lt;resultMap id=&quot;menuMap&quot; type=&quot;Menu&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;url&quot; column=&quot;url&quot;&gt;&lt;/result&gt; &lt;result property=&quot;pid&quot; column=&quot;pid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;icon&quot; column=&quot;icon&quot;&gt;&lt;/result&gt; &lt;association property=&quot;permission&quot; javaType=&quot;Permission&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;pid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;name&quot; column=&quot;pname&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 22 菜单管理-删除菜单根据菜单id 去删除菜单… 1234567891011//删除代码 $.ajax(&#123; type: &quot;post&quot;, url: &quot;/menu/deleteMenu&quot;, data: &#123;&quot;id&quot;:row.id&#125;, success: function (data) &#123; if (data.isSuccess) &#123; window.location.href=&quot;/menu/index&quot;; &#125; &#125; &#125;); &#x2F;&#x2F;后台删除功能 MenuController.java 1234567891011121314@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/menu/deleteMenu&quot;) @ResponseBody public MzResult deleteMenu(Long id)&#123; MzResult ajaxResult = new MzResult(); try&#123; //删除菜单 通过id删除 menuService.deleteMenuById(id); return ajaxResult; &#125;catch(Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存失败&quot;); &#125; &#125; MenuMapper.java 12@Delete(&quot;delete from t_menu where id=#&#123;id&#125; or pid=#&#123;id&#125;&quot;) void deleteMenuById(Long id); 23 菜单管理-修改菜单1234567891011121314151617181920212223242526272829303132333435363738editMenu:function()&#123; var editMenuFormObj = $(&quot;#editMenuForm&quot;).serializeObject(); var sendObj = &#123; name:editMenuFormObj.name, id:editMenuFormObj.id, icon:editMenuFormObj.icon, url:editMenuFormObj.url &#125; $.ajax(&#123; type: &quot;post&quot;, url: &quot;/menu/editMenu&quot;, dataType : &quot;json&quot;, data: JSON.stringify(sendObj), contentType:&#x27;application/json;charset=utf-8&#x27;, success: function (data) &#123; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123; omg: &#123; text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;, action:function()&#123; $(&#x27;#EditMenuModal&#x27;).modal(&#x27;hide&#x27;); window.location.href=&quot;/menu/index&quot;; &#125; &#125; &#125; &#125;); &#125; &#125; &#125;); &#125; 后台功能: MenuController.java 12345678910111213@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/menu/editMenu&quot;) @ResponseBody public MzResult editMenu(@RequestBody Menu menu)&#123; MzResult mzResult = new MzResult(); try&#123; menuService.editMenu(menu); return mzResult; &#125;catch(Exception e)&#123; e.printStackTrace(); return new MzResult(&quot;保存失败&quot;); &#125; &#125; 修改的MenuMapper.java和MenuMapper.xml 123456789101112131415&lt;update id=&quot;editMenu&quot; parameterType=&quot;Menu&quot;&gt; update t_menu &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;icon != null&quot;&gt; icon=#&#123;icon&#125;, &lt;/if&gt; &lt;if test=&quot;url != null&quot;&gt; url=#&#123;url&#125;, &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 24 菜单管理-角色列表上面的我们已经把用户数据，把菜单数据准备好了，下面设计角色模块. 首页准备页面 role_list.html 角色列表展示新增RoleController.java 123456789101112131415@PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @RequestMapping(&quot;/role/index&quot;) public String index(Model model)&#123; List&lt;Permission&gt; permisisons = permissionService.findAllPermisisons(); model.addAttribute(&quot;permissions&quot;,permisisons); //返回角色 return &quot;views/role/role_list&quot;; &#125; @RequestMapping(&quot;/role/listpage&quot;) @ResponseBody public PageList listpage(RoleQuery roleQuery)&#123; System.out.println(&quot;传递参数:&quot;+roleQuery); return roleService.listpage(roleQuery); &#125; PermissionMapper.java 123//查找所有的权限@Select(&quot;select * from t_permission&quot;)List&lt;Permission&gt; findAllPermisisons(); RoleServiceImpl.java 1234567891011@Override public PageList listpage(RoleQuery userQuery) &#123; PageList pageList = new PageList(); //查询总的条数 Long total = roleMapper.queryTotal(userQuery); List&lt;Role&gt; roles = roleMapper.queryData(userQuery); pageList.setTotal(total); pageList.setRows(roles); //分页查询的数据 return pageList; &#125; RoleMapper.java 123Long queryTotal(RoleQuery roleQuery); List&lt;Role&gt; queryData(RoleQuery roleQuery); RoleMapper.xml 12345678910111213141516171819202122232425262728293031&lt;!--分页--&gt; &lt;select id=&quot;queryTotal&quot; parameterType=&quot;RoleQuery&quot; resultType=&quot;java.lang.Long&quot;&gt; select count(*) from t_role &lt;include refid=&quot;whereSql&quot;&gt;&lt;/include&gt; &lt;/select&gt; &lt;select id=&quot;queryData&quot; parameterType=&quot;RoleQuery&quot; resultMap=&quot;RoleMap&quot;&gt; select * from t_role &lt;include refid=&quot;whereSql&quot;&gt;&lt;/include&gt; order by id desc limit #&#123;offset&#125;,#&#123;pageSize&#125; &lt;/select&gt; &lt;resultMap id=&quot;RoleMap&quot; type=&quot;Role&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sn&quot; property=&quot;sn&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;permissions&quot; column=&quot;id&quot; select=&quot;getPermissionsByRoleId&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getPermissionsByRoleId&quot; resultType=&quot;Permission&quot;&gt; SELECT p.* FROM t_role_permission rp JOIN t_permission p ON rp.permissionid = p.id WHERE rp.roleid = #&#123;id&#125; &lt;/select&gt; 最终效果： 注意页面 使用格式化方法 展示 角色所属的权限 12345678910function permissionsFormatter(value,row, index)&#123; if(row.permissions.length &gt; 0)&#123; var roleStr = &quot;&quot;; for(var i=0;i&lt;row.permissions.length;i++)&#123; roleStr+= &quot; &lt;span class=\\&quot;label label-warning\\&quot;&gt;&quot;+row.permissions[i].title+&quot;&lt;/span&gt;&quot; &#125; return roleStr; &#125; return &quot;&lt;span class=\\&quot;label label-danger\\&quot;&gt;未分配权限&lt;/span&gt;&quot;; &#125; 25 角色管理-新增角色弹出新增角色的表单 1234567891011121314add:function()&#123; $(&#x27;#roleAddModal&#x27;).modal(&#123; show: true, backdrop:&#x27;static&#x27; &#125;); //初始化编辑器 markDownObj = $(&quot;#editor&quot;).markdown(&#123; autofocus: true, savable:false, onChange: function(e)&#123; console.log(&quot;Changed!&quot;+e.getContent()); &#125; &#125;)&#125; 保存代码 123456789101112131415161718192021222324252627282930313233343536373839save()&#123; //获取角色名称 var roleName = $(&quot;#a_name&quot;).val(); //获取编辑的值 var content = markDownObj[0].value.trim(); //把markdown语法转换成HTML语法 content = marked(content) //验证通过 $.ajax(&#123; url: &quot;/role/addRole&quot;, async: false, type: &quot;POST&quot;, data: &#123;&quot;name&quot;:roleName,&quot;desc&quot;:content&#125;, success: function (data) &#123; if (data.isSuccess) &#123; $.confirm(&#123; title: &#x27;温馨提示:&#x27;, content: &#x27;保存成功&#x27;, type: &#x27;green&#x27;, buttons: &#123;omg: &#123;text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;,&#125; &#125; &#125;); $(&#x27;#roleAddModal&#x27;).modal(&#x27;hide&#x27;); $(&#x27;#roleTable&#x27;).bootstrapTable(&#x27;refresh&#x27;); &#125; else if (&quot;403&quot; == data) &#123; $.confirm(&#123; title: &#x27;温馨提示:&#x27;, content: &#x27;你无权访问&#x27;, type: &#x27;green&#x27;, buttons: &#123;omg: &#123;text: &#x27;谢谢&#x27;, btnClass: &#x27;btn-green&#x27;,&#125; &#125; &#125;); $(&#x27;#roleAddModal&#x27;).modal(&#x27;hide&#x27;); &#125; &#125; &#125;); &#125; 后台代码 RoleController.java 12345678910111213@RequestMapping(&quot;/role/addRole&quot;) @PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) @ResponseBody public MzResult addRole(Role role)&#123; System.out.println(&quot;保存角色....&quot;+role); try &#123; roleService.saveRole(role); return new MzResult(); &#125; catch (Exception e) &#123; e.printStackTrace(); return new MzResult(&quot;操作失败&quot;); &#125; &#125; RoleService RoleServiceImpl 略 RoleMapper.java 12@Insert(&quot;insert into t_role(name,sn,`desc`) values (&#x27;$&#123;name&#125;&#x27;,&#x27;$&#123;sn&#125;&#x27;,trim(&#x27;&lt;![CDATA[$&#123;desc&#125;]]&gt;&#x27;))&quot;) void saveRole(Role role); 温馨提示请看最后一篇权限管理3","categories":[],"tags":[]},{"title":"权限管理系统1","slug":"权限管理系统1","date":"2022-08-20T00:07:27.000Z","updated":"2022-08-20T01:07:28.565Z","comments":true,"path":"2022/08/20/权限管理系统1/","link":"","permalink":"http://example.com/2022/08/20/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1/","excerpt":"","text":"1 权限系统前言介绍系统前言(1)一个系统或者一个项目，为什么需要添加权限，权限有什么作用？一般一个稍微复杂一点的项目或者系统，都会涉及到权限部分，权限部分可以说是一个系统或者项目的基石(最基础部分)，基本上面系统都离不开权限的内容. 权限: 不同人进行到系统，看到的，操作的内容都不一样 比如：用户 ：yuge 角色： 导演 权限：演戏 写剧本 用户: zhangsan 角色：演员 权限：演戏 (2)我们应该怎么去设计一个权限系统呢？a) 自己手动用代码去实现一个权限–不用任何框架（代码量就比较大了 对程序员门槛要求比较高） b) 使用开源框架 shiro springsecurity 2 Shiro和SpringSecurity区别? (1)SpringSecurity比Shiro更加出名，从名字可以看出来，SpringSecurity属于Spring家族，在SpringBoot没有出现之前，Shiro使用比较多，但是后来 SpringBoot出来了，提供了自动化配置方案，SpringSecurity要使用多一点。 (2)Shiro实现功能比SpringSecurity要少的多，SpringSecurity除了基本Shiro认证和授权以外，还对分布式，oauth认证，单点登录 都比较友好的支持； (3)SpringSecurity的社区讨论更加丰富，有更好社区的支持； (4)SpringSecurity和Spring进行无缝衔接的，比Shiro要好的多，特别是在SpringBoot流行的今天，SpringSecurityu更能发挥它的特点. (5)SpringSecurity更加细粒度的控制权限，比Shiro做的好,数据访问控制Controller进行控制； (6)Shrio简单，功能没有这么多，上手要容易点，SpringSecurity功能要多一点，上手要难一点，学起来成本要大一点； (7）一般像传统的老的项目 shiro+Spring+SpringMVC+MyBatis 现在企业流行的: SpringBoot+MyBatis+SpringMVC+SpringSecurity 温馨提示Mark老师提醒一句:如果项目里面使用spring产品比较多，建议你使用springsecurity，如果你像实现更多丰富的功能，也建议你使用springsecurity，如果项目是传统的 Spring+SpringMVC+MyBatis 建议你使用shiro 3 SpringSecurity的认识 Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括 用户认证（Authentication）和用户授权（Authorization）两个部分。 用户认证 用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。– 登录过程进行认证 用户授权用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。 温馨提示mark老师 提醒您记住： 权限框架核心 用户认证(Authentication) 和 用户授权(Authorization) 我们要完成用户认证，和用户授权，还需要学习一个概念 叫RBAC 4 RBAC的认识(1)什么是RBACRBAC 是基于 角色的访问控制(Role-Based Access Controll) 在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理. 用户和角色有关联， 角色和权限有关联 这里我们提取几个关键内容： 角色(Role) 权限(Permission) 用户(User) 其实我们这里多提供关键内容 “资源”(菜单资源) 这个几个什么意思呢，下面我们来认识一下. 角色(Role)： 为了对许多拥有相似权限的用户进行分类管理，定义了角色的概念, 比如说 管理员，演员，导演.老师，学生 权限(Permisison): 具体的操作，具体的用户的动作, 比如 新增用户操作 修改用户操作 删除用户操作，演戏操作 写剧本 等 用户(User): 就是操作的个体。说白了 就是指人。 资源(Resource): 具体的内容 东西 例如: 下面例子 就能提醒 用户 角色 权限 资源协作关系 不同的角色对应的权限就不一样 用户: 张三 李四角色：普通用户 管理员权限：普通用户(开美女门) 管理员(开珠宝门 开美女门)资源： 美女 和 珠宝 同时这里也存在 几个关系：(提炼) 用户 和 角色 – 多对多关系 (多个用户可以拥有一个角色，一个角色可以赋给多个用户) –建立一个中间表 (uid,rid) 角色 和 权限 – 多对多关系 (多个权限可以拥有一个角色，一个角色可以赋给多个权限) –建立一个中间表 (uid,rid) 管理员角色( 开美女门权限 开珠宝门权限 ) 开美女权限(管理员角色 普通用户角色) 权限 和 资源 – 这里可以是一对一 也可以是 一对多 (一个权限 对应 一个资源 也可以一个权限对应多个资源) 根据这几层关系 我们就可以涉及数据库表结构 温馨提示基础认识就到这啦！！！ 5 数据库表结构ER图（实体关系图 表和表之间的关系图） 权限核心： 用户 user 角色 role 权限permission 数据库表用户表(t_user) 角色表（t_role） 权限表(t_permission) t_user_role（用户和角色的中间表） t_role_permission(角色和权限中间表) t_menu（菜单资源–对应权限） 6 项目结构搭建使用idea或者eclipse进行项目搭建.推荐使用idea. (1)首先创建maven项目 取名itfxq_auth (2)导入对应依赖jar包 (pom.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- springboot版本号定义 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.itfxq.security&lt;/groupId&gt; &lt;artifactId&gt;itfxq_security&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- springsecurity整合springboot包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web相关的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 简写get set 构造器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- 测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springboot整合mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 编码解码的包--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- json转换时间格式 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;!-- 日志信息 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jsp依赖 对应springboot版本为2.1.4--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf和spring整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--devtools热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; (3) 在resources文件夹下面 创建配置文件 application.properties，添加以下内容.123456789101112131415161718server.port=80# datasourcespring.datasource.url=jdbc:mysql://localhost:3306/mz_auth?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=adminspring.thymeleaf.suffix=.htmlspring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5 spring.thymeleaf.cache=falsespring.mvc.static-path-pattern=/static/**/# MyBatis mappermybatis.mapper-locations=classpath:com/mz/auth/mapper/*.xmlmybatis.type-aliases-package=com.mz.auth.domain,com.mz.auth.querylogging.level.com.mz= infologging.pattern.console=&quot; %clr([%thread])&#123;red&#125; %highlight(%-5level) %logger&#123;50&#125; -%msg%n&quot; (4)创建包结构 (5) 创建启动类 12345678910/** * @Author: Mark老师 */@SpringBootApplication@MapperScan(&quot;com.mz.auth.mapper&quot;)public class AuthApp &#123; public static void main(String[] args) &#123; SpringApplication.run(AuthApp.class,args); &#125;&#125; (6)启动运行 如果出现这个 这里有个密码 是springsecurity 产生的 说明springsecurity已经启动成功。当然离我们要完成的功能要差的很远。 我们要学习springsecurity ，先来完成登录. 登录 可以基于内存方式登录(学习认识阶段方式) 和 基于数据库方式登录(项目中使用方式) 7 基于内存方式登录认证创建一个登录页面 放到 templates&#x2F;login.html 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html id=&quot;ng-app&quot; ng-app=&quot;app&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;form-signin&quot; action=&quot;/form&quot; method=&quot;post&quot;&gt; &lt;h2 class=&quot;form-signin-heading&quot;&gt;用户登录&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-lg btn-primary btn-block&quot; &gt;登录&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建一个登录成功页面 index.html 12345678910 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 恭喜登录成功&lt;/body&gt;&lt;/html&gt; 创建一个登录失败页面 error.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登录失败&lt;/body&gt;&lt;/html&gt; 创建LoginController 12345678@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/login&quot;) public String userLogin() &#123; return &quot;login&quot;; &#125;&#125; 添加类 SecurityConfig 继承 WebSecurityConfigurerAdapter 重写覆写configure方法,最后加上@Configuration 和@EnableWebSecurity 2个注解 123456789101112131415161718192021222324252627282930313233343536373839/** * @Author: Mark * @Decription:SecurityConfig */@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests()//HttpServletRequest请求认证 //放行路径 不需要认证 .antMatchers(&quot;/static/**&quot;).permitAll() .anyRequest().authenticated() //其他任何请求都需要登录认证 .and() .formLogin() //form表单登录方式 .and() .csrf().disable() //关闭CSRF网络攻击 XSS .formLogin().loginPage(&quot;/login&quot;) //表示登录时候 跳转的页面 .loginProcessingUrl(&quot;/form&quot;) //form表单登录请求 .defaultSuccessUrl(&quot;/index&quot;) //成功登陆后跳转页面 .failureUrl(&quot;/loginError&quot;).permitAll();//失败错误跳转 &#125; //基于内存方式登录 @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;admin&quot;) .password(new BCryptPasswordEncoder() .encode(&quot;123456&quot;)).roles(&quot;USER&quot;); &#125;&#125; 测试内存方式登录认证 http://localhost –&gt;正确的用户名和密码 admin&#x2F;123456 –&gt;跳转成功 错误的用户名和密码 admin&#x2F;123 –&gt;跳转失败页面 8 基于数据库方式登录认证 基于内存方式完成的登录认证，肯定不能满足开发的需求，因为 用户名还有密码，权限，角色都存储在数据库里面，所有不能使用基于内存的方式完成登录认证。下面使用基于数据库方式完成登录认证. (1)准备工作-创建对应的实体类要实现数据库登录认证。首先创建一个User实体类 User类: 1234567891011121314151617@Datapublic class User &#123; private Long id; private String username; private String password; private String email; private String tel; @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date createTime; private Boolean sex; private String headImg; private Integer type; //type=1 是管理员 type=2是老师 private List&lt;Role&gt; roles = new ArrayList();//用户对应的角色集合 public User() &#123; &#125;&#125; Permission类 12345678910111213/** * @Author: Mark * @Decription: Permission */@Datapublic class Permission &#123; private Long id; private String name; private String title; private Long pid; private Long menuid;&#125; Role类 1234567891011/** * @Author: Mark * @Decription:Role */public class Role &#123; private Long id; private String name; private String sn; private String desc; List&lt;Permission&gt; permissions = new ArrayList();&#125; (2)创建UserService接口 和 UserMapper层UserMapper接口 123456789/** * @Author: Mark * @Decription:UserMapper */@Mapperpublic interface UserMapper &#123; @Select(&quot;select * from t_user where username=#&#123;username&#125;&quot;) User findUserByUserName(String username);&#125; (3)UserService接口和 UserServiceImpl实现类123456789101112131415161718public interface IUserService &#123; //根据用户名取到用户 User findUserByUserName(String username);&#125;/** * @Author: Mark * @Decription:UserServiceImpl */@Servicepublic class UserServiceImpl implements IUserService &#123; @Autowired private UserMapper userMapper; public User findUserByUserName(String username)&#123; return userMapper.findUserByUserName(username); &#125;&#125; (4)封装用户类 UserSecurityUserSecurity主要用于登录之后，存储用户的信息，封装如下: 1234567891011121314//登录用户封装public class UserSecurity extends User &#123; com.mz.auth.entity.User loginUser ; public UserSecurity(com.mz.auth.entity.User user, Set&lt;GrantedAuthority&gt; authorities) &#123; super(user.getUsername(), user.getPassword(),true,true,true,true, authorities); this.loginUser = user; &#125; public com.mz.auth.entity.User getLoginUser() &#123; return loginUser; &#125; public void setLoginUser(com.mz.auth.entity.User loginUser) &#123; this.loginUser = loginUser; &#125;&#125; (5)添加登录认证处理类UserDetailsServiceImpl123456789101112131415161718192021@Componentpublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private IUserService userService; //查询用户和角色 @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询出用户 com.mz.auth.entity.User user = userService.findUserByUserName(username); if(user != null) &#123; //构建所有权限集合==ROLE_角色+权限 HashSet&lt;GrantedAuthority&gt; authorities = new HashSet&lt;GrantedAuthority&gt;(); authorities.add(new SimpleGrantedAuthority(&quot;ROLE_管理员&quot;)); return new UserSecurity(user,authorities); &#125;else&#123; return null; &#125; &#125;&#125; (6)改造配置SecurityConfig配置把基于内存的注释掉，添加基于数据库登录方式 123456789101112131415@Autowired UserDetailsService userDetailsService; @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; //基于内存方式登录 // auth.inMemoryAuthentication() // .passwordEncoder(new BCryptPasswordEncoder()) // .withUser(&quot;admin&quot;) // .password(new BCryptPasswordEncoder() // .encode(&quot;123456&quot;)).roles(&quot;USER&quot;); //基于数据库方式登录 auth.userDetailsService(userDetailsService) .passwordEncoder(new BCryptPasswordEncoder()); &#125; 启动测试测试方式和上面基于内容方式一样的. 认证方式就说到这里，现在我们说一下访问权限怎么处理 9 认证的核心原理流程图 –源码解析上一个小节 完成了登录的认证操作,下面使用源码的方式进行底层的理解. 请看下面的图: 步骤一：@EnableWebSecurity 引用了 WebSecurityConfiguration 配置类 和 @EnableGlobalAuthentication 注解 @EnableGlobalAuthentication 注解源码里面看到其引用了AuthenticationConfiguration 配置类。这个类里面有个方法 getAuthenticationManager() 步骤二：ProviderManager是 AuthenticationManager 的实现子类之一 ， 内部维护了 一个List&lt;**AuthenticationProvider**&gt; 对象， 用于支持和扩展 多种形式的认证方式，它里面方法authenticate方法 ，该方法关键代码 provider.authenticate(authentication); 步骤三：调用AbstractUserDetailsAuthenticationProvider 类里面的 authenticate方法 该方法里面有关键代码 1user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); 步骤四: 上面的方法会调用 DaoAuthenticationProvider 类的retrieveUser方法 方法里面有这个代码 UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username); 这个大家比较熟悉了把，然后重写方法，完成我们的认证操作。 10 访问权限控制–授权权限控制(授权)：说白了一点，就是你认证这个用户有这个权限 或者有这个角色，就可以操作内容，如果没有这个权限或者没有这个角色 ，就不能操作内容。 实现的步骤： （1） 首先把该认证用户存储在数据库的 权限和角色 查询出来，交给SpringSecurity框架去管理 （2）该框架在发现你在操作某个内容的时候，就会把您当前的权限拿出来 和你操作的内容需要的权限 进行对比一下，如果存在 就可以操作，如果不存在就不能操作. 代码实现: 添加对应mapper和service层1先在数据库把写sql，一会要在代码里面查询 用户局部的角色和权限，交个SpringSecurity管理起来 123456789101112131415//查询用户1具备角色select r.* from t_role rjoin t_user_role u on r.id = u.roleidwhere u.userid = 1用户和角色 角色和权限//查询用户1具备权限select p.* from t_permission pjoin t_role_permission rp on p.id = rp.permissionidjoin t_role r on rp.roleid = r.idjoin t_user_role ur on ur.roleid = r.idwhere ur.userid = 1 2 写java代码去查询数据 在RoleMapper添加根据id查询角色的方法 RoleMapper.java 123456789101112/** * @Author: Mark * @Decription:RoleMapper */public interface RoleMapper &#123; /** * 通过用户id查询角色 * @param userid * @return */ List&lt;Role&gt; listRoleByUserId(Long userid);&#125; 添加RoleMapper.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mz.auth.mapper.RoleMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.mz.auth.entity.Role&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;listRoleByUserId&quot; resultMap=&quot;BaseResultMap&quot;&gt; select t_role.* from t_role join t_user_role on t_role.id = t_user_role.roleid where t_user_role.userid = #&#123;userid&#125; &lt;/select&gt; &lt;sql id=&quot;whereSql&quot;&gt; &lt;/sql&gt;&lt;/mapper&gt; 添加RoleService和RoleServiceImpl 1234567891011121314151617public interface IRoleService &#123; //根据用户id查询角色 List&lt;Role&gt; listRoleByUserId(Long userid);&#125;@Service@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)public class RoleServiceImpl implements IRoleService &#123; @Autowired private RoleMapper roleMapper; @Override public List&lt;Role&gt; listRoleByUserId(Long userid) &#123; return roleMapper.listRoleByUserId(userid); &#125; &#125; 添加PermissionMapper 1234567/** * @Author: Mark * @Decription:PermissionMapper */public interface PermissionMapper &#123; List&lt;Permission&gt; listPermissionByUserId(Long userid);&#125; IPermissionService和PermissionServiceImpl 123456789101112131415161718public interface IPermissionService &#123; //根据用户查询权限 List&lt;Permission&gt; listPermissionByUserId(Long userid);&#125;@Servicepublic class PermissionServiceImpl implements IPermissionService &#123; @Autowired private PermissionMapper permissionMapper; @Override public List&lt;Permission&gt; listPermissionByUserId(Long userid) &#123; return permissionMapper.listPermissionByUserId(userid); &#125;&#125; 添加对应的权限获取代码在UserDetailsServiceImpl里面。 12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private IUserService userService; @Autowired private IRoleService roleService; @Autowired private IPermissionService permissionService; //查询用户和角色 @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询出用户 com.mz.auth.entity.User user = userService.findUserByUserName(username); if(user != null) &#123; //查询角色集合 Long userid = user.getId(); List&lt;Role&gt; roles = roleService.listRoleByUserId(userid); //查询权限集合 List&lt;Permission&gt; permissions = permissionService.listPermissionByUserId(userid); //构建所有权限集合==ROLE_角色+权限 HashSet&lt;GrantedAuthority&gt; authorities = new HashSet&lt;GrantedAuthority&gt;(); for (Role role : roles) &#123; authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.getName())); &#125; for (Permission permission : permissions) &#123; authorities.add(new SimpleGrantedAuthority(permission.getName())); &#125; return new UserSecurity(user,authorities); &#125;else&#123; return null; &#125; &#125;&#125; 调整配置SecurityConfig的配置123456789101112131415161718192021222324252627282930@Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests()//HttpServletRequest请求认证 //放行路径 不需要认证 .antMatchers(&quot;/css/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() //form表单登录方式 .and() .csrf().disable() //关闭CSRF .formLogin().loginPage(&quot;/login&quot;) //表示登录时候 跳转的页面 .loginProcessingUrl(&quot;/form&quot;) //form表单登录请求 .defaultSuccessUrl(&quot;/index&quot;) //成功登陆后跳转页面 .failureUrl(&quot;/loginError&quot;).permitAll();//失败错误跳转 //权限不够返回处理 http.exceptionHandling().accessDeniedHandler(new AccessDeniedHandler() &#123; @Override public void handle(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e) throws IOException, ServletException &#123; String type = req.getHeader(&quot;X-Requested-With&quot;); if(&quot;XMLHttpRequest&quot;.equals(type))&#123; resp.getWriter().print(&quot;403&quot;); &#125;else&#123; req.getRequestDispatcher(&quot;/error403&quot;).forward(req,resp); &#125; &#125; &#125;); &#125; 在类上面添加注解 开启权限控制 1@EnableGlobalMethodSecurity(prePostEnabled = true)//开启细粒度控制 添加UserController进行测试123456789101112131415161718/** * @Author: Mark * @Decription:UserController */@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private IUserService userService; @RequestMapping(&quot;/list&quot;) @ResponseBody @PreAuthorize(&quot;hasRole(&#x27;管理员&#x27;)&quot;) public List&lt;User&gt; queryAll()&#123; return userService.findAll(); &#125;&#125; 测试如果没有权限就会跳转没有权限的页面 11 访问权限核心原理流程图 –源码解析该小节主要对授权的源码进行讲解，有助于更加深刻的理解。 源码说明在注解 @EnableWebSecurity 引用了 WebSecurityConfiguration 配置类 和 @EnableGlobalAuthentication WebSecurityConfiguration 就是与授权相关的配置；该类的源码里面有个 springSecurityFilterChain() 方法 ，就去执行一堆过滤器 (这个过滤器就形成过滤器链)。如果下图。 FilterSecurityInterceptor 是整个Security filter链中的最后一个，同时它也是最重要的一个，它的主要功能就是判断认证成功的用户是否有 权限访问接口，其最主要的处理方法就是 调用父类（AbstractSecurityInterceptor）的 super.beforeInvocation() 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263protected InterceptorStatusToken beforeInvocation(Object object) &#123; Assert.notNull(object, &quot;Object was null&quot;); boolean debug = this.logger.isDebugEnabled(); if (!this.getSecureObjectClass().isAssignableFrom(object.getClass())) &#123; throw new IllegalArgumentException(&quot;Security invocation attempted for object &quot; + object.getClass().getName() + &quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot; + this.getSecureObjectClass()); &#125; else &#123; //获取当前访问地址所需要的权限信息 Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object); if (attributes != null &amp;&amp; !attributes.isEmpty()) &#123; if (debug) &#123; this.logger.debug(&quot;Secure object: &quot; + object + &quot;; Attributes: &quot; + attributes); &#125; if (SecurityContextHolder.getContext().getAuthentication() == null) &#123; this.credentialsNotFound(this.messages.getMessage(&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;, &quot;An Authentication object was not found in the SecurityContext&quot;), object, attributes); &#125; //获取当前用户所需要的权限信息 Authentication authenticated = this.authenticateIfRequired(); //使用投票机制 判断失败 直接返回异常 try &#123; this.accessDecisionManager.decide(authenticated, object, attributes); &#125; catch (AccessDeniedException var7) &#123; this.publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, var7)); throw var7; &#125; if (debug) &#123; this.logger.debug(&quot;Authorization successful&quot;); &#125; if (this.publishAuthorizationSuccess) &#123; this.publishEvent(new AuthorizedEvent(object, attributes, authenticated)); &#125; Authentication runAs = this.runAsManager.buildRunAs(authenticated, object, attributes); if (runAs == null) &#123; if (debug) &#123; this.logger.debug(&quot;RunAsManager did not change Authentication object&quot;); &#125; return new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object); &#125; else &#123; if (debug) &#123; this.logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs); &#125; SecurityContext origCtx = SecurityContextHolder.getContext(); SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext()); SecurityContextHolder.getContext().setAuthentication(runAs); return new InterceptorStatusToken(origCtx, true, attributes, object); &#125; &#125; else if (this.rejectPublicInvocations) &#123; throw new IllegalArgumentException(&quot;Secure object invocation &quot; + object + &quot; was denied as public invocations are not allowed via this interceptor. &quot; + &quot;This indicates a configuration error because the &quot; + &quot;rejectPublicInvocations property is set to &#x27;true&#x27;&quot;); &#125; else &#123; if (debug) &#123; this.logger.debug(&quot;Public object - authentication not attempted&quot;); &#125; this.publishEvent(new PublicInvocationEvent(object)); return null; &#125; &#125; &#125; 12 权限系统登录功能实现要实现登录功能,需要把对应的界面引入 引入管理系统页面系统的页面采用HTML+JS+Jquery+Bootstrap,如果还不会这些的同学，请查看对应的教程.页面是采用bootstrap+thymeleaf结合而成的. 没有使用JSP技术，springboot官方已经基本在淘汰JSP技术. 拷贝资料里面 static 和 templates文件夹到项目中 跳转页面 启动跳转到登录 登录之后的主页 调整LoginController类的 方法 12345678910//跳转登录页面 @RequestMapping(&quot;/login&quot;) public String userLogin() &#123; return &quot;views/login&quot;; &#125; //登录成功 @RequestMapping(&quot;/index&quot;) public String index() &#123; return &quot;views/index&quot;; &#125; 添加静态资源放行 1234.antMatchers( &quot;/static/upload/**&quot;, &quot;/static/**&quot;) .permitAll() 启动项目 就会出现登录页面 完成登录功能查看登录页面 login.html 的登录方法 是一个ajax提交 12345678910111213141516171819function goLogin()&#123; //注册 var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); //验证通过 $.ajax(&#123; url: &quot;/form&quot;, type: &quot;POST&quot;, data: &#123;&quot;username&quot;:username,&quot;password&quot;:password&#125;, success: function (data) &#123; if (data.isSuccess) &#123; window.location.href=&quot;/index&quot; &#125; else&#123; $(&quot;#errorInfo&quot;).css(&#x27;display&#x27;,&quot;block&quot;); $(&quot;#errorInfo&quot;).html(&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;+data.message+&quot;&lt;/span&gt;&quot;); &#125; &#125; &#125;); &#125; url: 就是后台处理登录的请求地址，我们配置的 .loginProcessingUrl(“&#x2F;form”) 。所有调整url的请求地址为&#x2F;form 这是一个ajax请求，有返回的数据 。返回的数据是JSON格式，也就意味着后台登录返回的JSON格式的数据. {code:20000,message: 操作信息} 把 SecurityConfig配置里面的 .defaultSuccessUrl(“&#x2F;index”)修改成 successHandler(myAuthenctiationSuccessHandler); 通过myAuthenctiationSuccessHandler这个类来处理登录成功之后的结果 1234567891011121314151617181920212223242526272829303132protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests()//HttpServletRequest请求认证 //放行路径 不需要认证 .antMatchers( &quot;/static/upload/**&quot;, &quot;/static/**&quot;) .permitAll() .anyRequest().authenticated() .and() .formLogin() //form表单登录方式 .and() .csrf().disable() //关闭CSRF .formLogin().loginPage(&quot;/login&quot;) //表示登录时候 跳转的页面 .loginProcessingUrl(&quot;/form&quot;) //form表单登录请求 .successHandler(myAuthenctiationSuccessHandler) .failureUrl(&quot;/loginError&quot;).permitAll();//失败错误跳转 //权限不够返回处理 http.exceptionHandling().accessDeniedHandler(new AccessDeniedHandler() &#123; @Override public void handle(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e) throws IOException, ServletException &#123; String type = req.getHeader(&quot;X-Requested-With&quot;); if(&quot;XMLHttpRequest&quot;.equals(type))&#123; resp.getWriter().print(&quot;403&quot;); &#125;else&#123; req.getRequestDispatcher(&quot;/error403&quot;).forward(req,resp); &#125; &#125; &#125;); &#125; 自定义登录成功之后的处理类 MyAuthenctiationSuccessHandler 1234567891011@Componentpublic class MyAuthenctiationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException, IOException &#123; response.setContentType(&quot;application/json;charset=utf-8&quot;); RequestCache cache = new HttpSessionRequestCache(); SavedRequest savedRequest = cache.getRequest(request, response); String jsonStr = &quot;&#123;\\&quot;isSuccess\\&quot;:true&#125;&quot;; response.getWriter().print(jsonStr); &#125;&#125; 失败的处理 LoginController 123456789101112//登录成功 @RequestMapping(&quot;/index&quot;) public String index() &#123; return &quot;views/index&quot;; &#125; //登录失败 @RequestMapping(&quot;/loginError&quot;) @ResponseBody public MzResult loginError() &#123; return new MzResult(&quot;用户名或者密码不正确&quot;); &#125; 新增MzResult结果处理类 123456789101112131415@Datapublic class MzResult &#123; private Boolean isSuccess = true; private String message = &quot;操作成功&quot;; public MzResult(String message) &#123; this.isSuccess = false; this.message = message; &#125; public MzResult() &#123; &#125;&#125; 登录成功之后: 系统主页 温馨提示13 权限系统登录功能实现在后台的SecurityConfig.java 配置类中添加注销功能 123//注销功能 http.logout().logoutSuccessUrl(&quot;/login&quot;) .invalidateHttpSession(true); 在common&#x2F;include.html 里面 添加退出登录 1&lt;li&gt; &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;&lt;i class=&quot;mdi mdi-logout-variant&quot;&gt;&lt;/i&gt; 退出登录&lt;/a&gt; &lt;/li&gt; 温馨提示下一篇请看权限管理系统2","categories":[],"tags":[]},{"title":"uniapp打包成H5部署到服务器教程","slug":"uniapp打包成H5部署到服务器教程","date":"2020-07-20T03:20:31.000Z","updated":"2022-09-01T01:09:23.203Z","comments":true,"path":"2020/07/20/uniapp打包成H5部署到服务器教程/","link":"","permalink":"http://example.com/2020/07/20/uniapp%E6%89%93%E5%8C%85%E6%88%90H5%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"uniapp打包成H5部署到服务器教程当前端uniapp写的项目开发完成的时候，需要将页面打包出来，生成H5的静态文件，部署在服务器上，通过服务器链接地址，就可以直接在手机上点开访问 了。 在网上看了一圈，好像没有找到十分详细的教程，这里稍微详细的记录了一下，uniapp打包成H5部署到服务器教程。 步骤如下： 1：点击菜单栏发行，点击选择网站-H5手机版， 2：在网站域名这一栏填写，网站域名，例如www.xxx.com或者你的服务器的IP地址47.103.XX.XX，（这个地址是你将项目打包之后存放放静态文件的地址）。 我这里为了考虑到安全因素，将自己的服务器地址马赛克了。 3：点击高级按钮，进入到manifest.json的h5配置里面，根据自己的情况配置一些信息，我这里是默认的。 一定要注意配置运行时候的基础路径（下图红色框标记的地方），如果出现空白页面或者静态文件404的情况，可能是因为这个路径没有配置好。 （多嘴一句，这个运行的基础路径，是和编译之后的静态文件的文件夹是一致的，默认是h5，我这里改名字了，我这里将静态文件h5的文件夹改成了work项目需要）。 4：点击发行，控制台会自动编译注意这个不同于vue，编译完成的文件不支持本地file协议打开。不要使用资源管理器直接打开。直接打开静态文件是看不到东西的。出现以下提示，说明编译成功 5：编译通过，生成静态的h5文件，我们需要将这个h5的文件，部署到我们前面填写的域名（或者服务器的ip）的根目录底下。 （这个h5在上传到服务器的时候，可以自己命名，我命名成work了，命名需要和发布之前的高级配置里面路径保持一致）。 6：找一个工具，连接自己的服务器，进入到自己的服务器的根目录底下。 我这里用的是Xftp工具。，我在根目录底下新建了一个work,（即静态H5的文件夹重命名了） 将static文件夹喝index.html复制进去 图片.png 好的，这个时候就已经部署成功了。 7：打开浏览器，输入服务器ip地址，访问一下index.html的内容吧http://47.10x.xx.78:8091/work/index.html#/主机ip和端口号也要注意，这里是我的主机和端口号，隐藏起来了。 8：注意，这三个地方的路径名称一定要一致哦。1：打包时候的配置的运行的基础路径2：服务器根目录底下存放静态文件static和index.html3：浏览器里面访问的路径 OK，这样就结束了，皆大欢喜，撒花","categories":[],"tags":[]},{"title":"Java中的设计模式","slug":"Java中的设计模式","date":"2020-07-03T08:15:24.000Z","updated":"2022-09-03T08:25:10.569Z","comments":true,"path":"2020/07/03/Java中的设计模式/","link":"","permalink":"http://example.com/2020/07/03/Java%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Java中的设计模式设计模式在开发设计中，被反复使用的一种代码设计经验，使用设计模式的目的是为了可重用代码，提高代码的可扩展性和维护性 单例模式在一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修改 ，一般是通过getInstance()的方法来获取他们的实例 工厂模式一种创建性模式，它提供了一种创建对象的最佳方式，在工厂模式当中，创建对象不会暴露客户端创建逻辑，并且是通过使用一个共同接口来指向新创建对象的。 适配器模式作为两个不兼容的接口之间的桥梁，这种类型的设计模式属于结构型设计模式，它结合了两个独立接口的能力，这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。 观察者模式当对象存在一对多的关系时，则使用，当一个对象被修改时，则会自动通知依赖它的对象，观察者模式属于行为型模式。","categories":[],"tags":[]},{"title":"Java中的锁","slug":"Java中的锁","date":"2020-05-12T08:27:28.000Z","updated":"2022-09-03T08:28:22.360Z","comments":true,"path":"2020/05/12/Java中的锁/","link":"","permalink":"http://example.com/2020/05/12/Java%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"带你彻底理解Java中的21种锁 1、乐观锁 乐观锁是一种乐观思想，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。 Java中的乐观锁： CAS，比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作 2、悲观锁 悲观锁是一种悲观思想，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。 Java中的悲观锁： synchronized修饰的方法和方法块、ReentrantLock。 3、自旋锁 自旋锁是一种技术： 为了让线程等待，我们只须让线程执行一个忙循环（自旋）。 现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。 自旋锁的优点： 避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。 自旋锁的缺点： 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。 自旋次数默认值：10次，可以使用参数-XX:PreBlockSpin来自行更改。 自适应自旋： 自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。 Java中的自旋锁： CAS操作中的比较操作失败后的自旋等待。 4、可重入锁（递归锁） 可重入锁是一种技术： 任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。 可重入锁的原理： 通过组合自定义同步器来实现锁的获取与释放。 再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。获取锁后，进行计数自增， 释放锁：释放锁时，进行计数自减。 Java中的可重入锁： ReentrantLock、synchronized修饰的方法或代码段。 可重入锁的作用： 避免死锁。 面试题1： 可重入锁如果加了两把，但是只释放了一把会出现什么问题？ 答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。 面试题2： 如果只加了一把锁，释放两次会出现什么问题？ 答：会报错，java.lang.IllegalMonitorStateException。 5、读写锁 读写锁是一种技术： 通过ReentrantReadWriteLock类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。 读锁： 允许多个线程获取读锁，同时访问同一个资源。 写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。 Java中的读写锁：ReentrantReadWriteLock 6、公平锁 公平锁是一种思想： 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。 7、非公平锁 非公平锁是一种思想： 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。 优点： 非公平锁的性能高于公平锁。 缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁） Java中的非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。 8、共享锁 共享锁是一种思想： 可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。 Java中用到的共享锁： ReentrantReadWriteLock。 9、独占锁 独占锁是一种思想： 只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。 Java中用到的独占锁： synchronized，ReentrantLock 10、重量级锁 重量级锁是一种称谓： synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 Mutex Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁，偏向锁。 Java中的重量级锁： synchronized 11、轻量级锁 轻量级锁是JDK6时加入的一种锁优化机制： 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。 优点： 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。 缺点： 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。 12、偏向锁 偏向锁是JDK6时加入的一种锁优化机制： 在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。 优点： 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。 缺点： 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。 13、分段锁 分段锁是一种机制： 最好的例子来说明分段锁是ConcurrentHashMap。ConcurrentHashMap原理：它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。 线程安全：ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全 14、互斥锁 互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问。 读-读互斥 读-写互斥 写-读互斥 写-写互斥 Java中的同步锁： synchronized 15、同步锁 同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java中的同步锁： synchronized 16、死锁 死锁是一种现象：如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。 Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁。 17、锁粗化 锁粗化是一种优化技术： 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。 18、锁消除 锁消除是一种优化技术： 就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。 那如何判断共享数据不会被线程竞争？ 利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。 在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。 19、synchronized synchronized是Java中的关键字：用来修饰方法、对象实例。属于独占锁、悲观锁、可重入锁、非公平锁。 1.作用于实例方法时，锁住的是对象的实例(this)； 2.当作用于静态方法时，锁住的是 Class类，相当于类的一个全局锁， 会锁所有调用该方法的线程； 3.synchronized 作用于一个非 NULL的对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。 20、Lock和synchronized的区别 Lock： 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。 1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别 2.Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。 3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 4.Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 5.通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。 synchronized的优势： 足够清晰简单，只需要基础的同步功能时，用synchronized。 Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。 使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。 21、ReentrantLock 和synchronized的区别 ReentrantLock是Java中的类 ： 继承了Lock类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。 划重点 相同点： 1.主要解决共享变量如何安全访问的问题 2.都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁， 3.保证了线程安全的两大特性：可见性、原子性。 不同点： 1.ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法， synchronized 隐式获得释放锁。 2.ReentrantLock 可响应中断， synchronized 是不可以响应中断的，ReentrantLock 为处理锁的不可用性提供了更高的灵活性 3.ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的 4.ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，synchronized 是非公平锁，且不可更改。 5.ReentrantLock 通过 Condition 可以绑定多个条件","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"函数式接口","slug":"函数式接口","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"Stream流使用笔记","slug":"Stream流使用笔记","permalink":"http://example.com/tags/Stream%E6%B5%81%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"name":"提高生产力，最全 MyBatisPlus 讲解！","slug":"提高生产力，最全-MyBatisPlus-讲解！","permalink":"http://example.com/tags/%E6%8F%90%E9%AB%98%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%8C%E6%9C%80%E5%85%A8-MyBatisPlus-%E8%AE%B2%E8%A7%A3%EF%BC%81/"},{"name":"SQL强化2","slug":"SQL强化2","permalink":"http://example.com/tags/SQL%E5%BC%BA%E5%8C%962/"},{"name":"SQL强化1","slug":"SQL强化1","permalink":"http://example.com/tags/SQL%E5%BC%BA%E5%8C%961/"},{"name":"Docker部署SpringBoot项目","slug":"Docker部署SpringBoot项目","permalink":"http://example.com/tags/Docker%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/"},{"name":"VueAdmin部署","slug":"VueAdmin部署","permalink":"http://example.com/tags/VueAdmin%E9%83%A8%E7%BD%B2/"},{"name":"VueAdmin前端","slug":"VueAdmin前端","permalink":"http://example.com/tags/VueAdmin%E5%89%8D%E7%AB%AF/"},{"name":"VueAdmin后端","slug":"VueAdmin后端","permalink":"http://example.com/tags/VueAdmin%E5%90%8E%E7%AB%AF/"}]}